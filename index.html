<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="我的计算机学习经历和笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="崔梓坤的个人博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="崔梓坤的个人博客">
<meta property="og:description" content="我的计算机学习经历和笔记">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="崔梓坤">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>崔梓坤的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">崔梓坤的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/13/C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8CC%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="崔梓坤">
      <meta itemprop="description" content="我的计算机学习经历和笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="崔梓坤的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/13/C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8CC%E5%BA%93/" class="post-title-link" itemprop="url">C预处理器和C库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-13 18:29:31 / 修改时间：18:33:13" itemprop="dateCreated datePublished" datetime="2020-06-13T18:29:31+08:00">2020-06-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="C预处理器"><a href="#C预处理器" class="headerlink" title="C预处理器"></a>C预处理器</h2><p>C预处理器在程序执行之前查看程序（故称之为预处理器）。根据程序的预处理器指令，预处理器把符号缩写替换成其表示的内容、预处包含程序所需的其他文件、以告诉编译器应该查看哪些代码。</p>
<h3 id="翻译程序的第一步"><a href="#翻译程序的第一步" class="headerlink" title="翻译程序的第一步"></a>翻译程序的第一步</h3><p>在预处理之前，编译器必须对该程序进行一些翻译处理</p>
<ul>
<li><p>第一步：把源代码中出现的字符映射到源字符集。该过程处理多字节字符和三字符序列；</p>
</li>
<li><p>第二步：编译器定位每个反斜杠<code>\</code>后面跟着换行符的实例，并删除它们。也就是说，把下面两个物理行(physical line)转换成一个逻辑行(logic line) ，预处理中预处理表达式的长度必须是一个逻辑行；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个物理行</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"That's wond\</span></span><br><span class="line"><span class="string">erful!\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转化为一个逻辑行</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"That's wonderful!\n"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>第三步：编译器把文本划分成预处理记号(token)序列、空白(whitespace)序列和注释序列（记号是由空格、制表符或换行符分隔的项)。这里要注意的是，编译器将用一个空格字符替换每一条注释。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span><span class="comment">/*looks not like a space*/</span>fox;</span><br></pre></td></tr></table></figure>

<p>将变成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fox;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，程序已经准备好进入预处理阶段，预处理器查找一行中以#号开始的预处理指令。</p>
</li>
</ul>
<h3 id="define"><a href="#define" class="headerlink" title="#define"></a>#define</h3><p><strong>两个重点：</strong></p>
<ul>
<li>预处理器指令从#开始运行，到后面的第1个换行符为止。也就是说，指令的长度仅限于一行。</li>
<li>预处理指令可以出现在源代码文件的任何地方，其定义从指令出现的地方到该文件末尾有效。</li>
</ul>
<p><strong>每行#define（逻辑行）都由3部分组成：</strong></p>
<ul>
<li><strong>第1部分</strong>：#define指令本身。ANSI和后来的标准都允许#号前面有空格或制表符，而且还允许在#和指令的其余部分之间有空格。但是旧版本的C要求指令从一行最左边开始， 而且#和指令其余部分之间不能有空格。</li>
<li><strong>第2部分</strong>：选定的缩写，也称为宏(macro)。可以分为对象宏(object-like macro)和函数宏(function-like macro)。<strong>宏的名称中不允许有空格</strong>，而且必须遵循C变量的命名规则：只能使用字符、数字和下划线（_）字符，而且首字符不能是数字；</li>
<li><strong>第3部分</strong>：替换列表或替换体，一旦预处理器在程序中找到宏的示实例后，就会用替换体代替该宏。从宏变成最终替换文本的过程称为宏展开(macro expansion)</li>
</ul>
<img src="https://gitee.com/Carlisle345748/cloudimg/raw/master/img/macro.png" style="zoom:50%;" />

<p><strong>宏可以表示常量、字符串、C表达式、空宏：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TWO 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOUR TWO*TWO</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WORD <span class="meta-string">"I am a macro"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PR printf(<span class="meta-string">"I work as a expression\n"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NONE</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = FOUR;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, TWO, x);</span><br><span class="line">  <span class="built_in">puts</span>(WORD);</span><br><span class="line">  PR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2 4</span></span><br><span class="line"><span class="comment">I am a macro</span></span><br><span class="line"><span class="comment">I work as a expression</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>有人可能认为FOUR被替换成4，但是实际的过程是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = FOUR;</span><br><span class="line">x = TWO*TWO;</span><br><span class="line">x = <span class="number">2</span>*<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>宏展开到此处为止，不会计算2<em>2然后变成x=4。由于编译器在编译期对所有的常量表达式（只包含常量的表达式）求值，所以*</em>预处理器不会进行实际的乘法运算，这一过程在 编译时进行。预处理器不做计算，不对表达式求值，它只进行替换。**</p>
<p>同时，需要注意，#define指令的作用域是其出现的地方到文件末尾，因此必须要先定义TWO，才能定义FOUR。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOUR TWO*TWO   <span class="comment">// 错误，TWO还没定义</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TWO 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOUR TWO*TWO   <span class="comment">// 正确</span></span></span><br></pre></td></tr></table></figure>



<p><strong>双引号中的宏不会替换</strong></p>
<p>一般而言，预处理器发现程序中的宏后，会用宏等价的替换文本进行替换。如果替换的字符串中还包含宏，则继续替换这些宏。唯一例外的是双引号中的宏。因此，下面的语句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TWO 2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"TWO\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">打印结果：</span></span><br><span class="line"><span class="comment">TOW</span></span><br><span class="line"><span class="comment">而不是：</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="记号-token"><a href="#记号-token" class="headerlink" title="记号(token)"></a>记号(token)</h4><p>从技术角度来看，可以把宏的替换体看作是记号（token）型字符串， 而不是字符型字符串。C预处理器记号是宏定义的替换体中单独的“词”。用空白把这些词分开。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOUR 2*2</span></span><br></pre></td></tr></table></figure>

<p>该宏定义有一个记号：<code>2*2</code>序列。但是，下面的宏定义中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOUR 2 * 3</span></span><br></pre></td></tr></table></figure>

<p>有3个记号：<code>2</code>、<code>*</code>、<code>3</code>。</p>
<p>替换体中有多个空格时，字符型字符串和记号型字符串的处理方式不 同。考虑下面的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EIGHT 4  *  8</span></span><br></pre></td></tr></table></figure>

<p>如果预处理器把该替换体解释为字符型字符串，将用<code>4  *  8</code>替换EIGHT。 即，额外的空格是替换体的一部分。如果预处理器把该替换体解释为记号型字符串，则用3个记号<code>4 * 8</code>（分别由单个空格分隔）来替换EIGHT。换而言之，解释为字符型字符串，把空格视为替换体的一部分；解释为记号型字 符串，把空格视为替换体中各记号的分隔符</p>
<h4 id="在-define中使用参数"><a href="#在-define中使用参数" class="headerlink" title="在#define中使用参数"></a>在#define中使用参数</h4><p>在#define中使用参数可以创建外形和作用与函数类似的类函数宏(function-like macro)。</p>
<img src="https://gitee.com/Carlisle345748/cloudimg/raw/master/img/类函数宏.png" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQUARE(X) ((X)*(X))</span></span><br><span class="line"><span class="keyword">int</span> z;</span><br><span class="line">z = SQUARE(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>这看上去像函数调用，但是它的行为和函数调用完全不同，并且注意到在定义中使用了很多括号。下面的例子演示了类函数宏和另一个宏的用法。该示例中有一些陷阱，在使用类函数宏的时候一定要注意（括号就是用来避开陷阱的）。</p>
<p><strong>常见陷阱：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQUARE(X) X*X</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PR(X) printf(<span class="meta-string">"The result is %d.\n"</span>, X)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"x = %d\n"</span>, x);</span><br><span class="line">    z = SQUARE(x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Evaluating SQUARE(x): "</span>);</span><br><span class="line">    PR(z);</span><br><span class="line">    z = SQUARE(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Evaluating SQUARE(2): "</span>);</span><br><span class="line">    PR(z);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Evaluating SQUARE(x+2): "</span>);</span><br><span class="line">    PR(SQUARE(x+<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Evaluating 100/SQUARE(2): "</span>);</span><br><span class="line">    PR(SQUARE(<span class="number">100</span>/SQUARE(<span class="number">2</span>)));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"x is %d\n"</span>, x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Evaluating 100/SQUARE(++x): "</span>);</span><br><span class="line">    PR(SQUARE(++x));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">x = 5</span></span><br><span class="line"><span class="comment">Evaluating SQUARE(x): The result is 25.</span></span><br><span class="line"><span class="comment">Evaluating SQUARE(2): The result is 4.</span></span><br><span class="line"><span class="comment">Evaluating SQUARE(x+2): The result is 17.</span></span><br><span class="line"><span class="comment">Evaluating 100/SQUARE(2): The result is 100.</span></span><br><span class="line"><span class="comment">x is 5</span></span><br><span class="line"><span class="comment">Evaluating 100/SQUARE(++x): The result is 42.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>前两行与预期相符，但是接下来的结果有点奇怪。程序中设置x的值为5，你可能认为<code>SQUARE(x+2)</code>应该是 <code>7*7</code>，即 49。但是输出结果是17。这是因为预处理器不做计算，只做替换，所以<code>SQUARE(x+2)</code>实际变成了<code>x+2*x+2</code>，结果为17。</p>
<p>同样，<code>100/SQUARE(2)</code>替换为<code>100/2*2</code>，所以结果还是100。<code>SQUARE(++x)</code>被替换为<code>++x*++x</code>，递增了两次x，一次在乘法运算之前，一次在乘法运算之后：由于标准并未对这类运算规定顺序，所以有些编译器得<code>7*6</code>。而有些编 译器可能在乘法运算之前已经递增了x，所以<code>7*7</code>得49。</p>
<p><strong>解决方法：</strong></p>
<p>在替换体中使用圆括号使其得到符合预期的乘法运算，时要使用足够多的圆括号来确保运算和结合的正确顺序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQUARE(X) ((X)*(X))</span></span><br></pre></td></tr></table></figure>



<h5 id="用宏参数创建字符串-运算符"><a href="#用宏参数创建字符串-运算符" class="headerlink" title="用宏参数创建字符串: #运算符"></a>用宏参数创建字符串: #运算符</h5><p>预处理器不会替换双引号字符串中宏，但是有时候我们需要实现这样的功能，就可以使用预处理运算符<code>#</code>。<code>#</code>作为一个预处理运算符，可以把记号(token)转换成字符串。例如，如果x是一个宏形参，那 么#x就是转换为字符串”x”的形参名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSQR(X) printf(<span class="meta-string">"The square of "</span>#X<span class="meta-string">" is %d\n"</span>, ((X)*(X)))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">5</span>;</span><br><span class="line">    PSQR(y);</span><br><span class="line">    PSQR(<span class="number">2</span> + <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">The square of y is 25</span></span><br><span class="line"><span class="comment">The square of 2 + 4 is 36</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>调用第1个宏时，用<code>&quot;y&quot;</code>替换<code>#x</code>。调用第2个宏时，用<code>&quot;2 + 4&quot;</code>替换<code>#x</code>。 ANSI C字符串的串联特性将这些字符串与printf()语句的其他字符串组合，生成最终的字符串。例如，第1次调用变成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"The square of "</span><span class="string">"y"</span><span class="string">" is %d\n"</span>, ((y)*(y))))</span><br></pre></td></tr></table></figure>

<p>然后，字符串串联功能将这3个相邻的字符串组合成一个字符串：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"The square of y is %d\n"</span>, ((y)*(y))));</span><br></pre></td></tr></table></figure>



<h5 id="预处理器黏合剂-运算符"><a href="#预处理器黏合剂-运算符" class="headerlink" title="预处理器黏合剂: ##运算符"></a>预处理器黏合剂: ##运算符</h5><p>与#运算符类似，##运算符可用于类函数宏的替换部分。而且，##还可用于对象宏的替换部分。##运算符把两个记号组合成一个记号。例如，可以这样做：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XNAME(n) x##n</span></span><br></pre></td></tr></table></figure>

<p>然后，宏XNAME(4)将展开为x4。下面是更多例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XNAME(n) x ## n</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT_XN(n) printf(<span class="meta-string">"x"</span> #n <span class="meta-string">" = %d\n"</span>, x ## n)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">XNAME</span><span class="params">(<span class="number">1</span>)</span> </span>= <span class="number">14</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">XNAME</span><span class="params">(<span class="number">2</span>)</span> </span>= <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> x3 = <span class="number">30</span>;</span><br><span class="line">    PRINT_XN(<span class="number">1</span>);</span><br><span class="line">    PRINT_XN(<span class="number">2</span>);</span><br><span class="line">    PRINT_XN(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">x1 = 14</span></span><br><span class="line"><span class="comment">x2 = 20</span></span><br><span class="line"><span class="comment">x3 = 30</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>PRINT_XN()宏用#运算符组合字符串，##运算符把记号组合为一个标识符。</p>
<h5 id="变参宏：-和-VA-ARGS"><a href="#变参宏：-和-VA-ARGS" class="headerlink" title="变参宏：...和__VA_ARGS__"></a>变参宏：<code>...</code>和<code>__VA_ARGS__</code></h5><p>一些函数，如 printf()接受数量可变的参数。stdvar.h 头文件提供了工具，让用户自定义带可变参数的函数。在类函数宏中，也可以实现这一功能。</p>
<p>通过把宏参数列表中最后的参数写成省略号（即，3个点<code>...</code>）来实现这 一功能。这样，预定义宏<code>__VA_ARGS__</code>可用在替换部分中，表面省略号代表了什么，比如以下定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PR(...) printf(__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line">PR(<span class="string">"Howdy"</span>);</span><br><span class="line">PR(<span class="string">"weight = %d, shipping = $%.2f\n"</span>, wt, sp);</span><br></pre></td></tr></table></figure>

<p>对于第1次调用，<code>_ _VA_ARGS_ _</code>展开为1个参数：<code>&quot;Howdy&quot;</code>。</p>
<p>对于第2次调用，<code>_ _VA_ARGS_ _</code>展开为3个参数：<code>&quot;weight shipping = $%.2f\n&quot;</code>、<code>wt</code>、<code>sp</code>。</p>
<p>宏展开后的代码为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Howdy"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"weight = %d, shipping = $%.2f\n"</span>, wt, sp);</span><br></pre></td></tr></table></figure>



<h5 id="宏和函数的选择"><a href="#宏和函数的选择" class="headerlink" title="宏和函数的选择"></a>宏和函数的选择</h5><p>有些编程任务既可以用带参数的宏完成，也可以用函数完成。应该使用宏还是函数？</p>
<p><strong>类函数宏</strong>：</p>
<ul>
<li><p>优点</p>
<ul>
<li>节省了函数和主调函数之间跳转的时间</li>
<li>不用担心变量类型的问题，int和float都可以使用SQUARE(X)宏</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>使用宏比使用普通函数复杂一些，稍有不慎会产生奇怪的副作用。一些编译器规定宏只能定义成一行。</li>
<li>宏生成内联代码，即在程序中生成语句。如果调用20次宏，即在程序中插入20行代码。如果调用函数 20次，程序中只有一份函数语句的副本。所以宏占用更多空间</li>
</ul>
</li>
</ul>
<p>如果打算使用宏来加快程序的运行速度，那么首先要确定使用宏和使用函数是否会导致较大差异。在程序中只使用一次的宏无法明显减少程序的运行时间。在嵌套循环中使用宏更有助于提高效率。</p>
<h3 id="include"><a href="#include" class="headerlink" title="#include"></a>#include</h3><p>当预处理器发现#include 指令时，会查看后面的文件名并把文件的内容包含到当前文件中，即替换源文件中的#include指令。这相当于把被包含文 件的全部内容输入到源文件#include指令所在的位置。#include指令有两种形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"myheader.h"</span></span></span><br></pre></td></tr></table></figure>

<p>在 UNIX 系统中，<code>&lt;&gt;</code>告诉预处理器在标准系统目录中查找该文件。 <code>&quot;&quot;</code>告诉预处理器首先在当前目录中（或文件名中指定的其他目录）查找该文件，如果未找到再查找标准系统目录。</p>
<p>集成开发环境（IDE）也有标准路径或系统头文件的路径。许多集成开发环境提供菜单选项，指定用尖括号时的查找路径。在 UNIX 中，使用双引号意味着先查找本地目录，但是具体查找哪个目录取决于编译器的设定。有些编译器会搜索源代码文件所在的目录，有些编译器则搜索当前的工作目 录，还有些搜索项目文件所在的目录。</p>
<p><strong>包含一个大型头文件不一定显著增加程序的大小。在大部分情况下，头文件的内容是编译器生成最终代码时所需的信息，而不是添加到最终代码中 的材料。</strong></p>
<h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><p><strong>头文件中最常用的形式和内容如下：</strong></p>
<ul>
<li>明示常量：#define定义的各种明示常量</li>
<li>宏函数：如，getc(stdin)通常定义为getchar()。</li>
<li>结构模型：如标准I/O使用的FILE结构，其中包含了文件和文件缓冲区的相关信息。</li>
<li>类型定义：标准 I/O 函数使用指向 FILE 的指针作为参数。通常， stdio.h 用#define 或typedef把FILE定义为指向结构的指针。类似地，size_t和 time_t类型也定义在头文件中。</li>
</ul>
<p><strong>在多文件中共享变量</strong></p>
<p>还可以使用头文件声明外部变量供其他文件共享。例如，如果已经开发了共享某个变量的一系列函数，该变量报告某种状况（如，错误情 况），这种方法就很有效。这种情况下，可以在包含这些函数声明的源代码文件定义一个文件作用域的外部链接变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> status = <span class="number">0</span>;    　<span class="comment">// 该变量具有文件作用域，在源代码文件</span></span><br></pre></td></tr></table></figure>

<p>然后，可以在与源代码文件相关联的头文件中进行引用式声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> status;  <span class="comment">// 在头文件中</span></span><br></pre></td></tr></table></figure>

<p>这行代码会出现在包含了该头文件的文件中，这样使用该系列函数的文件都能使用这个变量。<strong>虽然源代码文件中包含该头文件后也包含了该声明， 但是只要声明的类型一致，在一个文件中同时使用定义式声明和引用式声明没问题。</strong></p>
<p><strong>使用具有文件作用域、内部链接和const限定符的变量或数组</strong></p>
<p>const 防止值被意外修改，static 意味着每个包含该头文件的文件都获得一份副本。因此，不需要在一个文件中进行定义式声明，在其他文件中进行引用式声明。</p>
<h3 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h3><p>预处理器提供一些指令，程序员通过修改#define的值即可生成可移植的代码。#undef指令取消之前的#define定义。#if、#ifdef、 #ifndef、#else、#elif和#endif指令用于指定什么情况下编写哪些代码。#line 指令用于重置行和文件信息，#error指令用于给出错误消息，#pragma指令用 于向编译器发出指令。</p>
<h4 id="undef"><a href="#undef" class="headerlink" title="#undef"></a>#undef</h4><p>#undef指令用于“取消”已定义的#define指令。也就是说，假设有如下定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIMIT 400</span></span><br></pre></td></tr></table></figure>

<p>然后，下面的指令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> LIMIT</span></span><br></pre></td></tr></table></figure>

<p>将移除上面的定义。现在就可以把LIMIT重新定义为一个新值。即使原 来没有定义LIMIT，取消LIMIT的定义仍然有效。如果想使用一个名称，又不确定之前是否已经用过，为安全起见，可以用#undef 指令取消该名字的定义。</p>
<h4 id="预处理器定义"><a href="#预处理器定义" class="headerlink" title="预处理器定义"></a>预处理器定义</h4><p>当预处理器 在预处理器指令中发现一个标识符时，它会把该标识符当作已定义的或未定义的。这里的已定义表示由<strong>预处理器定义</strong>。如果标识符是同一个文件中由前面的#define指令创建的宏名，而且没有用#undef 指令关闭，那么该标识符是已定义的。如果标识符不是宏，假设是一个文件作用域的C变量，那么该标识符对预处理器而言就是未定义的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIMIT 1000   <span class="comment">// LIMIT是已定义的</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GOOD         <span class="comment">// GOOD是已定义的</span></span></span><br><span class="line"><span class="keyword">int</span> q;	             <span class="comment">// q不是宏，所以不算已经定义（预处理器定义）</span></span><br><span class="line"><span class="meta">#under GOOD          <span class="comment">// GOOD取消定义，从此开始GOOD是未定义的</span></span></span><br></pre></td></tr></table></figure>



<h4 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h4><p>可以使用其他指令创建条件编译（conditinal compilation）。也就是说， 可以使用这些指令告诉编译器根据编译时的条件执行或忽略信息（或代码） 块。</p>
<h5 id="ifdef、-else、-endif"><a href="#ifdef、-else、-endif" class="headerlink" title="#ifdef、#else、#endif"></a>#ifdef、#else、#endif</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MAVIS</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"horse.h"</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> STABLES 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cow.h"</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> STABLES 15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>#ifdef指令说明，如果预处理器已定义了后面的标识符（MAVIS），则执行#else或#endif指令之前的所有指令并编译所有C代码（先出现哪个指令就执行到哪里）。如果预处理器未定义MAVIS，且有#else指令，则执行 #else和#endif指令之间的所有代码。</p>
<p>#ifdef #else很像的if else。两者的主要区别是，预处理器不识别用于标记块的花括号<code>{}</code>，因此它使用#else（如果需要）和#endif（必须存在） 来标记指令块。这些指令结构可以嵌套。也可以用这些指令标记C语句块，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JUST_CHECKING</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIMIT 4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LIMIT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        total += <span class="number">2</span> * i * i + <span class="number">1</span>;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> JUST_CHECKING</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"i=%d, running total = %d\n"</span>, i, total);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Grand total = %d\n"</span>, total);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果省略JUST_CHECKING定义（把它放在C注释中，或者使用#undef指 令取消它的定义）并重新编译该程序，只会输出最后一行。</p>
<p>可以用这种方法在调试程序。定义JUST_CHECKING并合理使用#ifdef，编译器将执行用于 试的程序代码，打印中间值。调试结束后，可移除JUST_CHECKING定义并重新编译。如果以后还需要使用这些信息，重新插入定义即可。这样做省去了再次输入额外打印语句的麻烦。#ifdef还可用于根据不同的C实现选择合适的代码块。</p>
<h5 id="ifndef"><a href="#ifndef" class="headerlink" title="#ifndef"></a>#ifndef</h5><p>#ifndef指令与#ifdef指令的用法类似，也可以和#else、#endif一起使用， 但是它们的逻辑相反。</p>
<p>通常，包含多个头文件时，其中的文件可能包含了相同宏定义。<strong>#ifndef 指令可以防止相同的宏被重复定义。在首次定义一个宏的头文件中用#ifndef 指令激活定义，随后在其他头文件中的定义都被忽略。</strong></p>
<p>#ifndef指令通常用于防止多次包含一个文件(重复定义宏会报错)。也就是说，应该像下面这样设置头文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> THINGS_H_</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> THINGS_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>#ifndef还可以用来提供方便修改头文件中定义的方式，比如头文件”arrays.h”中定义了<code>#define SIZE 1000</code>。在调试的过程中，如果我们想修改SIZE，可以不用修改头文件，而像下面的代码这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* arrays.h*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SIZE</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> SIZE 1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* source.c */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> SIZE 10</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"arrays.h"</span></span></span><br></pre></td></tr></table></figure>

<p>这样子，include “arrays.h”时预处理#ifndef发现SIZE已经被定义了，就不会重新定义。调试完成后，删去#define SIZE 10即可，避免了修改头文件。</p>
<h5 id="if和-elif"><a href="#if和-elif" class="headerlink" title="#if和#elif"></a>#if和#elif</h5><p>#if指令很像C语言中的if。#if后面跟整型常量表达式，如果表达式为非零，则表达式为真。可以在指令中使用C的关系运算符和逻辑运算符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SYS == 1</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ibm.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> SYS == 2</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vax.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> SYS == 3</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mac.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"general"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>较新的编译器提供另一种方法测试名称是否已定义，即用#if (VAX)代替#ifdef VAX。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined (VAX)</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ibcmp.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<h4 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h4><table>
<thead>
<tr>
<th>宏</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>__DATE__</code></td>
<td>预处理的时期(“Mmm dd yyyy”)形式的字符串字面量，如 Nov 23 2019</td>
</tr>
<tr>
<td><code>__FILE__</code></td>
<td>当前源代码文件名的字符串字面量</td>
</tr>
<tr>
<td><code>__LINE__</code></td>
<td>当前源代码文件中行号的整型常量</td>
</tr>
<tr>
<td><code>__STDC__</code></td>
<td>设置为1时，表面是implementation遵循C标准</td>
</tr>
<tr>
<td><code>__STDC_VERSION__</code></td>
<td>支持C99标准，设置为19901L；支持C11，设置为201112L</td>
</tr>
<tr>
<td><code>__STDC_HOSTED__</code></td>
<td>本机环境设置为1；否则为0</td>
</tr>
<tr>
<td><code>__TIME__</code></td>
<td>翻译代码的时间，格式为“hh:mm:ss”</td>
</tr>
</tbody></table>
<p>C99 标准提供一个名为<code>_ _func_ _</code>的预定义标识符，它展开为一个代表函数名的字符串（该函数包含该标识符）。那么，<code>_ _func_ _</code>必须具有函数作用域，而从本质上看宏具有文件作用域。因此，<code>_ _func_ _</code>是C语言的预定义标识符，而不是预定义宏。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* predef.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">why_me</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This file is %s\n"</span>, __FILE__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The date is %s\n"</span>, __DATE__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The time is %s\n"</span>, __TIME__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The version is %ld\n"</span>, __STDC_VERSION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This line is %d\n"</span>, __LINE__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This function is %s\n"</span>, __func__);</span><br><span class="line">    why_me();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">why_me</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This function is %s\n"</span>, __func__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This line is %d\n"</span>, __LINE__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">This file is predef.c</span></span><br><span class="line"><span class="comment">The date is Jun 13 2020</span></span><br><span class="line"><span class="comment">The time is 14:17:40</span></span><br><span class="line"><span class="comment">The version is 201112</span></span><br><span class="line"><span class="comment">This line is 10</span></span><br><span class="line"><span class="comment">This function is main</span></span><br><span class="line"><span class="comment">This function is why_me</span></span><br><span class="line"><span class="comment">This line is 20</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="line和-error"><a href="#line和-error" class="headerlink" title="#line和#error"></a>#line和#error</h4><p>#line指令重置<code>_ _LINE_ _</code>和<code>_ _FILE_ _</code>宏报告的行号和文件名。可以这样使用#line：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">line</span> 1000            <span class="comment">// 把当前行号设置为1000</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">line</span> 1000 <span class="meta-string">"cool.c"</span>   <span class="comment">// 把当前行号设置为1000，文件名设置为“cool.c"</span></span></span><br></pre></td></tr></table></figure>

<p>#error 指令让预处理器发出一条错误消息，该消息包含指令中的文本。 如果可能的话，编译过程应该中断。可以这样使用#error指令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __STDC_VERSION__ != 201112L</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">error</span> Not C11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>如果编译器只支持旧标准，则会编译失败，如果支持C11标准，就能成功编译。</p>
<h4 id="pragma"><a href="#pragma" class="headerlink" title="#pragma"></a>#pragma</h4><p>在现在的编译器中，可以通过命令行参数或IDE菜单修改编译器的一些 设置。#pragma把编译器指令放入源代码中。例如，在开发C99时，标准被称为C9X，可以使用下面的编译指示（pragma）让编译器支持C9X：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> c9x on</span></span><br></pre></td></tr></table></figure>

<p>C99还提供_Pragma预处理器运算符，该运算符把字符串转换成普通的编译指示。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_Pragma(<span class="string">"nonstandardtreatmenttypeB on"</span>)</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> nonstandardtreatmenttypeB on</span></span><br></pre></td></tr></table></figure>

<p>由于该运算符不使用#符号，所以可以把它作为宏展开的一部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRAGMA(X) <span class="meta-keyword">_Pragma</span>(#X)</span></span><br></pre></td></tr></table></figure>



<h4 id="泛型选择-C11"><a href="#泛型选择-C11" class="headerlink" title="泛型选择(C11)"></a>泛型选择(C11)</h4><p>在程序设计中，泛型编程（generic programming）指那些没有特定类型，但是一旦指定一种类型，就可以转换成指定类型的代码。例如，C++在 模板中可以创建泛型算法，然后编译器根据指定的类型自动使用实例化代码。C没有这种功能。然而，C11新增了一种表达式，叫作泛型选择表达式 （generic selection expression），可根据表达式的类型（即表达式的类型是 int、double 还是其他类型）选择一个值。泛型选择表达式不是预处理器指令，但是在一些泛型编程中它常用作#define宏定义的一部分。</p>
<p>下面是泛型表达式的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_Generic(x, int: 0, float: 1, double: 2, default:3)</span><br></pre></td></tr></table></figure>

<p><code>_Generic</code>是C11的关键字。<code>_Generic</code>后面的圆括号中包含多个用逗号分隔的项。第1个项是一个表达式，后面的每个项都由一个类型、一个冒号和一个值组成，如float: 1。第1个项的类型匹配哪个标签，整个表达式的值是该 标签后面的值。例如，假设上面表达式中x是int类型的变量，x的类型匹配 int:标签，那么整个表达式的值就是0。如果没有与类型匹配的标签，表达式 的值就是default:标签后面的值。</p>
<p>下面是一个把泛型选择语句和宏定义组合的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYTYPE(X) _Generic((X), int: <span class="meta-string">"int"</span>, float: <span class="meta-string">"float"</span>, double: <span class="meta-string">"double"</span>, default: <span class="meta-string">"other"</span>)</span></span><br><span class="line"></span><br><span class="line">MYTYPE(<span class="number">5</span>)    <span class="comment">// “int"</span></span><br></pre></td></tr></table></figure>

<p>对一个泛型选择表达式求值时，程序不会先对第一个项求值，它只确定类型。只有匹配标签的类型后才会对表达式求值。</p>
<h3 id="内联-inline-函数-C99"><a href="#内联-inline-函数-C99" class="headerlink" title="内联(inline)函数(C99)"></a>内联(inline)函数(C99)</h3><p>通常，函数调用都有一定的开销，因为函数的调用过程包括建立调用、 传递参数、跳转到函数代码并返回。使用宏使代码内联，可以避免这样的开销。C99还提供另一种方法：内联函数（inline function）。C99和C11标准中叙述的是：“把函数变成内联函数表明该函数的调用会达到尽可能快的速度，其具体效果由implementation定义”。因此，把函数变成内联函数，编译器可能会用内联代码替换函数调用，并（或）执行一些其他的优化，但是也可能不起作用。</p>
<p>创建内联函数的定义有多种方法。<strong>标准规定具有内部链接的函数可以成为内联函数，还规定了内联函数的定义与调用该函数的代码必须在同一个文 件中。因此，最简单的方法是使用函数说明符 inline 和存储类别说明符 static</strong>。通常，内联函数应定义在首次使用它的文件中，所以内联函数也相当于函数原型。如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">eatline</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  eatline();</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器查看内联函数的定义（也是原型），可能会用函数体中的代码替换 eatline()函数调用。也就是说，效果相当于在函数调用的位置输入函数体中的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">eatline</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>由于并未给内联函数预留单独的代码块，所以无法获得内联函数的地址</strong>。另外，内联函数无法在调试器中显示。内联函数应该比较短小。把较长的函数变成内联并未节约多少时间，因为执行函数体的时间比调用函数的时间长得多。</p>
<p><strong>编译器优化内联函数必须知道该函数定义的内容。这意味着内联函数定义与函数调用必须在同一个文件中</strong>。鉴于此，一般情况下内联函数都具有内部链接。因此，如果程序有多个文件都要使用某个内联函数，那么这些文件 中都必须包含该内联函数的定义。最简单的做法是，把内联函数定义放入头文件，并在使用该内联函数的文件中包含该头文件即可。</p>
<p><strong>与C++不同的是，C还允许混合使用内联函数定义和外部函数定义（具有外部链接的函数定义）</strong>。例如，一个程序中使用下面3个文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file1.c ...</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">double</span> q = square(<span class="number">1.3</span>);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//file2.c ...</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="keyword">return</span> (<span class="keyword">int</span>) (x*x); &#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spam</span><span class="params">(<span class="keyword">double</span> v)</span> </span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">double</span> kv = square(v);</span><br><span class="line">	...                  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//file3.c</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="keyword">return</span> (<span class="keyword">int</span>) (x * x + <span class="number">0.5</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">masp</span><span class="params">(<span class="keyword">double</span> w)</span> </span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">double</span> kw = square(w);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上述代码所示，3个文件中都定义了square()函数。file1.c文件中是 inline static定义；file2.c 文件中是普通的函数定义（因此具有外部链接）； file3.c 文件中是 inline 定义，省略了static。</p>
<ul>
<li><p>file1.c 文件中的main()使用square()的局部static定义。由于该定义也是inline定义， 所以编译器有可能优化代码，也许会内联该函数。</p>
</li>
<li><p>file2.c 文件中，spam()函 数使用该文件中 square()函数的定义，该定义具有外部链接，其他文件也可见</p>
</li>
<li><p>file3.c 文件中，编译器既可以使用该文件中square()函数的内联定义，也可以使用file2.c文件中的外部链接定义。如果像file3.c那样，省略file1.c文件 inline定义中的static，那么该inline定义被视为可替换的外部定义。</p>
</li>
</ul>
<h3 id="Noreturn函数-C11"><a href="#Noreturn函数-C11" class="headerlink" title="_Noreturn函数(C11)"></a>_Noreturn函数(C11)</h3><p>C11新增了函数说明符_Noreturn，表明调用完成后函数不返回主调函数。exit()函数是 _Noreturn 函数的一个示例，一旦调用exit()，它不会再返回主调函数。注意，这与void返回类型不同。void类型的函数在执行完毕后返回主调函数，只是它不提供返回值。</p>
<p>_Noreturn的目的是告诉用户和编译器，这个特殊的函数不会把控制返回 主调程序。告诉用户以免滥用该函数，通知编译器可优化一些代码。</p>
<h2 id="C库"><a href="#C库" class="headerlink" title="C库"></a>C库</h2><p>如何访问C库取决于实现，因此你要了解当前系统的一般情况。首先，可以在多个不同的位置找到库函数。例如，getchar()函数通常作为宏定义在 stdio.h头文件中，而strlen()通常在库文件中。其次，不同的系统搜索这些函数的方法不同。下面介绍3种可能的方法。</p>
<ul>
<li>自动访问：在一些系统中，只需编译程序，就可使用一些常用的库函数。记住，在使用函数之前必须先声明函数的类型，通过包含合适的头文件即可完成。</li>
<li>文件包含：如果函数被定义为宏，那么可以通过#include 指令包含定义宏函数的文 件。通常，类似的宏都放在合适名称的头文件中。</li>
<li>库包含：在编译或链接程序的某些阶段，可能需要指定库选项。即使在自动检查 标准库的系统中，也会有不常用的函数库。必须通过编译时选项显式指定这 些库。注意，这个过程与包含头文件不同。头文件提供函数声明或原型，而 库选项告诉系统到哪里查找函数代码</li>
</ul>
<h3 id="通用工具库-stdlib-h"><a href="#通用工具库-stdlib-h" class="headerlink" title="通用工具库(stdlib.h)"></a>通用工具库(stdlib.h)</h3><p>通用工具库包含各种函数，包括随机数生成器、查找和排序函数、转换函数和内存管理函数。如，rand()、srand()、malloc()和free()函数。 在ANSI C标准中，这些函数的原型都在stdlib.h头文件中。</p>
<h4 id="exit-和atexit"><a href="#exit-和atexit" class="headerlink" title="exit()和atexit()"></a>exit()和atexit()</h4><ul>
<li><p>exit()函数执行会结束程序，<strong>在 main()返回系统时将自动调用exit()函数。</strong>根据ANSI C标准规定，在<strong>最初调用(非递归调用)</strong>的main()中使用return与调用exit()的效果相同。要注意，如果main()在一个递归程序中，exit()仍然会终止程序，但是return只会把控制权交给上一级递归，直至最初的一级。然后return结束程序。return和exit()的另一个区别是，即使在其他函数中（除main()以外）调用exit()也能结束整个程序。</p>
</li>
<li><p>atexit()函数的参数为一个函数指针，使用atexit()函数会将函数指针指向的函数注册到列表中，当exit()被调用时就会执行这个列表中的函数。ANSI保证，在这个列表中至少可以放 32 个函数。最后调用 exit()函数时，exit()会执行这些函数（<strong>执行顺序与列表中的函数顺序相反，即最后添加的函数最先执行</strong>）。atexit()注册的函数应该不带任何参数且返回类型为void。通常，这些函数执行一些清理任务，例如更新监视程序的文件或重置环境变量。</p>
</li>
</ul>
<p>exit()执行完atexit()指定的函数后，会完成一些清理工作：刷新所有输出流、关闭所有打开的流和关闭由标准I/O函数tmpfile()创建的临时文件。然后 exit()把控制权返回主机环境，如果可能的话，向主机环境报告终止状态。 通常，UNIX程序使用0表示成功终止，用非零值表示终止失败。UNIX返回的代码并不适用于所有的系统，所以ANSI C为了可移植性的要求，定义了一个名为EXIT_FAILURE的宏表示终止失败。类似地，ANSI C还定义了 EXIT_SUCCESS表示成功终止。不过，exit()函数也接受0表示成功终止。</p>
<h4 id="qsort-函数"><a href="#qsort-函数" class="headerlink" title="qsort()函数"></a>qsort()函数</h4><p>函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">void</span> *base, <span class="keyword">size_t</span> nmemb, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">int</span> (*compar)(<span class="keyword">const</span> <span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *))</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数1：指向待排序数组的首元素的指针。ANSI C允许把指向任何数据类型的指针强制转换成指向void的指针，因此，qsort()的第1个实际参数可以引用任何类型的数组；</li>
<li>参数2：待排序项的数量，函数原型把该值转换为size_t类型；</li>
<li>参数3：数组中每个元素的大小，常用sizeof获取；</li>
<li>参数4：指向函数的指针，这个被指针指向的比较函数用于确定排序的顺序。该函数应接受两个参数：分别指向待比较两项的指针。如果第1项的值大于第2项，比较函数则返回正数；如果两项相同，则返回0；如果第1项的值小于第2项，则返回负数。qsort()根据给定的其他信息 计算出两个指针的值，然后把它们传递给比较函数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *p1, <span class="keyword">const</span> <span class="keyword">void</span> *p2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[<span class="number">100</span>] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">13</span>,<span class="number">6.</span>.....<span class="number">.100</span>&#125;;</span><br><span class="line">  	qsort(data, <span class="number">100</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), comp);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *p1, <span class="keyword">const</span> <span class="keyword">void</span> *p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *a1 = (<span class="keyword">const</span> <span class="keyword">int</span> *)p1;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *a2 = (<span class="keyword">const</span> <span class="keyword">int</span> *)p2;</span><br><span class="line">    <span class="keyword">if</span> (*a1 &gt; *a2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*a1 == *a2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="断言库"><a href="#断言库" class="headerlink" title="断言库"></a>断言库</h3><p>assert.h 头文件支持的断言库是一个用于辅助调试程序的小型库。它由 assert()宏组成，接受一个整型表达式作为参数。如果表达式求值为假（非零），assert()宏就在标准错误流（stderr）中写入一条错误信息，并调用 abort()函数终止程序（abort()函数的原型在stdlib.h头文件中）</p>
<h4 id="assert"><a href="#assert" class="headerlink" title="assert()"></a>assert()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x, y, z;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Enter a pair of numbers (0 0 to quit)"</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%lf %lf"</span>, &amp;x, &amp;y) == <span class="number">2</span> &amp;&amp; (x!=<span class="number">0</span> || y != <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        z = x * x - y * y;</span><br><span class="line">        assert(z &gt;= <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Anser is %f\n"</span>, <span class="built_in">sqrt</span>(z));</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Next pair of numbers."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Done."</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Enter a pair of numbers (0 0 to quit)</span></span><br><span class="line"><span class="comment">4 3</span></span><br><span class="line"><span class="comment">Anser is 2.645751</span></span><br><span class="line"><span class="comment">Next pair of numbers.</span></span><br><span class="line"><span class="comment">3 4</span></span><br><span class="line"><span class="comment">Assertion failed: (z &gt;= 0), function main, file assert.c, line 12.</span></span><br><span class="line"><span class="comment">[1]    44103 abort  </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>如果认为已经排除了程序的 bug，就可以把下面的宏定义写在包含assert.h的位置前面：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDEBUG</span></span><br></pre></td></tr></table></figure>

<p>并重新编译程序，这样编译器就会禁用文件中的所有 assert()语句。如 果程序又出现问题，可以移除这条#define指令（或者把它注释掉），然后重 新编译程序，这样就重新启用了assert()语句。</p>
<h4 id="Static-assert-C11"><a href="#Static-assert-C11" class="headerlink" title="_Static_assert (C11)"></a>_Static_assert (C11)</h4><p>assert()表达式是在运行时进行检查。C11新增了一个特性：<code>_Static_assert</code>声明，可以在编译时检查assert()表达式。因此，assert()可以导 致正在运行的程序中止，而<code>_Static_assert()</code>可以导致程序无法通过编译。</p>
<ul>
<li>参数1：整型常量表达式，判断条件</li>
<li>参数2：一个字符串，错误信息</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//　statasrt.c </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt; </span></span></span><br><span class="line"></span><br><span class="line">_Static_assert(CHAR_BIT == <span class="number">16</span>, <span class="string">"16-bit char falsely assumed"</span>); </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"char is 16 bits."</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">assert.c:6:1: error: static_assert failed due to requirement '8 == 16' "16-bit char falsely assumed"</span></span><br><span class="line"><span class="comment">_Static_assert(CHAR_BIT == 16, "16-bit char falsely assumed"); </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><code>_Static_assert</code>要求它的第1个参数是<strong>整型常量表达式，这保证了能在编译期求值（sizeof表达式被视为整型常量）</strong>，不可以使用变量，因为表量在程序运行过程中才会求值。</p>
<h3 id="string-h库的memcpy和memmove"><a href="#string-h库的memcpy和memmove" class="headerlink" title="string.h库的memcpy和memmove()"></a>string.h库的memcpy和memmove()</h3><p>不能把一个数组赋给另一个数组，所以要通过循环把数组中的每个元素 赋给另一个数组相应的元素。有一个例外的情况是：使用strcpy()和strncpy() 函数来处理字符数组。memcpy()和memmove()函数提供类似的方法处理任意类型的数组。下面是这两个函数的原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> * <span class="keyword">restrict</span> s1, <span class="keyword">const</span> <span class="keyword">void</span> * <span class="keyword">restrict</span> s2, <span class="keyword">size_t</span> n)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memmove</span><span class="params">(<span class="keyword">void</span> *s1, <span class="keyword">const</span> <span class="keyword">void</span> *s2, <span class="keyword">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这两个函数都从 s2 指向的位置拷贝 n 字节到 s1 指向的位置，而且都返回 s1 的值。所不同的是， memcpy()的参数带关键字restrict，即<strong>memcpy()假设两个内存区域之间没有重叠；而memmove()不作这样的假设，所以拷贝过程类似于先把所有字节拷贝到一个临时缓冲区，然后再拷贝到最终目的地</strong>。 如果使用 memcpy()时，两区域出现重叠会怎样？其行为是未定义的，这意 味着该函数可能正常工作，也可能失败。</p>
<p>由于这两个函数设计用于处理任何数据类型，所有它们的参数都是两个 指向 void 的指针。C 允许把任何类型的指针赋给<code>void *</code>类型的指针。如此宽容导致函数无法知道待拷贝数据的类型。因此，这两个函数使用第 3 个参数指明待拷贝的字节数。注意，对数组而言，字节数一般与元素个数不同。如果要拷贝数组中10个double类型的元素，要使用10*sizeof(double)，而不是10。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 10</span></span><br><span class="line">_Static_assert(<span class="keyword">sizeof</span>(<span class="keyword">double</span>) == <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="string">"double not twice int"</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_array</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> ar[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> values[SIZE] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> target[SIZE];</span><br><span class="line">    <span class="keyword">double</span> curious[SIZE/<span class="number">2</span>] = &#123;<span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>, <span class="number">6.0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"memcpy() used:"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"values (original data): "</span>);</span><br><span class="line">    show_array(values, SIZE);</span><br><span class="line">    <span class="built_in">memcpy</span>(target, values, SIZE * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"target (copy of values):"</span>);</span><br><span class="line">    show_array(target, SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"\nUsing memove() with overlapping ranges:"</span>);</span><br><span class="line">    memmove(values + <span class="number">2</span>, values, <span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"values -- elements 0-5 copied to 2-7:"</span>);</span><br><span class="line">    show_array(values, SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"\nUsing memcpy() to copy double to int:"</span>); </span><br><span class="line">    <span class="built_in">memcpy</span>(target, curious, (SIZE / <span class="number">2</span>) * <span class="keyword">sizeof</span>(<span class="keyword">double</span>)); </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"target -- 5 doubles into 10 int positions:"</span>); </span><br><span class="line">    show_array(target, SIZE / <span class="number">2</span>); </span><br><span class="line">    show_array(target + <span class="number">5</span>, SIZE / <span class="number">2</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_array</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> ar[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, ar[i]);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">memcpy() used:</span></span><br><span class="line"><span class="comment">values (original data): </span></span><br><span class="line"><span class="comment">1 2 3 4 5 6 7 8 9 10 </span></span><br><span class="line"><span class="comment">target (copy of values):</span></span><br><span class="line"><span class="comment">1 2 3 4 5 6 7 8 9 10 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Using memove() with overlapping ranges:</span></span><br><span class="line"><span class="comment">values -- elements 0-5 copied to 2-7:</span></span><br><span class="line"><span class="comment">1 2 1 2 3 4 5 8 9 10 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Using memcpy() to copy double to int:</span></span><br><span class="line"><span class="comment">target -- 5 doubles into 10 int positions:</span></span><br><span class="line"><span class="comment">0 1073741824 0 1074266112 0 </span></span><br><span class="line"><span class="comment">1074790400 0 1075052544 0 1075314688 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>程序中最后一次调用 memcpy()从 double 类型数组中把数据拷贝到 int 类型数组中，这演示了memcpy()函数不知道也不关心数据的类型，它只负责从一个位置把一些字节拷贝到另一个位置（例如，从结构中拷贝数据到字符数组中）。而且，拷贝过程中也不会进行数据转换。如果用循环对数组中的每 个元素赋值，double类型的值会在赋值过程被转换为int类型的值。这种情况下，按原样拷贝字节，然后程序把这些位组合解释成int类型。</p>
<h3 id="可变参数stdarg-h"><a href="#可变参数stdarg-h" class="headerlink" title="可变参数stdarg.h"></a>可变参数stdarg.h</h3><p>stdarg.h 头文件为函数提供了一个使用可变数量参数的功能，但是用法比较复杂。必须按如下步骤进行：</p>
<ol>
<li><p>提供一个使用省略号(…)的函数原型，至少有一个形参和一个省略号，省略号必须在最后</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> n, ...)</span></span>;　　              <span class="comment">// 有效</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> k, ...)</span></span>;   <span class="comment">// 有效</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">f3</span><span class="params">(<span class="keyword">char</span> c1,..., <span class="keyword">char</span> c2)</span></span>;       <span class="comment">// 无效</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f4</span><span class="params">(...)</span></span>;                      <span class="comment">// 无效</span></span><br></pre></td></tr></table></figure>

<p>最右边的形参（即省略号的前一个形参）起着特殊的作用，标准中用<code>parmN</code>这个术语来描述该形参。在上面的例子中，第1行f1()中parmN为n，第 2行f2()中parmN为k。传递给该形参的实际参数是省略号部分代表的参数数量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1(<span class="number">2</span>, <span class="number">200</span>, <span class="number">400</span>);        <span class="comment">// 2个额外参数</span></span><br><span class="line">f1(<span class="number">4</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">14</span>, <span class="number">15</span>);  <span class="comment">// 4个额外参数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在函数定义中创建一个va_list类型的变量；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> lim, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  va_list ap;        <span class="comment">// 声明一个储存参数的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该例中，lim是parmN形参，它表明变参列表中参数的数量。</p>
</li>
<li><p>用宏把该变量初始化为一个参数列表；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">va_start(ap, lim);  <span class="comment">// 把ap初始化为参数列表</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用宏访问参数列表，使用宏va_arg()。该宏接受两个参数：<strong>一个va_list类型的变量和一个类型名</strong>。第1次调用va_arg()时， 它返回参数列表的第1项；第2次调用时返回第2项，以此类推。表示类型的参数指定了返回值的类型。例如，如果参数列表中的第1个参数是double类 型，第2个参数是int类型，可以这样做：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> tic;</span><br><span class="line"><span class="keyword">int</span> toc;</span><br><span class="line">tic = va_arg(ap, <span class="keyword">double</span>);    <span class="comment">// 获得第一个参数</span></span><br><span class="line">toc = va_arg(ap, <span class="keyword">int</span>);       <span class="comment">// 获得第二个参数</span></span><br></pre></td></tr></table></figure>

<p><strong>注意，传入的参数类型必须与宏参数的类型相匹配，否则会出错</strong></p>
<ol>
<li>用宏完成清理工作，使用va_end()宏完成清理工作。调用va_end(ap)后，只有用va_start重新初始化ap后，才能使用变量ap。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">va_end(ap);</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>因为va_arg()不提供退回之前参数的方法，所以有必要保存va_list类型 变量的副本。C99新增了一个宏用于处理这种情况：va_copy()。该宏接受两 个va_list类型的变量作为参数，它把第2个参数拷贝给第1个参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">va_list ap;</span><br><span class="line">va_list apcopy;</span><br><span class="line">va_start(ap, lim);</span><br><span class="line">va_copy(apcopy, ap);</span><br><span class="line"></span><br><span class="line">tic = va_arg(ap, <span class="keyword">double</span>);</span><br><span class="line">toc = va_arg(ap, <span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>

<p>此时，即使删除了ap，也可以从apcopy中检索两个参数。</p>
<p><strong>例子</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> s,t;</span><br><span class="line"></span><br><span class="line">    s = sum(<span class="number">3</span>, <span class="number">1.1</span>, <span class="number">2.5</span>, <span class="number">13.3</span>);</span><br><span class="line">    t = sum(<span class="number">6</span>, <span class="number">1.1</span>, <span class="number">2.1</span>, <span class="number">13.1</span>, <span class="number">4.1</span>, <span class="number">5.1</span>, <span class="number">6.1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"return value of sum(3, 1.1, 2.5, 13.3)                : %g\n"</span>, s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"return value of sum(6, 1.1, 2.1, 13.1, 4.1, 5.1, 6.1) : %g\n"</span>, t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap, n);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        total += va_arg(ap, <span class="keyword">double</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">return value of sum(3, 1.1, 2.5, 13.3)                : 16.9</span></span><br><span class="line"><span class="comment">return value of sum(6, 1.1, 2.1, 13.1, 4.1, 5.1, 6.1) : 31.6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/13/%E4%BD%8D%E8%BF%90%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="崔梓坤">
      <meta itemprop="description" content="我的计算机学习经历和笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="崔梓坤的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/13/%E4%BD%8D%E8%BF%90%E7%AE%97/" class="post-title-link" itemprop="url">位运算</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-13 18:28:41" itemprop="dateCreated datePublished" datetime="2020-06-13T18:28:41+08:00">2020-06-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-16 15:51:07" itemprop="dateModified" datetime="2020-06-16T15:51:07+08:00">2020-06-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><h4 id="十进制转换"><a href="#十进制转换" class="headerlink" title="十进制转换"></a>十进制转换</h4><p><strong>整数部分</strong></p>
<p>10进制数除2取余数至0，以十进制数<code>13</code>为例：<br>$$<br>13\div2=6余1\<br>6\div2=3余0\<br>3\div2=1余1\<br>1\div2=0余1<br>$$<br>所以十进制数<code>13</code>转化为二进制数为<code>1101</code><strong>（注意顺序，整数是从下到上）</strong></p>
<p><strong>小数部分</strong></p>
<p>10进制数不断乘2取整数部分，部分小数无法用二进制精确表示，乘2取整无限不循环。以十进制数<code>6.36</code>为例：</p>
<img src="https://gitee.com/Carlisle345748/cloudimg/raw/master/img/10进制小数转2进制.jpg" alt="10进制小数转2进制" style="zoom:50%;" />

<p>截取十进制的6.36转化为二进制为<strong>（整数部分顺序从下到上，小数部分为从上到下）</strong>。<br>$$<br>110.010111000010100011110…<br>$$</p>
<p>各种进制的转换可以使用<a href="http://www.binaryconvert.com/" target="_blank" rel="noopener">binaryconvert工具站</a></p>
<h4 id="二进制补码-two’s-complement"><a href="#二进制补码-two’s-complement" class="headerlink" title="二进制补码 (two’s complement)"></a>二进制补码 (two’s complement)</h4><p>如何表示有符号整数取决于硬件，而不是C语言。也许表示有符号数最简单的方式是用1位（如，高阶位）储存符号，只剩下7位表示数字本身（假设储存在1字节中）。用这种符号量（sign-magnitude）表示法，<code>1000 0001</code>表 示−1，<code>0000 0001</code>表示1。因此，其表示范围是−127～+127。这种方法的缺点是有两个0：+0和-0。这很容易混淆，而且用两个位组合来表示一个值也有些浪费。二进制补码（two’s-complement）方法避免了这个问题，是当今最常用的系统。</p>
<p>以1字节为例，二进制补码用1字节中的后7位表示0～127，高阶位设置为0。目前，这种方法和符号量的方法相同。另外，如果高阶位是1，表示的值为负。<strong>这两种方法的区别在于如何确定负值</strong>。从一个9位组合<code>1 0000 0000</code>（256的二进制形式）减去一个负数的位组合，结果是该负值的量<code>（1 0000 0000 - 负数的位组合 = 负数的绝对值）</code>。例如，假设一个负值的位组合是 10000000，作为 一个无符号字节，该组合为表示 128，作为一个有符号值，该组合表示负值，值为<code>1 0000 0000 - 1000 0000 = 1000 0000(128)</code>，即该数为-128。</p>
<ul>
<li>正数：以<code>0101 0011</code>为例，高阶位0表示这是一个正数，后7位<code>101 0011</code>的10进制为83，所以该数字为83</li>
<li>负数：以<code>1101 0011</code>为例，高阶位1表示这是一个负数，<code>1 0000 0000 - 1101 0011 = 10 1101</code>，<code>10 1101</code>的10进制为56，所以该数字为-45</li>
</ul>
<p>要得到一个<strong>二进制补码数的相反数</strong>，最简单的方法是反转每一位（即0 变为1，1变为0），然后加1。因为1是<code>0000 0001</code>，那么−1则是<code>1111 1110+1</code>， 或<code>1111 1111</code>。这与上面的介绍一致。</p>
<h4 id="二进制反码-one’s-complement"><a href="#二进制反码-one’s-complement" class="headerlink" title="二进制反码 (one’s complement)"></a>二进制反码 (one’s complement)</h4><p>二进制反码（one’s-complement）方法通过反转位组合中的每一位形成 一个负数。例如，<code>0000 0001</code>是1，那么<code>1111 1110</code>是−1。这种方法也有一个 −0：<code>1111 1111</code>。该方法能表示-127～+127之间的数。</p>
<h4 id="二进制截断"><a href="#二进制截断" class="headerlink" title="二进制截断"></a>二进制截断</h4><p>对于32bit的integer，在类型转换中被截断后，剩余的部分对应的十进制数为<code>原十进制数 % 2^剩余位数</code>。例如，十进制数<code>1107</code>储存为32bit的signed integer，二进制表示为<code>0000 0000 0000 0000 0000 0100 0101 0011</code>，截断为8bit的signed char后，剩余的位为<code>0101 0011</code>,对应的十进制数为<code>83</code>，<code>1107 % 2^8 = 83</code>。</p>
<p>原理：<code>2^n</code>的二进制表示为1…(n个0)，比如<code>2^8</code>的二进制为<code>1 0000 0000</code>，所以任何数除以<code>2^8</code>的余数都是该数字二进制的前8位，因此得到截断至8位的值。</p>
<h3 id="八进制和十六进制"><a href="#八进制和十六进制" class="headerlink" title="八进制和十六进制"></a>八进制和十六进制</h3><p>八进制和十六进制在表达与计算机相关的值时很方便。例如，十进制数65536经常出现在16位机中，用十六进制表示正好是10000。另外，十六进制数的每一位的数恰好由4位二进制数表示。例如，十六进制数3是0011，十六进制数5是0101。因此，十六进制数35的位组合（bit pattern）是00110101，十六进制数53的位组合是01010011。这种对应关系使得十六进制和二进制的转换非常方便。</p>
<p>在C语言中，用特定的前缀表示使用哪种进制。<code>0x</code>或<code>0X</code>前缀表示十六进制值，所以十进制数<code>16</code>表示成十六进制是<code>0x10</code>或<code>0X10</code>。与此类似，<code>0</code>前缀表示八进制。例如，十进制数<code>16</code>表示成八进制是<code>020</code>。但是这种进制转换只是方便人查看和使用，计算机本身对于任何数都是以二进制储存的。</p>
<p><strong>需要注意：</strong>在printf()中<code>%o, %x, %X, %#o, %#x, %#X</code>都是打印无符号的八进制/十六进制整数，负数若使用上述转换说明打印，输出的是对应的补码结果。以十六进制为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">-0X12</span>;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">0X12</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"decimal: %d hexadecimal: %#X\n"</span>, num1, num1); <span class="comment">// negative</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"decimal: %d hexadecimal: %#X\n"</span>, num2, num2); <span class="comment">// positive</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">decimal: -18 hexadecimal: 0XFFFFFFEE</span></span><br><span class="line"><span class="comment">decimal: 18 hexadecimal: 0X12</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>八进制位</th>
<th>等价的二进制位</th>
<th>八进制位</th>
<th>等价的二进制位</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>000</td>
<td>4</td>
<td>100</td>
</tr>
<tr>
<td>1</td>
<td>001</td>
<td>5</td>
<td>101</td>
</tr>
<tr>
<td>2</td>
<td>010</td>
<td>6</td>
<td>110</td>
</tr>
<tr>
<td>3</td>
<td>011</td>
<td>7</td>
<td>111</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>十进制</th>
<th>十六进制</th>
<th>等价二进制</th>
<th>十进制</th>
<th>十六进制</th>
<th>等价二进制</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0000</td>
<td>8</td>
<td>8</td>
<td>1000</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0001</td>
<td>9</td>
<td>9</td>
<td>1001</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>0010</td>
<td>10</td>
<td>a</td>
<td>1010</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>0011</td>
<td>11</td>
<td>b</td>
<td>1011</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>0100</td>
<td>12</td>
<td>c</td>
<td>1100</td>
</tr>
<tr>
<td>5</td>
<td>5</td>
<td>0101</td>
<td>13</td>
<td>d</td>
<td>1101</td>
</tr>
<tr>
<td>6</td>
<td>6</td>
<td>0110</td>
<td>14</td>
<td>e</td>
<td>1110</td>
</tr>
<tr>
<td>7</td>
<td>7</td>
<td>0111</td>
<td>15</td>
<td>f</td>
<td>1111</td>
</tr>
</tbody></table>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><ul>
<li><p><strong>～</strong>：取反</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">～(<span class="number">1001</span> <span class="number">1010</span>);             <span class="comment">// 结果为 0110 0101</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>&amp;</strong>:  与</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1001</span> <span class="number">0011</span>) &amp; (<span class="number">0011</span> <span class="number">1101</span>); <span class="comment">// 结果为 0001 0001</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>|</strong>:  或</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1001</span> <span class="number">0011</span>) | (<span class="number">0011</span> <span class="number">1101</span>); <span class="comment">// 结果为 1011 1111</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>^</strong>: 异或</p>
<p>1 ^ 0 = 1; 0 ^ 0 = 0; 1 ^ 1 = 0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1001</span> <span class="number">0011</span>) | (<span class="number">0011</span> <span class="number">1101</span>); <span class="comment">// 结果为 1010 1110</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>&lt;&lt;</strong>: 左移</p>
<p>移除运算对象左末端位的值，用0填充空出的位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1000</span> <span class="number">1010</span>)  &lt;&lt; <span class="number">2</span>;         <span class="comment">// 结果为 0010 1000 </span></span><br><span class="line">number &lt;&lt; n;　             <span class="comment">// 等于number乘以2的n次幂</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>&gt;&gt;</strong>: 右移</p>
<p>移除运算对象右末端位的值，对于无符号类型，用0填充空出的位置，对于有符号类型，结果取决于机器,空出的位置可用0填充，或者用符号位（即，最左端的位）的副本填充</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1000</span> <span class="number">1010</span>) &gt;&gt; <span class="number">2</span>;          <span class="comment">// 无符号值，结果为 0010 0010</span></span><br><span class="line">(<span class="number">1000</span> <span class="number">1010</span>) &gt;&gt; <span class="number">2</span>;          <span class="comment">// 有符号值，某些系统中结果为 0010 0010</span></span><br><span class="line">(<span class="number">1000</span> <span class="number">1010</span>) &gt;&gt; <span class="number">2</span>;          <span class="comment">// 有符号值，某些系统中结果为 1110 0010</span></span><br><span class="line">number &lt;&lt; n;　             <span class="comment">// 如果number为非负数，等于number除以2的n次幂</span></span><br></pre></td></tr></table></figure>





</li>
</ul>
<h3 id="位运算符用法"><a href="#位运算符用法" class="headerlink" title="位运算符用法"></a>位运算符用法</h3><h4 id="掩码"><a href="#掩码" class="headerlink" title="掩码"></a>掩码</h4><p>由于任何值与1做&amp;运算都是其自身，任何值与0做&amp;运算都是0，所以可以隐藏指定的位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flags = flags &amp; MASK;     <span class="comment">// MASK中0是隐藏，1是显示</span></span><br></pre></td></tr></table></figure>



<h4 id="打开位"><a href="#打开位" class="headerlink" title="打开位"></a>打开位</h4><p>由于任何值与1做｜运算都是1，任何值与0做｜运算都是其自身，可以用｜运算在不影响其他位的情况下关闭指定的位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flags = flags ｜ MASK;     <span class="comment">// MASK中0是不变，1是打开</span></span><br></pre></td></tr></table></figure>



<h4 id="关闭位"><a href="#关闭位" class="headerlink" title="关闭位"></a>关闭位</h4><p>由于任何值与1做&amp;运算都是其自身，任何值与0做&amp;运算都是0，在不影响其他位的情况下关闭指定的位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flags = flags &amp; ~MASK      <span class="comment">// MASK中0是不变，1是关闭</span></span><br></pre></td></tr></table></figure>



<h4 id="切换位"><a href="#切换位" class="headerlink" title="切换位"></a>切换位</h4><p>切换位指的是打开已关闭的位，或关闭已打开的位。由于1^=0, 0 ^ 1=1,0可以使用按位异或运算符^切换位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flags = flags ^ MASK        <span class="comment">// MASK中0是不变，1是切换</span></span><br></pre></td></tr></table></figure>



<h4 id="检查位的值"><a href="#检查位的值" class="headerlink" title="检查位的值"></a>检查位的值</h4><p>要检查某个位的值，例如，flags中 1号位是否被设置为1？不能这样直接比较flags和MASK。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flags == MASK)</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Wow"</span>)  <span class="comment">// 不能正常工作</span></span><br></pre></td></tr></table></figure>

<p>这样做即使flags的1号位为1，其他位的值会导致比较结果为假。因此，<strong>必须覆盖flags中的其他位，只用1号位和MASK比较：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((flags &amp; MASK) == MASK) <span class="comment">// MASK中，1是待检查的位，0是不需检查的0</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Wow"</span>)  <span class="comment">// 正常工作</span></span><br></pre></td></tr></table></figure>



<h3 id="位字段-Bit-Fields"><a href="#位字段-Bit-Fields" class="headerlink" title="位字段(Bit-Fields)"></a>位字段(Bit-Fields)</h3><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>位字段在C中通过结构声明，可以在结构中操控一个值中的单独位或多个位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> autfd : <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> bldfc : <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> undln : <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> itals : <span class="number">1</span>;</span><br><span class="line">&#125; prnt;</span><br></pre></td></tr></table></figure>

<p>根据该声明，prnt包含4个1位的字段。现在，可以通过普通的结构成员运算符（.）单独给这些字段赋值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prnt.itals = <span class="number">0</span>;</span><br><span class="line">prnt.undln = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>由于每个字段恰好为1位，所以只能为其赋值1或0。<strong>变量prnt被储存在 unsigned int大小的内存单元中，但是在本例中只使用了其中的4位。</strong> </p>
<p><strong>多位字段</strong></p>
<p>有时，某些设置也有多个选择，因此需要多位来表示，<strong>但是要确保所赋的值不超出字段可容纳的范围</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> codel : <span class="number">2</span>;     <span class="comment">// 2位字段</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> code2 : <span class="number">2</span>;     <span class="comment">// 2位字段</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> code3 : <span class="number">8</span>;     <span class="comment">// 8位字段</span></span><br><span class="line">&#125; prcode;</span><br></pre></td></tr></table></figure>

<p>如果声明的总位数超过了一个unsigned int类型的大小，会用到下一个unsigned int类型的存储位置。一个字段不允许跨越两个unsigned int之间的边界。编译器会自动移动跨界的字段，保持unsigned int的边界对齐。一旦发生这种情况，第1个unsigned int中会留下一个未命名的“洞”。</p>
<p>可以用未命名的字段宽度“填充”未命名的“洞”。使用一个宽度为0的未命名字段迫使下一个字段与下一个整数对齐：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> field1 : <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>        : <span class="number">2</span>;    <span class="comment">// 添加一个2位的空隙</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> field2 : <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>        : <span class="number">0</span>;    <span class="comment">// 添加宽度为0的未命名字段，迫使field3储存在下一个unsigned int 中</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> field3 : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，在stuff.field1和stuff.field2之间，有一个2位的空隙；stuff.field3将储存在下一个unsigned int中。</p>
<p><strong>不同机器上的位字段储存方式</strong></p>
<p>字段储存在一个int中的顺序取决于机器。在有些机器上，存储的顺序是从左往右，而在另一些机器上，是从右往左。另外，不同的机器中两个字段边界的位置也有区别。由于这些原因，位字段通常都不容易移植。尽管如此，有些情况却要用到这种不可移植的特性。例如，以特定硬件设备所用的形式储存数据。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><table>
<thead>
<tr>
<th>Bit Pattern</th>
<th>Decimal</th>
<th>Color</th>
</tr>
</thead>
<tbody><tr>
<td>000</td>
<td>0</td>
<td>Black</td>
</tr>
<tr>
<td>001</td>
<td>1</td>
<td>Red</td>
</tr>
<tr>
<td>010</td>
<td>2</td>
<td>Green</td>
</tr>
<tr>
<td>011</td>
<td>3</td>
<td>Yellow</td>
</tr>
<tr>
<td>100</td>
<td>4</td>
<td>Blue</td>
</tr>
<tr>
<td>101</td>
<td>5</td>
<td>Magenta</td>
</tr>
<tr>
<td>110</td>
<td>6</td>
<td>Cyan</td>
</tr>
<tr>
<td>111</td>
<td>7</td>
<td>White</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="comment">/* line style */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOLID 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DOTTED 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DASHED 2</span></span><br><span class="line">/ * primary colors */</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLUE 4   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GREEN 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RED 1</span></span><br><span class="line">/ * mixed colors */</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLACK 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YELLOW (RED | GREEN)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEGENTA (RED | BLUE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CYAN (GREEN | BLUE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WHITE (RED | GREEN | BLUE)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *colors[<span class="number">8</span>] = &#123;<span class="string">"black"</span>, <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"yellow"</span>, <span class="string">"blue"</span>,</span><br><span class="line">                         <span class="string">"megenta"</span>, <span class="string">"cyan"</span>, <span class="string">"white"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">box_probs</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> opaque               : <span class="number">1</span>;  <span class="comment">// or unsigned int (pre C99)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> fill_color   : <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>              : <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">bool</span> show_border          : <span class="number">1</span>;  <span class="comment">// or unsigned int (pre C99)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> border_color : <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> border_style : <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>              : <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_settings</span><span class="params">(<span class="keyword">const</span> struct box_probs * pb)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	/ * create <span class="keyword">and</span> initialize box_props structure */</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">box_probs</span> <span class="title">box</span> = &#123;</span><span class="literal">true</span>, YELLOW, <span class="literal">true</span>, GREEN, DASHED&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Original box settings:"</span>);</span><br><span class="line">    show_settings(&amp;box);</span><br><span class="line"></span><br><span class="line">    box.opaque = <span class="literal">false</span>;</span><br><span class="line">    box.fill_color = WHITE;</span><br><span class="line">    box.border_color = MEGENTA;</span><br><span class="line">    box.border_style = SOLID;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nModified box seetings:\n"</span>);</span><br><span class="line">    show_settings(&amp;box);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_settings</span><span class="params">(<span class="keyword">const</span> struct box_probs * pb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Box is %s\n"</span>, pb-&gt;opaque == <span class="literal">true</span> ? <span class="string">"opaque"</span> : <span class="string">"transparent"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The filling color is %s\n"</span>, colors[pb-&gt;fill_color]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Border %s\n"</span>, pb-&gt;show_border == <span class="literal">true</span> ? <span class="string">"shown"</span> : <span class="string">"not shown"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The border color is %s"</span>, colors[pb-&gt;border_color]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The border style is "</span>);</span><br><span class="line">    <span class="keyword">switch</span> (pb-&gt;border_style)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> SOLID: <span class="built_in">printf</span>(<span class="string">"solid.\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DOTTED: <span class="built_in">printf</span>(<span class="string">"dotted.\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DASHED: <span class="built_in">printf</span>(<span class="string">"dashed.\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="built_in">printf</span>(<span class="string">"unkown type.\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="对齐特性-C11"><a href="#对齐特性-C11" class="headerlink" title="对齐特性(C11)"></a>对齐特性(C11)</h3><p>C11 的对齐特性比用位填充字节更自然，它们还代表了C在处理硬件相关问题上的能力。在这种上下文中，对齐指的是如何安排对象在内存中的位置。例如，<strong>为了效率最大化，系统可能要把一个 double 类型的值储存在4 字节内存地址上，但却允许把char储存在任意地址</strong>。大部分程序员都对对齐不以为然。但是，有些情况又受益于对齐控制。例如，把数据从一个硬件位置转移到另一个位置，或者调用指令同时操作多个数据项。</p>
<h4 id="Alignof-运算符"><a href="#Alignof-运算符" class="headerlink" title="_Alignof 运算符"></a>_Alignof 运算符</h4><p> <code>_Alignof</code>运算符给出一个类型的对齐要求，在关键字<code>_Alignof</code>后面的圆括号中写上类型名即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> d_align = _Alignoif(<span class="keyword">float</span>);</span><br></pre></td></tr></table></figure>

<p>假设d_align的值是4，意思是float类型对象的对齐要求是4。也就是说， 4是储存该类型值相邻地址的字节数差。一般而言，对齐值都应该是2的非负整数次幂。较大的对齐值被称为stricter或stronger，较小的对齐值被称为 weaker。</p>
<h4 id="Alignas说明符"><a href="#Alignas说明符" class="headerlink" title="_Alignas说明符"></a>_Alignas说明符</h4><p>可以使用<code>_Alignas</code>说明符指定一个变量或类型的对齐值。但是，不应该要求该值小于基本对齐值。例如，如果float类型的对齐要求是4，不要请求其对齐值是1或2。该说明符用作声明的一部分，说明符后面的圆括号内包含对齐值或类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_Alignas(<span class="keyword">double</span>) <span class="keyword">char</span> c1;</span><br><span class="line">_Alignas(<span class="number">8</span>) <span class="keyword">char</span> c2;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> _Alignas(<span class="keyword">long</span> <span class="keyword">double</span>) c_arr[<span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">double</span>)];</span><br></pre></td></tr></table></figure>

<p>在新版的Clang和GCC中，无论_Alignas(type)说明符在类型说明符的前面还是后面都可以</p>
<h4 id="stdalign-h"><a href="#stdalign-h" class="headerlink" title="stdalign.h"></a>stdalign.h</h4><p>在程序中包含 stdalign.h 头文件后，就可以把 alignas 和 alignof 分别作为 <code>_Alignas</code>和<code>_Alignof</code>的别名。这样做可以与C++关键字匹配。</p>
<h4 id="aligned-alloc"><a href="#aligned-alloc" class="headerlink" title="aligned_alloc"></a>aligned_alloc</h4><p>C11在stdlib.h库还添加了一个新的内存分配函数，用于对齐动态分配的 内存。该函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">aligned_alloc</span><span class="params">(<span class="keyword">size_t</span> alignment, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>第1个参数代表指定的对齐，第2个参数是所需的字节数，其值应是第1个参数的倍数。与其他内存分配函数一样，要使用free()函数释放之前分配的内存。</p>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> dx;</span><br><span class="line">    <span class="keyword">char</span> ca;</span><br><span class="line">    <span class="keyword">char</span> cx;</span><br><span class="line">    <span class="keyword">double</span> dz;</span><br><span class="line">    <span class="keyword">char</span> cb;</span><br><span class="line">    <span class="keyword">char</span> _Alignas(<span class="keyword">double</span>) cz;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"char alignment: %zd\n"</span>, _Alignof(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"double alignment: %zd\n"</span>, _Alignof(<span class="keyword">double</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;dx: %p\n"</span>, &amp;dx);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;ca: %p\n"</span>, &amp;ca);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;cx: %p\n"</span>, &amp;cx);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;dz: %p\n"</span>, &amp;dz);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;cb: %p\n"</span>, &amp;cb);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;cz: %p\n"</span>, &amp;cz);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">char alignment: 1</span></span><br><span class="line"><span class="comment">double alignment: 8</span></span><br><span class="line"><span class="comment">&amp;dx: 0x7ffeea9de610</span></span><br><span class="line"><span class="comment">&amp;ca: 0x7ffeea9de60f</span></span><br><span class="line"><span class="comment">&amp;cx: 0x7ffeea9de60e</span></span><br><span class="line"><span class="comment">&amp;dz: 0x7ffeea9de600</span></span><br><span class="line"><span class="comment">&amp;cb: 0x7ffeea9de5ff</span></span><br><span class="line"><span class="comment">&amp;cz: 0x7ffeea9de5f8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在我们的系统中，double的对齐值是8，这意味着地址的类型对齐可以 被8整除。以0或8结尾的十六进制地址可被8整除。这就是地址常用两个 double类型的变量和char类型的变量cz（该变量是double对齐值）。因为char 的对齐值是1，对于普通的char类型变量，编译器可以使用任何地址。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/13/%E5%82%A8%E5%AD%98%E7%B1%BB%E5%9E%8B%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="崔梓坤">
      <meta itemprop="description" content="我的计算机学习经历和笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="崔梓坤的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/13/%E5%82%A8%E5%AD%98%E7%B1%BB%E5%9E%8B%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">储存类型、链接和内存管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-13 18:28:00 / 修改时间：18:28:25" itemprop="dateCreated datePublished" datetime="2020-06-13T18:28:00+08:00">2020-06-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="存储类型"><a href="#存储类型" class="headerlink" title="存储类型"></a>存储类型</h2><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>程序需要一种方法访问储存在内存中的数据对象(object)，这可以通过声明变量来完成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> entity = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>该声明创建了一个名为<code>entity</code>的<strong>标识符（identifier）</strong>。标识符是一个名称，可以用来指定（designate）特定对象的内容。该声明还提供了储存在对象中的值(3)。</p>
<p>变量名不是指定对象的唯一途径。考虑下面的声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * pt = &amp;entity;</span><br><span class="line"><span class="keyword">int</span> ranks[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p><code>pt</code>是一个标识符，它指定了一个储存地址的对象。但是，表达式<code>*pt</code>不是标识符，因为它不是一个名称。然而，它确实指定了一 个对象，在这种情况下，它与 entity 指定的对象相同。一般而言，那些指定对象的表达式被称为左值(lvalue)，所以，<code>entity</code>既是标识符也是左值；<code>*pt</code>既是表达式也是左值。</p>
<h3 id="作用域、链接、储存期"><a href="#作用域、链接、储存期" class="headerlink" title="作用域、链接、储存期"></a>作用域、链接、储存期</h3><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p><strong>作用域描述程序中可访问标识符的区域</strong>。一个C变量的作用域可以是块作用域(花括号括起来的代码区域})、函数作用域、函数原型作用域或文件作用域(file scope)。</p>
<ul>
<li><p>块作用域</p>
<p>花括号{}括起来的代码区域属于一个块，比如复合语句(compound statement)。C99把块的概念扩展到包括for循环、while循环、 do while循环和if语句所控制的代码，即使这些代码没有用花括号括起来， 也算是块的一部分。<strong>注意：对于for、while、if等块，其判断语句是一个块，而其循环体是其子块。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)  <span class="comment">// 判断语句本身是一个块</span></span><br><span class="line">&#123;</span><br><span class="line">  	<span class="comment">// 循环体是判断语句这个块的子块</span></span><br><span class="line">  	count += <span class="number">1</span>;</span><br><span class="line">  	totoal += arr[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"This is also a block"</span>);   <span class="comment">// C99中在while、for、do while中即使没有花括号也算作块</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数原型作用域</p>
<p>函数原型作用域的范围是从<strong>形参定义处到原型声明结束</strong>。这意味着，<strong>编译器在处理函数原型中的形参时只关心它的类型，而形参名（如果有的话） 通常无关紧要</strong>。而且，即使有形参名，也不必与函数定义中的形参名相匹 配。<strong>只有在变长数组(VLA)中，形参名才有用</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mighty</span><span class="params">(<span class="keyword">int</span> mouse, <span class="keyword">double</span> large)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use_a_VLA</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, ar[n][m])</span></span>;  <span class="comment">// VLA</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>文件作用域(file scope)</p>
<p>变量的定义在函数的外面，具有文件作用域（file scope），所谓的“文件”是指一个源代码(.c)文件。具有文件作用域的变量，从它的定义处到该定义所在文件的末尾均可见。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="keyword">int</span> unit = <span class="number">0</span>;   <span class="comment">// unit具有文件作用域, main和func都可以使用它</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">voud <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<blockquote>
<p><strong>翻译单元(translation unit)和文件</strong></p>
<p>多个文件在编译器中可能以一个文件出现。例如，通常在源代码（.c扩展名）中包含一个或多个头文件（.h 扩展名）。头文件会依次包含其他头文件，所以会包含多个单独的物理文件。但是，C预处理实际上是用包含的头文件内容替换#include指令。所以，编译器源代码文件和所有的头文件都看成是一个包含信息的单独文件。这个文件被称为翻译单元 （translation unit）。描述一个具有文件作用域的变量时，它的实际可见范围 是整个翻译单元。如果程序由多个源代码文件组成，那么该程序也将由多个翻译单元组成。每个翻译单元均对应一个源代码文件和它所包含的文件。</p>
</blockquote>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>C 变量有 3 种链接属性：外部链接、内部链接或无链接。</p>
<ul>
<li>外部链接：包含“外部链接”和“文件作用域”的变量可以在其他源代码文件中使用。</li>
<li>内部链接：包含“内部链接”和“文件作用域”的变量可以在当前源代码文件中使用。</li>
<li>无链接：无链接的变量只能在作用域内的局部使用的，在各种函数和块中定义的变量为无链接变量。</li>
</ul>
<h4 id="储存期"><a href="#储存期" class="headerlink" title="储存期"></a>储存期</h4><p>作用域和链接描述了标识符的可见性。存储期描述了通过这些标识符访问的对象的生存期(duration)。C对象有4种存储期：<strong>静态存储期(static)、线程存储期(thread)、自动存储期(automatic)、动态分配(allocated)存储期</strong>。</p>
<ul>
<li><p>静态存储期</p>
<p>如果对象具有静态存储期，那么它在程序的执行期间一直存在。文件作用域变量具有静态存储期。</p>
</li>
<li><p>线程存储期</p>
<p>线程存储期用于并发程序设计，程序执行可被分为多个线程。具有线程存储期的对象，从被声明时到线程结束一直存在。以关键字<code>_Thread_local</code>声明一个对象时，每个线程都获得该变量的私有备份。</p>
</li>
<li><p>自动存储期</p>
<p>在块中不带存储类别说明符或带 auto 存储类别说明符声明的变量（或作为函数头中的形参）属于自动存储类别。所有函数、块内的局部变量都是自动存储期，在函数运行时创建，函数结束后自动销毁。</p>
</li>
<li><p>动态分配存储期</p>
<p>使用malloc()或calloc()函数分配空间的对象，在创建之后，直到使用free()函数后才会被销毁。</p>
</li>
</ul>
<p>​    </p>
<h3 id="储存类别"><a href="#储存类别" class="headerlink" title="储存类别"></a>储存类别</h3><p>C语言中有5种存储列别，分别有不同的作用域、存储期、链接和声明方式。</p>
<p><img src="https://gitee.com/Carlisle345748/cloudimg/raw/master/img/5%E7%A7%8D%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB.png" alt=""></p>
<h4 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h4><p>默认情况下，声明在块或函数头中的任何变量都属于自动变量，具有自动存储期、块作用域且无链接的特征。**</p>
<ul>
<li><strong>块作用域和无链接意味着只有在变量定义所在的块中才能通过标识符访问该变量</strong>。另一个函数可以使用同名变量，但是该变量是储存在不同内存位置上的另一个变量。</li>
<li><strong>自动存储期意味着，程序在进入该变量声明所在的块时变量存在，程序在退出该块时变量消失</strong>，原来该变量占用的内存位置现在可做他用。</li>
</ul>
<p>为了更清楚地表达你的意图（例如，为了表明有意覆盖一个外部变量定义，或者强调不要把该变量改为其他存储类别），可以显式使用关键字<code>auto</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> <span class="keyword">int</span> var1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>C和C++中的auto</strong></p>
<p>关键字auto是存储类别说明符（storage-class specifier）。auto关键字在 C++中的用法完全不同，如果编写C/C++兼容的程序，最好不要使用auto作为存储类别说明符。</p>
</blockquote>
<ol>
<li>如果内层块中声明的变量与外层块中的变量同名，内层块会隐藏外层块的定义。但是离开内层块后，外层块变量的作用域又回到了原来的作用域，下面的代码演示了上述过程。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;  <span class="comment">// 第一个i在main函数内</span></span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">"i = %d address %p \n"</span>, i, &amp;i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i  = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)  <span class="comment">// 第二个i在for(....)这个块里</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i = %d  address = %p\n"</span>, i, &amp;i);  <span class="comment">// 这里还是for()里面的第二个i</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">30</span>; <span class="comment">// 第三个i在for的循环体子块内</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i = %d  address = %p\n"</span>, i, &amp;i);  <span class="comment">// 第三个i</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i = %d address %p \n"</span>, i, &amp;i);  <span class="comment">// 第一个i</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">i = 10 address 0x7ffee190c618 </span></span><br><span class="line"><span class="comment">i = 0  address = 0x7ffee1463614</span></span><br><span class="line"><span class="comment">i = 30  address = 0x7ffee1463610</span></span><br><span class="line"><span class="comment">i = 1  address = 0x7ffee1463614</span></span><br><span class="line"><span class="comment">i = 30  address = 0x7ffee1463610</span></span><br><span class="line"><span class="comment">i = 2  address = 0x7ffee1463614</span></span><br><span class="line"><span class="comment">i = 30  address = 0x7ffee1463610</span></span><br><span class="line"><span class="comment">i = 10 address 0x7ffee1463618 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>首先，在<code>main</code>函数中创建并初始化了第一个<code>i=10</code>。然后在for (int i = 0; i &lt; 3; i++)中创建了第二个<code>i=0</code>，并且在for的循环体中创建了第三个<code>i=30</code>。<strong>注意，for、while、if等语句，for、while和括号内的判断条件是一个块，而循环体是其子块。</strong>所以，第三个变量只定义在for循环体子块中，printf()中<code>i=30</code>，每轮迭代结束，新的第三个<code>i</code>变量就消失。然后循环的测试条件使用并递增第二个的<code>i</code>。所以，在循环过程中，第三个<code>i</code>被重复创建和销毁了3次。</p>
<ol start="2">
<li>自动变量的不会自动初始化，除非显式初始化它。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> repid;      <span class="comment">// 未初始化，repid是原有的垃圾值</span></span><br><span class="line"><span class="keyword">int</span> tents = <span class="number">5</span>;  <span class="comment">// 显式初始化，tents的值为5</span></span><br></pre></td></tr></table></figure>



<h4 id="寄存器变量"><a href="#寄存器变量" class="headerlink" title="寄存器变量"></a>寄存器变量</h4><p>在块中带 register 存储类别说明符声明的变量（或作为函数头中的形参）属于寄存器存储类别，具有自动存储期、块作用域、无链接， <strong>且无法获取其地址</strong>。把一个变量声明为寄存器变量即请求编译器将其储存到访问速度最快的区域。如果未初始化寄存器变量，它的值是未定义的。</p>
<p>声明寄存器变量更像一种“请求”，而不是一定成功的。编译器必须根据寄存器或最快可用内存的数量衡量你的请求，或者直接忽略你的请求，所以可能不会如你所愿。在这种情况下， 寄存器变量就变成普通的自动变量。即使是这样，仍然不能对该变量使用地址运算符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">macho</span><span class="params">(<span class="keyword">register</span> <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">register</span> <span class="keyword">int</span> quick;       <span class="comment">// 声明寄存器变量</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">macho</span><span class="params">(<span class="keyword">register</span> <span class="keyword">int</span> n)</span>  <span class="comment">// 在函数头中使用关键字register，便可请求形参是寄存器变量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="块作用域的静态变量"><a href="#块作用域的静态变量" class="headerlink" title="块作用域的静态变量"></a>块作用域的静态变量</h4><p>块作用域中定义的静态变量和自动变量一样，具有相同的作用域，但是程序离开它们所在的函数后，这些变量不会消失。也就是说，这种变量具有块作用域、无链接，但是具有静态存储期。计算机在多次函数调用之间会记录它们的值。在块中（提供块作用域和无链接）以存储类别说明符static声明这种变量。如果未显式初始化静态变量，它们会被初始化为0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_tryrstat</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Here comes interation %d: "</span>, i);</span><br><span class="line">        my_tryrstat();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_tryrstat</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fade = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> stay = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fade = %d and stay = %d\n"</span>, fade++, stay++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Here comes interation 1: fade = 1 and stay = 1</span></span><br><span class="line"><span class="comment">Here comes interation 2: fade = 1 and stay = 2</span></span><br><span class="line"><span class="comment">Here comes interation 3: fade = 1 and stay = 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>静态变量stay保存了它被递增1后的值，但是fade变量每次都是1。这表明了初始化的不同：每次调用trystat()都会初始化fade，但是stay只在编译 my_tryrstat()时被初始化一次，静态变量在程序被载入内存时已执行完毕，这条声明并未在运行时执行。</p>
<p><strong>注意: 不能在函数头的形参中使用static：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wontwork</span><span class="params">(<span class="keyword">static</span> <span class="keyword">int</span> flu)</span></span>; <span class="comment">// 不允许</span></span><br></pre></td></tr></table></figure>

<p><strong>声明具有静态变量时，必须使用常量表达式，不可使用变量</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> m = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> x = m;  <span class="comment">// 不允许，x是变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="外部链接的静态变量"><a href="#外部链接的静态变量" class="headerlink" title="外部链接的静态变量"></a>外部链接的静态变量</h4><p><strong>把变量的定义性声明（defining declaration）放在在所有函数的外面便创建了外部变量。</strong>外部链接的静态变量具有文件作用域、外部链接和静态存储期。该类别有时称为外部存储类别（external storage class），属于该类别的变量称为外部变量（external variable）。外部链接的静态变量拥有文件作用域，对所有函数都可见。</p>
<ul>
<li><p><strong>函数内引用式声明</strong>：在同一个源代码文件中定义了外部链接的静态变量，也可以在函数内使用<code>extern</code>关键字再次“声明”该变量，但是这个声明可以完全忽略。这一个做法其实更多起到说明作用，表明这个函数引用了外部变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> outer_var = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> inner = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">int</span> outer_var;  <span class="comment">// 可忽略该声明，该声明更多起到说明作用</span></span><br><span class="line">  inner += outer_var;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><strong>从其他源代码文件中引用</strong>：如果一个源代码文件使用的外部变量定义在另一个源代码文件中，则必须用extern在该文件中声明该变量。如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> outer_var;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> other_file;   <span class="comment">// other_file定义在其他源代码文文件中，使用前必须使用extern声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>初始化外部变量</strong>：外部变量和自动变量类似，也可以被显式初始化。与自动变量不同的是，如果未初始化外部变量，它们会被自动初始化为 0。这一原则也适用于外部定义的数组元素。同时，外部变量只能初始化一次，且必须在定义该变量时进行。假设有下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1 one.c</span></span><br><span class="line"><span class="keyword">char</span> permis = <span class="string">'N'</span>;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// file2 tow.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> permis = <span class="string">'Y'</span>   <span class="comment">// 错误，file1已经声明并初始化了permis</span></span><br></pre></td></tr></table></figure>

<p><strong>同时，声明静态变量时，必须使用常量表达式，不可用变量。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">2</span>;                <span class="comment">// 允许</span></span><br><span class="line"><span class="keyword">int</span> y = <span class="number">3</span> +<span class="number">20</span>;            <span class="comment">// 允许</span></span><br><span class="line"><span class="keyword">size_t</span> z = <span class="keyword">sizeof</span>(<span class="keyword">int</span>);   <span class="comment">// 允许，sizeof(int)视为常量</span></span><br><span class="line"><span class="keyword">int</span> x2 = <span class="number">2</span> * x;           <span class="comment">// 不允许，x是变量</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><strong>函数内部声明重名变量</strong>：如果在函数内声明一个与外部变量重名的变量，则外部变量会被隐藏，在函数内部使用新声明的变量。</li>
</ul>
<h4 id="内部链接的静态变量"><a href="#内部链接的静态变量" class="headerlink" title="内部链接的静态变量"></a>内部链接的静态变量</h4><p>该存储类别的变量具有静态存储期、文件作用域和内部链接。在所有函数外部，用存储类别说明符static定义的变量具有这种存储类别。与外部链接的静态变量不同，内部链接的静态变量只能在当前源代码文件(翻译单元)中使用，不能在其他源代码文件中使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>[<span class="number">6</span>] = <span class="string">"Hello"</span>;</span><br></pre></td></tr></table></figure>

<p><strong>同时，声明静态变量时，必须使用常量表达式，不可用变量。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">2</span>;                <span class="comment">// 允许</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> y = <span class="number">3</span> +<span class="number">20</span>;            <span class="comment">// 允许</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> z = <span class="keyword">sizeof</span>(<span class="keyword">int</span>);   <span class="comment">// 允许，sizeof(int)视为常量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x2 = <span class="number">2</span> * x;           <span class="comment">// 不允许，x是变量</span></span><br></pre></td></tr></table></figure>



<h4 id="储存类型与函数"><a href="#储存类型与函数" class="headerlink" title="储存类型与函数"></a>储存类型与函数</h4><p>函数也有存储类别，可以是外部函数（默认）或静态函数。外部函数可以被其他源代码文件的函数访问，但是静态函数只能用于其定义所在的源代码文件内。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">gamma</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">beta</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在同一个程序中，其他文件中的函数可以调用gamma()，但是不能调用beta()，因为以static存储类别说明符创建的函数属于特定模块私有。这样做避免了名称冲突的问题，由于beta()受限于它所在的文件，所以在其他文件中可以使用与之同名的函数。</p>
<h2 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h2><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc()"></a>malloc()</h3><p>该函数接受一个参数：所需的内存字节数。malloc()函数会找到合适的空闲内存块，这样的内存是匿名的。也就是说， malloc()分配内存，但是不会为其赋名。然而，它确实返回动态分配内存块的首字节地址。 因此，可以把该地址赋给一个指针变量，并使用指针访问这块内存。molloc()的返回值是一个void指针，这个类型相当于一个“通用指针”，通常将该函数的返回值强制转换为匹配的类型。如果malloc()分配内存失败，则返回空指针。</p>
<ul>
<li>参数：所需的内存字节数</li>
<li>返回值：指向所分配内存块的void指针，可通过强制类型转换匹配适当的数据类型。如果分配失败，则返回空指针。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 使用malloc()创建一个含有30个double类型值的数组*/</span></span><br><span class="line"><span class="keyword">double</span> * ptd;</span><br><span class="line">ptd = (<span class="keyword">double</span> *)<span class="built_in">malloc</span>(<span class="number">30</span> * <span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">ptd[<span class="number">0</span>]；</span><br><span class="line">ptd[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>



<h3 id="free"><a href="#free" class="headerlink" title="free()"></a>free()</h3><p>通常,malloc()要与free()配套使用。free()函数的参数是之前malloc()返回的地址，该函数释放之前malloc()分配的内存。因此，<strong>动态分配内存的存储期从调用malloc()分配内存到调用free()释放内存为止</strong>。设想malloc()和 free()管理着一个内存池。每次调用malloc()分配内存给程序使用，每次调用 free()把内存归还内存池中，这样便可重复使用这些内存。如果不使用free()释放内存，可能在程序结束前耗尽内存。注意：不能用 free()释放通过其他方式（如，声明一个数组）分配的内存。</p>
<ul>
<li>参数：malloc()分配的内存块地址。不能是其他方式声明的数据的地址。</li>
</ul>
<h3 id="calloc"><a href="#calloc" class="headerlink" title="calloc()"></a>calloc()</h3><p>分配内存还可以使用calloc()，calloc()函数接受两个无符号整数作为参数（ANSI规定是size_t类型）。第1个参数是所需的存储单元数量，第2个参数是存储单元的大小（以字节为单位）。<strong>calloc()函数还有一个特性：它把块中的所有位都设置为0（注意，在某些硬件系统中，不是把所有位都设置为0来表示浮点值0）。</strong></p>
<ul>
<li>参数1: 所需存储单元数量(size_t)</li>
<li>参数2: 所需存储单元的大小(size_t)，以字节为单位</li>
<li>返回值：指向所分配内存块的void指针，可通过强制类型转换匹配适当的数据类型</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*使用calloc()创建一个包含100个long类型值的数组*/</span></span><br><span class="line"><span class="keyword">long</span> * newmem;</span><br><span class="line">newmem = (<span class="keyword">long</span>*)<span class="built_in">calloc</span>(<span class="number">100</span>, <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br></pre></td></tr></table></figure>



<h3 id="变长数组-VLA-和malloc-创建数组"><a href="#变长数组-VLA-和malloc-创建数组" class="headerlink" title="变长数组(VLA)和malloc()创建数组"></a>变长数组(VLA)和malloc()创建数组</h3><h4 id="动态数组-dynamic-array"><a href="#动态数组-dynamic-array" class="headerlink" title="动态数组(dynamic array)"></a>动态数组(dynamic array)</h4><p>现在，我们有3种创建数组的方法:</p>
<ul>
<li>声明数组时，用常量表达式表示数组的维度，用数组名访问数组的元素。可以用静态内存或自动内存创建这种数组。</li>
<li>声明变长数组（C99新增的特性）时，用变量表达式表示数组的维度， 用数组名访问数组的元素。具有这种特性的数组只能在自动内存中创建。</li>
<li>声明一个指针，调用malloc()，将其返回值赋给指针，使用指针访问数组的元素。该指针可以是静态的或自动的。</li>
</ul>
<p>使用第2种和第3种方法可以创建动态数组（dynamic array）。这种数组和普通数组不同，可以在程序运行时选择数组的大小和分配内存，使用动态数组给程序带来了更多灵活性。</p>
<h4 id="异同点"><a href="#异同点" class="headerlink" title="异同点"></a>异同点</h4><ul>
<li><p>相同点</p>
<ul>
<li>都可以在程序运行中确定数组的大小</li>
</ul>
</li>
<li><p>不同点</p>
<ul>
<li>变长数组是自动存储类型，程序在离开变长数组定义所在的块时，变长数组占用的内存空间会被自动释放，不必使用 free()。</li>
<li>用malloc()创建的数组不必局限在一个函数内访问。例如，可以这样做：函数创建一个数组并返回指针，供主调函数访问，然后主调函数在末尾调用free()释放之前分配的内存。</li>
</ul>
</li>
</ul>
<p>对多维数组而言，使用变长数组更方便。当然，也可以用 malloc()创建 二维数组，但是语法比较繁琐。如果编译器不支持变长数组特性，就只能固定二维数组的维度，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> m = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> ar2[n][m];  <span class="comment">// VLA</span></span><br><span class="line"><span class="keyword">int</span> (*p2)[<span class="number">6</span>];   <span class="comment">// pre-C99</span></span><br><span class="line"><span class="keyword">int</span> (*p3)[m];   <span class="comment">// VLA support</span></span><br><span class="line">p2 = (<span class="keyword">int</span> (*)[<span class="number">6</span>])<span class="built_in">malloc</span>(n * <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">p2 = (<span class="keyword">int</span> (*)[m])<span class="built_in">malloc</span>(n * m * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));  <span class="comment">// VLA support</span></span><br></pre></td></tr></table></figure>



<h3 id="存储类别的动态内存分配"><a href="#存储类别的动态内存分配" class="headerlink" title="存储类别的动态内存分配"></a>存储类别的动态内存分配</h3><p>存储类别和动态内存分配有何联系？我们来看一个理想化模型。可以认为程序把它可用的内存分为3部分：一部分供具有外部链接、内部链接和无链接的静态变量使用；一部分供自动变量使用；一部分供动态内存分配。</p>
<ul>
<li>静态存储：静态存储类别所用的内存数量在编译时确定，只要程序还在运行，就可访问储存在该部分的数据。该类别的变量在程序开始执行时被创建，在程序 结束时被销毁。</li>
<li>自动存储：自动存储类别的变量在程序进入变量定义所在块时存在，在程序离开块时消失。因此，随着程序调用函数和函数结束，自动变量所用的内存数量也相应地增加和减少。<strong>这部分的内存通常作为栈来处理，</strong>这意味着新创建的变量按顺序加入内存，然后以相反的顺序销毁。</li>
<li>动态分配：动态分配的内存在调用 malloc()或相关函数时存在，在调用 free()后释放。这部分的内存由程序员管理。所以内存块可以在一个函数中创建，在另一个函数中销毁。正是因为这样，这部分的内存用于动态内存分配会支离破碎。也就是说，未使用的内存块分散在已使用的内存块之间。另外，使用动态内存通常比使用栈内存慢。</li>
</ul>
<h2 id="ANSI-C类型限定符-type-qualifier"><a href="#ANSI-C类型限定符-type-qualifier" class="headerlink" title="ANSI C类型限定符(type qualifier)"></a>ANSI C类型限定符(type qualifier)</h2><h3 id="const类型限定符"><a href="#const类型限定符" class="headerlink" title="const类型限定符"></a>const类型限定符</h3><p>以const关键字声明的对象，其值不能通过赋值或递增、递减来修改:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> nochange;</span><br><span class="line">nochange = <span class="number">12</span>;         <span class="comment">// 不允许</span></span><br><span class="line">nochange++;            <span class="comment">// 不允许</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>在指针和形参中使用const</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> * pf;</span><br><span class="line"><span class="keyword">float</span> <span class="keyword">const</span> * pf;  <span class="comment">// 与上式等效，const只要在 * 就可</span></span><br></pre></td></tr></table></figure>

<p>创建了 pf 指向的值不能被改变，而 pf 本身的值可以改变。例如，可以设置该指针指向其他 const值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> * <span class="keyword">const</span> pt;</span><br></pre></td></tr></table></figure>

<p>创建的指针pt本身的值不能更改。pt必须指向同一个地址，但是它所指向的值可以改变。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> * <span class="keyword">const</span> ptr;</span><br></pre></td></tr></table></figure>

<p>表明ptr既不能指向别处，它所指向的值也不能改变。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> limit)</span></span>;</span><br></pre></td></tr></table></figure>

<p>const 关键字的常见用法是声明为函数形参的指针。例如，假设有一个函数要调用 display()显示一个数组的内容。要把数组名作为实际参数传递给该函数，但是数组名是一个地址。该函数可能会更改主调函数中的数据，但是上面的函数原型保证了数据不会被更改。</p>
</li>
<li><p>对全局数据使用const</p>
<p>前面讲过，使用全局变量是一种冒险的方法，因为这样做暴露了数据， 程序的任何部分都能更改数据。如果把数据设置为 const，就可避免这样的危险，因此用 const 限定符声明全局数据很合理。</p>
<p>然而，在文件间共享const数据要小心。可以采用两个策略。</p>
<ul>
<li><p>第一，遵循外部变量的常用规则，即在一个文件中使用定义式声明，在其他文件中使用引用式声明（用extern关键字）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* file1.c */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.14159</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* file2.c */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">double</span> PI;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二，把const变量放在一个头文件中，然后在其他文件中包含该头文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* constant.h */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.14159</span>;  <span class="comment">// 必须使用static</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* file1.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"constant.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* file2.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"constant.h"</span></span></span><br></pre></td></tr></table></figure>

<p><strong>这种方案必须在头文件中用关键字static声明全局const变量</strong>。如果去掉 static，那么在file1.c和file2.c中包含constant.h将导致每个文件中都有一个相同标识符的定义式声明，C标准不允许这样做。实际上，这种方案相当于给每个文件提供了一个单独的数据副本。每个副本只对该文件可见，所以无法用这些数据和其他文件通信。不过没关系，它们都是完全相同（每个文件都包含相同的头文件）的const数据。</p>
</li>
</ul>
</li>
</ul>
<h3 id="volatile类型限定符"><a href="#volatile类型限定符" class="headerlink" title="volatile类型限定符"></a>volatile类型限定符</h3><p>volatile 限定符告知计算机，代理（而不是变量所在的程序）可以改变该变量的值。通常，它被用于硬件地址以及在其他程序或同时运行的线程中共享数据。例如，一个地址上可能储存着当前的时钟时间，无论程序做什么，地址上的值都随时间的变化而改变。或者一个地址用于接受另一台计算机传入的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> loc;</span><br><span class="line">volative <span class="keyword">int</span> * ploc;</span><br></pre></td></tr></table></figure>

<p>volatile类型限定符的作用在于编译器的优化，例如下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val1 = x;</span><br><span class="line">val2 = x;</span><br></pre></td></tr></table></figure>

<p>智能的（进行优化的）编译器会注意到以上代码使用了两次 x，但并未改变它的值。于是编译器把 x的值临时储存在寄存器中，然后在val2需要使用x时，才从寄存器中（而不是从原始内存位置上）读取x的值，以节约时间。这个过程被称为高速缓存（caching）。通常，高速缓存是个不错的优化方案，但是如果一些其他代理在以上两条语句之间改变了x的值，就不能这样优化了。如果没有volatile关键字，编译器就不知道这种事情是否会发生。因此，为安全起见，编译器不会进行高速缓存。这是在 ANSI 之前的情况。现在，如果声明中没有volatile关键字，编译器会假定变量的值在使用过程中不变，然后再尝试优化代码。</p>
<p><strong>可以同时用const和volatile限定一个值</strong>。例如，通常用const把硬件时钟设置为程序不能更改的变量，但是可以通过代理改变，这时用 volatile。只能在声明中同时使用这两个限定符，它们的顺序不重要，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">const</span> <span class="keyword">int</span> loc1;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keyword">int</span> loc2;</span><br></pre></td></tr></table></figure>



<h3 id="restirct类型限定符"><a href="#restirct类型限定符" class="headerlink" title="restirct类型限定符"></a>restirct类型限定符</h3><p>restrict 关键字允许编译器优化某部分代码以更好地支持计算。<strong>它只能用于指针，表明该指针是访问数据对象的唯一且初始的方式</strong>，以下面的代码为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ar[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">restrict</span> restar = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">int</span> *par = ar;</span><br></pre></td></tr></table></figure>

<p>这里，指针restar是访问由malloc()所分配内存的<strong>唯一且初始</strong>的方式。因此，可以用restrict关键字限定它。而指针par既不是访问ar数组中数据的初始 方式，也不是唯一方式。所以不能把它设置为restrict。</p>
<p>现在考虑下面稍复杂的例子，其中n是int类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; <span class="number">10</span>; n++)</span><br><span class="line">&#123;</span><br><span class="line">  par[n] += <span class="number">5</span>;</span><br><span class="line">  restar[n] += <span class="number">5</span>;</span><br><span class="line">  ar[n] *= <span class="number">2</span>;</span><br><span class="line">  par[n] += <span class="number">3</span>;</span><br><span class="line">  restar[n] += <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于之前声明了 restar 是访问它所指向的数据块的唯一且初始的方式， 编译器可以把涉及 restar的两条语句替换成下面这条语句，效果相同：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">restar[<span class="number">0</span>] += <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<p>但是，如果把与par相关的两条语句替换成下面的语句，将导致计算错误：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">par[<span class="number">0</span>] += <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<p>这是因为for循环在par两次访问相同的数据之间，用ar改变了该数据的值。</p>
<p>在本例中，如果未使用restrict关键字，编译器就必须假设最坏的情况 （即，在两次使用指针之间，其他的标识符可能已经改变了数据）。如果用 了restrict关键字，编译器就可以选择捷径优化计算。</p>
<p>restrict限定符还可用于函数形参中的指针。这意味着编译器可以假定在函数体内其他标识符不会修改该指针指向的数据，而且编译器可以尝试对其优化，使其不做别的用途。</p>
<p>需要关注restrict 关键字的两者。一个是编译器，该关键字告知编译器可以自由假定一些优化方案。另一个是用户，该关键字告知用户要使用满足 restrict要求的参数。总而言之，编译器不会检查用户是否遵循这一限制，但是无视它后果自负。</p>
<h3 id="Atomic类型限定符"><a href="#Atomic类型限定符" class="headerlink" title="Atomic类型限定符"></a>Atomic类型限定符</h3><p>并发程序设计把程序执行分成可以同时执行的多个线程。这给程序设计 带来了新的挑战，包括如何管理访问相同数据的不同线程。C11通过包含可选的头文件stdatomic.h和threads.h，提供了一些可选的管理方法。值得注意的是，<strong>要通过各种宏函数来访问原子类型。当一个线程对一个原子类型的对象执行原子操作时，其他线程不能访问该对象。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_Atomic <span class="keyword">int</span> hogs;           <span class="comment">// hogs是一个原子类型的变量</span></span><br><span class="line">atomic_store(&amp;hogs, <span class="number">12</span>);    <span class="comment">// stdatomic.h中的宏</span></span><br></pre></td></tr></table></figure>

<p>这里，在hogs中储存12是一个原子过程，其他线程不能访问hogs。</p>
<h3 id="旧关键字的新位置"><a href="#旧关键字的新位置" class="headerlink" title="旧关键字的新位置"></a>旧关键字的新位置</h3><p>C99允许把类型限定符和存储类别说明符static放在函数原型和函数头的形式参数的初始方括号中。对于类型限定符而言，这样做为现有功能提供了一个替代的语法。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mufunc</span><span class="params">(<span class="keyword">int</span> * <span class="keyword">const</span> a1, <span class="keyword">int</span> * <span class="keyword">restrict</span> a2, <span class="keyword">int</span> n)</span></span>;  <span class="comment">// 旧语法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">(<span class="keyword">int</span> a1[<span class="keyword">const</span>], <span class="keyword">int</span> a2[<span class="keyword">restrict</span>], <span class="keyword">int</span> n)</span></span>;    <span class="comment">// 新的等价语法，C99</span></span><br></pre></td></tr></table></figure>

<p><strong>static的情况不同，因为新标准为static引入了一种与以前用法不相关的新用法</strong>。现在，static除了表明静态存储类别变量的作用域或链接外，新的用法告知编译器如何使用形式参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">stick</span><span class="params">(<span class="keyword">double</span> ar[<span class="keyword">static</span> <span class="number">20</span>])</span></span>;</span><br></pre></td></tr></table></figure>

<p>static 的这种用法表明，函数调用中的实际参数应该是一个<strong>指向数组首元素的指针，且该数组至少有20个元素</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/13/%E7%BB%93%E6%9E%84%E5%92%8C%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E5%BD%A2%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="崔梓坤">
      <meta itemprop="description" content="我的计算机学习经历和笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="崔梓坤的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/13/%E7%BB%93%E6%9E%84%E5%92%8C%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E5%BD%A2%E5%BC%8F/" class="post-title-link" itemprop="url">结构和其他数据形式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-13 18:26:47 / 修改时间：18:27:21" itemprop="dateCreated datePublished" datetime="2020-06-13T18:26:47+08:00">2020-06-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="结构-structure"><a href="#结构-structure" class="headerlink" title="结构(structure)"></a>结构(structure)</h2><p>C 结构提供在相同的数据对象中储存多个不同类型数据项的方法。可以 使用标记来标识一个具体的结构模板，并声明该类型的变量。通过成员点运 算符（.）可以使用结构模版中的标签来访问结构的各个成员。</p>
<h3 id="建立结构声明"><a href="#建立结构声明" class="headerlink" title="建立结构声明"></a>建立结构声明</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span>&#123;</span>        <span class="comment">// book是该结构的标记 tag</span></span><br><span class="line">  <span class="keyword">char</span> title[<span class="number">40</span>];</span><br><span class="line">  <span class="keyword">char</span> author[<span class="number">40</span>];</span><br><span class="line">  <span class="keyword">float</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该声明描述了一个由两个字符数组和一个float类型变量组成的结构。<strong>上述声明并未创建实际的数据对象</strong>，只描述了该对象由什么组成。下一步是创建一个结构变量，即是结构的另一层含义。程序中创建结构变量的一行是:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span>;</span></span><br></pre></td></tr></table></figure>

<p>这把library声明为一个使用book结构布局的结构变量。在结构的变量的声明中，struct book的作用相当于int或float。例如，可以定义两个struct book类型的变量，还可以定义指向struct book类型的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">doyle</span>, <span class="title">panshin</span>, * <span class="title">ptbook</span>;</span></span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/Carlisle345748/cloudimg/raw/master/img/结构的内存分配.png" alt="结构的内存分配" style="zoom:50%;" />

<p><strong>简化声明形式</strong></p>
<p>声明结构的过程和定义结构变量的过程可以组合成一个步骤，甚至不需要tag。不使用tag声明的结构不会创建结构模型，所以如果打算多次使用这样的结构，就需要使用tag。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span>&#123;</span></span><br><span class="line">  <span class="keyword">char</span> title[<span class="number">40</span>];</span><br><span class="line">  <span class="keyword">char</span> author[<span class="number">40</span>];</span><br><span class="line">  <span class="keyword">float</span> value;</span><br><span class="line">&#125; library;   <span class="comment">// 声明的右花括号后跟变量名</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span>      <span class="comment">// 不需要标记tag</span></span><br><span class="line">  <span class="keyword">char</span> title[<span class="number">40</span>];</span><br><span class="line">  <span class="keyword">char</span> author[<span class="number">40</span>];</span><br><span class="line">  <span class="keyword">float</span> value;</span><br><span class="line">&#125; library;   <span class="comment">// 声明的右花括号后跟变量名</span></span><br></pre></td></tr></table></figure>



<h3 id="初始化结构变量"><a href="#初始化结构变量" class="headerlink" title="初始化结构变量"></a>初始化结构变量</h3><p>可以使用普通初始化或指定初始化器来初始化结构变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span> = &#123;</span></span><br><span class="line">  <span class="string">"The Pious Pirate amd the Devious Damsel"</span>,</span><br><span class="line">  <span class="string">"Remme Vivotte"</span>,</span><br><span class="line">  <span class="number">1.95</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定初始化器</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span> = &#123;</span>.value = <span class="number">10.99</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任意顺序使用指定初始化器</span></span><br><span class="line">struct book gift = &#123;</span><br><span class="line">  .value = <span class="number">25.99</span>,</span><br><span class="line">  .author = <span class="string">"James"</span>,</span><br><span class="line">  .title = <span class="string">"Red and Black"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与数组类似，在指定初始化器后面的普通初始化器，为指定成员后面的成员提供初始值。另外，对特定成员的最后一次赋值才是它实际获得的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">gitf</span> = &#123;</span></span><br><span class="line">  .valie = <span class="number">18.90</span>,</span><br><span class="line">  .author = <span class="string">"Pestle"</span>,</span><br><span class="line">  <span class="number">0.25</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>赋给value的值是0.25，因为它在结构声明中紧跟在author成员之后。新值0.25取代了之前的18.9。</p>
<h3 id="访问结构成员"><a href="#访问结构成员" class="headerlink" title="访问结构成员"></a>访问结构成员</h3><p>使用结构成员运算符——点（.）访问结构中的成员。注意，虽然library是一个结构，但是library.value是一个float类型的变量，可以像使用其他 float 类型变量那样使用它</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span> = &#123;</span></span><br><span class="line">  .value = <span class="number">25.99</span>,</span><br><span class="line">  .author = <span class="string">"James"</span>,</span><br><span class="line">  .title = <span class="string">"Red and Black"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">library.author;   <span class="comment">// "James"</span></span><br><span class="line">library.title;	  <span class="comment">// "Red and Black"</span></span><br><span class="line">library.value;    <span class="comment">//  25.99</span></span><br></pre></td></tr></table></figure>



<h3 id="结构之间赋值"><a href="#结构之间赋值" class="headerlink" title="结构之间赋值"></a>结构之间赋值</h3><p>现在的C允许把一个结构赋值给另一个结构，但是数组不能这样做。也就是说，如果n_data和o_data都是相同类型的结构，可以这样做：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o_data = n_data;</span><br></pre></td></tr></table></figure>

<p><strong>这条语句把n_data的每个成员的值都赋给o_data的相应成员。即使成员是数组，也能完成赋值</strong>。另外，还可以把一个结构初始化为相同类型的另一 个结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">right_field</span> = &#123;</span><span class="string">"Ruthie"</span>, <span class="string">"George"</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">captain</span> = <span class="title">right_field</span>;</span></span><br></pre></td></tr></table></figure>



<h3 id="结构数组"><a href="#结构数组" class="headerlink" title="结构数组"></a>结构数组</h3><p>类似其他变量，结构也可以创建结构数组。声明结构数组和声明其他类型的数组类似，下面是一个声明结构数组的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span>[100];</span></span><br></pre></td></tr></table></figure>

<p>访问结构数组内结构的成员</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">library[<span class="number">1</span>].author</span><br></pre></td></tr></table></figure>



<h3 id="嵌套结构"><a href="#嵌套结构" class="headerlink" title="嵌套结构"></a>嵌套结构</h3><p>在结构中中还可以包含另外一个结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">name</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> first[<span class="number">40</span>];</span><br><span class="line">  <span class="keyword">char</span> last[<span class="number">40</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">friend</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">name</span> <span class="title">handle</span>;</span>  <span class="comment">// 嵌套结构</span></span><br><span class="line">  <span class="keyword">char</span> favfood[<span class="number">40</span>];</span><br><span class="line">  <span class="keyword">char</span> job[<span class="number">40</span>];</span><br><span class="line">  <span class="keyword">float</span> income;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化嵌套结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">friend</span> <span class="title">Jack</span> = &#123;</span></span><br><span class="line">  &#123;<span class="string">"Jack"</span>, <span class="string">"Cral"</span>&#125;,</span><br><span class="line">  <span class="string">"grilled salmon"</span>,</span><br><span class="line">  <span class="string">"Personality coach"</span>,</span><br><span class="line">  <span class="number">68112.00</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问嵌套结构成员</span></span><br><span class="line">Jack.handle.first; <span class="comment">// "Jack"</span></span><br><span class="line">Jack.handle.last;  <span class="comment">// "Carl"</span></span><br></pre></td></tr></table></figure>



<h3 id="指向结构的指针"><a href="#指向结构的指针" class="headerlink" title="指向结构的指针"></a>指向结构的指针</h3><p>使用结构指针的四大理由：</p>
<ul>
<li>比结构本身更容易操控(比如排序)</li>
<li>一些早期的C实现中，结构不能作为参数传递给函数，但是可以传递指向结构的指针（向后兼容）</li>
<li>传递指针比传递结构更有效率</li>
<li>一些数据结构中需要使用指向其他结构的指针</li>
</ul>
<h4 id="声明结构指针"><a href="#声明结构指针" class="headerlink" title="声明结构指针"></a>声明结构指针</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">guy</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">name</span> <span class="title">handle</span>;</span></span><br><span class="line">  <span class="keyword">char</span> favfood[<span class="number">40</span>];</span><br><span class="line">  <span class="keyword">char</span> job[<span class="number">40</span>];</span><br><span class="line">  <span class="keyword">float</span> income;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">friend</span> * <span class="title">him</span>;</span>   <span class="comment">// 声明结构指针</span></span><br></pre></td></tr></table></figure>

<p>指针him现在可以指向任意现有的guy类型的结构，例如如果barney是一个guy类型的结构，可以这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">him = &amp;barney;   <span class="comment">// 结构名不是结构地址，要加上&amp;</span></span><br></pre></td></tr></table></figure>

<p><strong>和数组不同的是，结构名并不是结构的地址，因此要在结构名前面加上 &amp;运算符。</strong></p>
<h4 id="用指针访问结构成员"><a href="#用指针访问结构成员" class="headerlink" title="用指针访问结构成员"></a>用指针访问结构成员</h4><ul>
<li><p>使用<code>-&gt;</code>运算符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">him = &amp;barney;</span><br><span class="line">him-&gt;income   <span class="comment">// 等价于barney.income</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解引用后访问</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">him = &amp;barney;</span><br><span class="line">(*him).income <span class="comment">// 等价于barney.income</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="向函数传递结构信息"><a href="#向函数传递结构信息" class="headerlink" title="向函数传递结构信息"></a>向函数传递结构信息</h3><h4 id="传递结构成员"><a href="#传递结构成员" class="headerlink" title="传递结构成员"></a>传递结构成员</h4><p>只要结构成员是一个具有单个值的数据类型（即，int及其相关类型、 char、float、double或指针），便可把它作为参数传递给接受该特定类型的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNDLEN 50</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">funds</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> bank[FUNDLEN];</span><br><span class="line">  <span class="keyword">double</span> bankfund;</span><br><span class="line">  <span class="keyword">char</span> save[FUNDLEN];</span><br><span class="line">  <span class="keyword">double</span> savefund;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">funds</span> <span class="title">stan</span> = &#123;</span></span><br><span class="line">    <span class="string">"Garlic"</span>,</span><br><span class="line">    <span class="number">40532.27</span>,</span><br><span class="line">    <span class="string">"Lucky"</span>,</span><br><span class="line">    <span class="number">8543.94</span></span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Stan has a total of $%.2f\n"</span>, sum(stan.bankfund, stan.savefund));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="传递结构的地址"><a href="#传递结构的地址" class="headerlink" title="传递结构的地址"></a>传递结构的地址</h4><p>继续解决前面的问题，但是这次把结构的地址作为参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNDLEN 50</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">funds</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> bank[FUNDLEN];</span><br><span class="line">  <span class="keyword">double</span> bankfund;</span><br><span class="line">  <span class="keyword">char</span> save[FUNDLEN];</span><br><span class="line">  <span class="keyword">double</span> savefund;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于该函数不能改变指针所指向值的内容，所以把money声明为一个指向const的指针。</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> struct funds *)</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">funds</span> <span class="title">stan</span> = &#123;</span></span><br><span class="line">    <span class="string">"Garlic"</span>,</span><br><span class="line">    <span class="number">40532.27</span>,</span><br><span class="line">    <span class="string">"Lucky"</span>,</span><br><span class="line">    <span class="number">8543.94</span></span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Stan has a total of $%.2f\n"</span>, sum(&amp;stan));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> struct funds * money)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> money-&gt;savefund + money-&gt;bankfund;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="传递结构"><a href="#传递结构" class="headerlink" title="传递结构"></a>传递结构</h4><p>新的编译器允许把结构直接作为参数，因此可以把上述程序重写为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNDLEN 50</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">funds</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> bank[FUNDLEN];</span><br><span class="line">  <span class="keyword">double</span> bankfund;</span><br><span class="line">  <span class="keyword">char</span> save[FUNDLEN];</span><br><span class="line">  <span class="keyword">double</span> savefund;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于该函数不能改变指针所指向值的内容，所以把money声明为一个指向const的指针。</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> struct funds)</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">funds</span> <span class="title">stan</span> = &#123;</span></span><br><span class="line">    <span class="string">"Garlic"</span>,</span><br><span class="line">    <span class="number">40532.27</span>,</span><br><span class="line">    <span class="string">"Lucky"</span>,</span><br><span class="line">    <span class="number">8543.94</span></span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Stan has a total of $%.2f\n"</span>, sum(stan));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> struct funds money)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> money.avefund + money.bankfund;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用sum()时，编译器根据funds模板创建 了一个名为money的自动结构变量。然后，该结构的各成员被初始化为 stan 结构变量相应成员的值的副本，因此函数中使用原来结构的副本来进行计算，而传递结构地址的函数中，函数使用原始结构进行运算。</p>
<h4 id="结构作为返回值"><a href="#结构作为返回值" class="headerlink" title="结构作为返回值"></a>结构作为返回值</h4><p>现在的C（包括ANSI C），函数不仅能把结构本身作为参数传递，还能把结构作为返回值返回。把结构作为函数参数可以把结构的信息传送给函数；把结构作为返回值的函数能把结构的信息从被调函数传回主调函数。结构指针也允许这种双向通信，因此可以选择任一种方法来解决编程问题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NLEN 30</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">namect</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> fname[NLEN];</span><br><span class="line">  <span class="keyword">char</span> lname[NLEN];</span><br><span class="line">  <span class="keyword">int</span> letters;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct namect <span class="title">getinfo</span><span class="params">(<span class="keyword">void</span>)</span></span>;           <span class="comment">// 以结构作为返回值</span></span><br><span class="line"><span class="function">struct namect <span class="title">makeinfo</span><span class="params">(struct namect)</span></span>; <span class="comment">// 以结构作为参数和返回值</span></span><br></pre></td></tr></table></figure>



<h4 id="函数中结构和结构指针的选择"><a href="#函数中结构和结构指针的选择" class="headerlink" title="函数中结构和结构指针的选择"></a>函数中结构和结构指针的选择</h4><p>把指针作为参数有两个优点和一个缺点：</p>
<ul>
<li><p>优点1：无论是以前还是现在的C实现都能使用这种方法</p>
</li>
<li><p>优点2：效率高，只需要传递一个地址。</p>
</li>
<li><p>缺点1：无法保护数据。 被调函数中的某些操作可能会意外影响原来结构中的数据。</p>
</li>
</ul>
<p>把结构作为参数传递的优点和缺点：</p>
<ul>
<li><p>优点1：函数处理的是原始数据的副本，保护了原始数据</p>
</li>
<li><p>优点2：代码风格更清楚</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vector</span> &#123;</span></span><br><span class="line">  <span class="keyword">double</span> x; </span><br><span class="line">  <span class="keyword">double</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vector</span> <span class="title">ans</span>, <span class="title">a</span>, <span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递结构版本</span></span><br><span class="line"><span class="function">struct <span class="built_in">vector</span> <span class="title">sum_vect</span><span class="params">(struct <span class="built_in">vector</span>, struct <span class="built_in">vector</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line">ans = sum_vect(a,b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递指针版本</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum_vect</span><span class="params">(<span class="keyword">const</span> struct <span class="built_in">vector</span> *, <span class="keyword">const</span> struct <span class="built_in">vector</span> *, struct <span class="built_in">vector</span> *)</span></span>;</span><br><span class="line">....</span><br><span class="line">sum_vect(&amp;a, &amp;b, &amp;ans);</span><br><span class="line"><span class="comment">// 另外，如果使用指针版本，程序员必须记住总和的地址应该是第1个参数还是第2个参数的地址。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>缺点1：较老版本的实现可能无法处理这样的代码</p>
</li>
<li><p>缺点2：传递结构浪费时间和存储空间。尤其是把大型结构传递给函数，而它只使 用结构中的一两个成员时特别浪费</p>
</li>
</ul>
<h3 id="结构中的字符数组和字符指针"><a href="#结构中的字符数组和字符指针" class="headerlink" title="结构中的字符数组和字符指针"></a>结构中的字符数组和字符指针</h3><p>到目前为止，我们在结构中都使用字符数组来储存字符串。是否可以使用指向 char 的指针来代替字符数组？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 20</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> first[LEN];</span><br><span class="line">  <span class="keyword">char</span> last[LEN]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pnames</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> * first;</span><br><span class="line">  <span class="keyword">char</span> * last;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">veep</span> = &#123;</span><span class="string">"Tilia"</span>, <span class="string">"Summbers"</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pnames</span> <span class="title">treas</span> = &#123;</span><span class="string">"Brad"</span>, <span class="string">"Fallingjaw"</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>对于struct names类型的结构变量veep，以上字符串都储存在结构内部， 结构总共要分配40字节储存姓名。然而，对于struct pnames类型的结构变量 treas，<strong>以上字符串储存在编译器储存常量的地方</strong>。结构本身只储存了两个地址，在我们的系统中共占16字节。尤其是，struct pnames结构不用为字符串分配任何存储空间。它使用的是储存在别处的字符串（如，字符串常量或数组中的字符串）。简而言之，在pnames结构变量中的指针应该只用来在程序中管理那些已分配和在别处分配的字符串。</p>
<p>我们看看这种限制在什么情况下出问题。考虑下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">accountant</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pnames</span> <span class="title">attorney</span>;</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Enter the last name of your accountant:"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, accountant.last);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Enter the last name of your attorney: "</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, attorney.last);  <span class="comment">// 这里有潜在危险</span></span><br></pre></td></tr></table></figure>

<p>就语法而言，这段代码没问题。但是，用户的输入储存到哪里去了？对于accountant，他的名储存在accountant结构变量的last成员中，该结构中有一个储存字符串的数组。<strong>对于attorney，scanf()把字符串放到attorney.last表示的地址上。由于这是未经初始化的变量，地址可以是任何值，因此程序可以把名放在任何地方。如果走运的话，程序不会出问题，至少暂时不会出问题，否则这一操作会导致程序崩溃</strong>。实际上，如果程序能正 常运行并不是好事，因为这意味着一个未被觉察的危险潜伏在程序中。</p>
<h3 id="结构、指针和malloc"><a href="#结构、指针和malloc" class="headerlink" title="结构、指针和malloc()"></a>结构、指针和malloc()</h3><p><strong>如果使用malloc()分配内存并使用指针储存该地址，那么在结构中使用指针处理字符串就比较合理</strong>。这种方法的优点是，可以请求malloc()为字符串分配合适的存储空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pnames</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> * first;</span><br><span class="line">  <span class="keyword">char</span> * last;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pnames</span> <span class="title">father</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pnames</span> <span class="title">attorney</span>;</span></span><br><span class="line">father.first (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">40</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">father.last (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">40</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br></pre></td></tr></table></figure>

<p><strong>要注意，first和last指向的两个字符串都不储存在结构中，它们储存在 malloc()分配的内存块中。</strong>在结构使用完毕后，要使用free()函数释放动态分配的内存块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(father.first);</span><br><span class="line"><span class="built_in">free</span>(father.last);</span><br></pre></td></tr></table></figure>



<h3 id="复合字面量和结构"><a href="#复合字面量和结构" class="headerlink" title="复合字面量和结构"></a>复合字面量和结构</h3><p>如果只需要一个临时结构值，复合字面量很好用。例如，可以使用复合字面量创建一个数组作为函数的参数或赋给另一个结构。语法是把类型名放在圆括号中，后面紧跟一个用花括号括起来的初始化列表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="class"><span class="keyword">struct</span> <span class="title">book</span>&#125;&#123;</span><span class="string">"The idiot"</span>, <span class="string">"Fyodor"</span>, <span class="number">6.99</span>&#125;;</span><br><span class="line">&#123;<span class="class"><span class="keyword">struct</span> <span class="title">names</span>&#125;&#123;</span><span class="string">"Jack"</span>, <span class="string">"Chan"</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>还可以把复合字面量作为函数的参数。如果函数接受一个结构，可以把复合字面量作为实际参数传递：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(struct book, struct book)</span></span>;</span><br><span class="line">sum(&#123;struct book&#125;&#123;<span class="string">"The idiot"</span>, <span class="string">"Fyodor"</span>, <span class="number">6.99</span>&#125;, &#123;struct book&#125;&#123;<span class="string">"Flower"</span>, <span class="string">"Mark"</span>, <span class="number">15.0</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>复合字面量在所有函数的外部，具有静态存储期；如果复合字面量在块中，则具有自动存储期。复合字面量和普通初始化列表的语法规则相同。这意味着，可以在复合字面量中使用指定初始化器。</p>
<h3 id="伸缩型-Flexible-数组成员-C99"><a href="#伸缩型-Flexible-数组成员-C99" class="headerlink" title="伸缩型(Flexible)数组成员(C99)"></a>伸缩型(Flexible)数组成员(C99)</h3><p>C99新增了一个特性：伸缩型数组成员（flexible array member），利用 这项特性声明的结构，其最后一个数组成员具有一些特性。</p>
<ul>
<li>该数组不会立即存在。</li>
<li>使用这个伸缩型数组成员可以编写合适的代码，就好像它确实存在并具有所需数目的元素一样。</li>
</ul>
<p>首先，声明一个伸缩型数组成员有如下规则：</p>
<ul>
<li><p>伸缩型数组成员必须是结构的最后一个成员；</p>
</li>
<li><p>结构中必须至少有一个成员；</p>
</li>
<li><p>伸缩数组的声明类似于普通数组，只是它的方括号中是空的</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flex</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> count;</span><br><span class="line">  <span class="keyword">double</span> average;</span><br><span class="line">  <span class="keyword">double</span> scores[];  <span class="comment">// 伸缩数组成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明一个struct flex类型的结构变量时，不能用scores做任何事，因为没有给这个数组预留存储空间。实际上，C99的意图并不是让你声明struct flex 类型的变量，而是希望你声明一个指向struct flex类型的指针，然后用 malloc()来分配足够的空间，以储存struct flex类型结构的常规内容和伸缩型 数组成员所需的额外空间。例如，假设用scores表示一个内含5个double类型 值的数组，可以这样做：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flex</span> * <span class="title">pf</span>;</span></span><br><span class="line">pf = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct flex) + <span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br></pre></td></tr></table></figure>

<p>现在有足够的存储空间储存count、average和一个内含5个double类型值 的数组。可以用指针pf访问这些成员：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pf-&gt;count = <span class="number">5</span>;</span><br><span class="line">pf-&gt;score[<span class="number">2</span>] = <span class="number">18.5</span>;</span><br></pre></td></tr></table></figure>

<p>下面的程序进一步扩展了这个例子，让伸缩型数组成员在第1种情况下表示5个值，在第2种情况下代表9个值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flex</span>&#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    <span class="keyword">double</span> average;</span><br><span class="line">    <span class="keyword">double</span> scores[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showFlex</span><span class="params">(<span class="keyword">const</span> struct flex * p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flex</span> * <span class="title">pf1</span>, *<span class="title">pf2</span>;</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pf1 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct flex) + n * <span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">    pf1-&gt;count = n;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pf1-&gt;scores[i] = <span class="number">20.0</span> - i;</span><br><span class="line">        tot += pf1-&gt;scores[i];</span><br><span class="line">    &#125;</span><br><span class="line">    pf1-&gt;average = tot / n;</span><br><span class="line">    showFlex(pf1);</span><br><span class="line"></span><br><span class="line">    n = <span class="number">9</span>;</span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">    pf2 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct flex) + n * <span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">    pf2-&gt;count = n;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pf2-&gt;scores[i] = <span class="number">20.0</span> - i/<span class="number">2.0</span>;</span><br><span class="line">        tot += pf2-&gt;scores[i];</span><br><span class="line">    &#125;</span><br><span class="line">    pf2-&gt;average = tot / n;</span><br><span class="line">    showFlex(pf2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showFlex</span><span class="params">(<span class="keyword">const</span> struct flex * p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Scores: "</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; p-&gt;count;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%g "</span>, p-&gt;scores[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nAverage: %g\n"</span>, p-&gt;average);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>带伸缩型数组成员的结构确实有一些特殊的处理要求：</p>
<ul>
<li>第一，不能用结构进行赋值或拷贝：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*pf2 = *pf1; <span class="comment">// 不允许</span></span><br></pre></td></tr></table></figure>

<ul>
<li>第二，不能以按值的方式把这种结构传递给函数，要把结构的地址传递给函数。</li>
<li>第三，不要使用带伸缩型数组成员的结构作为数组成员或另一个结构的 成员。</li>
</ul>
<h3 id="匿名结构-C11"><a href="#匿名结构-C11" class="headerlink" title="匿名结构(C11)"></a>匿名结构(C11)</h3><p>匿名结构是一个没有名称的结构成员。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> id;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span><span class="keyword">char</span> first[<span class="number">20</span>]; <span class="keyword">char</span> last[<span class="number">20</span>]&#125;; <span class="comment">// 匿名结构成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化方式与普通结构一样</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> <span class="title">ted</span> = &#123;</span><span class="number">8483</span>, &#123;<span class="string">"Ted"</span>, <span class="string">"Grace"</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>匿名结构的特征，就是简化了成员访问的步骤，只需要吧把first看作person成员那样使用它：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(ted.frist);</span><br></pre></td></tr></table></figure>



<h3 id="使用结构数组的函数"><a href="#使用结构数组的函数" class="headerlink" title="使用结构数组的函数"></a>使用结构数组的函数</h3><ul>
<li><p>可以把数组名作为数组中第1个结构的地址传递给函数。</p>
</li>
<li><p>可以用数组表示法访问数组中的其他结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">funds</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> bank[<span class="number">40</span>];</span><br><span class="line">  <span class="keyword">double</span> bankfund;</span><br><span class="line">  <span class="keyword">char</span> save[<span class="number">40</span>];</span><br><span class="line">  <span class="keyword">double</span> savefund;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> struct fund * money, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">funds</span> <span class="title">jones</span>[2] = &#123;</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"Jack"</span>,</span><br><span class="line">      <span class="number">1000.0</span>,</span><br><span class="line">      <span class="string">"Mark"</span>,</span><br><span class="line">      <span class="number">2000.0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"Teddy"</span>,</span><br><span class="line">      <span class="number">500.0</span>,</span><br><span class="line">      <span class="string">"Delores"</span>,</span><br><span class="line">      <span class="number">50000.0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  sum(jones, <span class="number">2</span>);</span><br><span class="line">  <span class="comment">// 等效 sum(&amp;jones[0], 2);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> struct funds meney[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">double</span> total;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    total += money[i].savefund + money[i].bankfund;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="联合-Union"><a href="#联合-Union" class="headerlink" title="联合(Union)"></a>联合(Union)</h2><p>联合（union）是一种数据类型，它能在同一个内存空间中储存不同的数据类型<strong>（不是同时储存）</strong>。其典型的用法是，设计一种表以储存既无规律、事先也不知道顺序的混合类型。使用联合类型的数组，其中的联合都大小相等，每个联合可以储存各种数据类型。</p>
<h3 id="创建联合"><a href="#创建联合" class="headerlink" title="创建联合"></a>创建联合</h3><p>创建联合和创建结构的方式相同，需要一个联合模板和联合变量。可以用一个步骤定义联合，也可以用联合标记分两步定义。下面是一个带标记的联合模板：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> hold &#123;</span><br><span class="line">  <span class="keyword">int</span> digit;</span><br><span class="line">  <span class="keyword">double</span> biglf;</span><br><span class="line">  <span class="keyword">char</span> letter;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>根据以上形式声明的结构可以储存一个int类型、一个double类型和char 类型的值。然而，声明的联合只能储存一个int类型的值或一个double类型的值或char类型的值。</strong></p>
<p>下面定义了3个hold类型相关变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> hold fit;       <span class="comment">// hold类型联合变量</span></span><br><span class="line"><span class="keyword">union</span> hold save[<span class="number">10</span>];  <span class="comment">// 内含10ge联合变量的数组</span></span><br><span class="line"><span class="keyword">union</span> hold * pu;      <span class="comment">// 指向hold类型联合变量的指针</span></span><br></pre></td></tr></table></figure>

<p>第1个声明创建了一个单独的联合变量fit。编译器分配足够的空间以便 它能储存联合声明中占用最大字节的类型。在本例中，占用空间最大的是double类型的数据。在我们的系统中，double类型占64位，即8字节。第2个 声明创建了一个数组save，内含10个元素，每个元素都是8字节。第3个声明创建了一个指针，该指针变量储存hold类型联合变量的地址。</p>
<h3 id="初始化联合"><a href="#初始化联合" class="headerlink" title="初始化联合"></a>初始化联合</h3><p>联合只能储存一个值，这与结构不同。有 3 种初始化的方法：把一个联合初始化为另一个同类型的联合；初始化联合的第1个元素；或者根据C99标准，使用指定初始化器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> hold valA;</span><br><span class="line">valA.letter = <span class="string">'R'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> hold valB = valA;            <span class="comment">// 用另一个联合初始化</span></span><br><span class="line"><span class="keyword">union</span> hold valC = &#123;<span class="number">88</span>&#125;;            <span class="comment">// 初始化联合的digit成员</span></span><br><span class="line"><span class="keyword">union</span> hold valD = &#123;.bigfl = <span class="number">18.2</span>&#125;  <span class="comment">// 指定初始化器</span></span><br></pre></td></tr></table></figure>



<h3 id="使用联合"><a href="#使用联合" class="headerlink" title="使用联合"></a>使用联合</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> hold fit;</span><br><span class="line">fit.digit = <span class="number">23</span>;     <span class="comment">// 把23储存在fit，占用4字节</span></span><br><span class="line">fit.bigfl = <span class="number">2.0</span>;    <span class="comment">// 清除23，储存2.0，占用8字节</span></span><br><span class="line">fit.letter = <span class="string">'h'</span>;   <span class="comment">// 清除2.0，储存h，占用1字节</span></span><br></pre></td></tr></table></figure>

<p>点运算符表示正在使用哪种数据类型。在联合中，一次只储存一个值。 即使有足够的空间，也不能同时储存一个char类型值和一个int类型值。编写 代码时要注意当前储存在联合中的数据类型。</p>
<p>和用指针访问结构使用<code>-&gt;</code>运算符一样，用指针访问联合时也要使用<code>-&gt;</code>运 算符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> hould *pu;</span><br><span class="line">pu = &amp;fit;</span><br><span class="line">x = pu-&gt;digit;</span><br></pre></td></tr></table></figure>

<p>联合的另一种用法是，在结构中储存与其成员有从属关系的信息。例如，假设用一个结构表示一辆汽车。如果汽车属于驾驶者，就要用一个结构 成员来描述这个所有者。如果汽车被租赁，那么需要一个成员来描述其租赁公司。可以用下面的代码来完成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">owner</span>&#123;</span></span><br><span class="line">  <span class="keyword">char</span> socsecurity[<span class="number">12</span>];</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">leasecompany</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">40</span>];</span><br><span class="line">  <span class="keyword">char</span> headquarter[<span class="number">40</span>];</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> data&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">owner</span> <span class="title">owcar</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">leasecompany</span> <span class="title">leasecar</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">car_data</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> make[<span class="number">15</span>];</span><br><span class="line">  <span class="keyword">int</span> status; <span class="comment">//0 = owned, 1=leased</span></span><br><span class="line">  <span class="keyword">union</span> data ownerinfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设flits是car_data类型的结构变量，如果flits.status为0，程序将使用 flits.ownerinfo.owncar.socsecurity，如果flits.status为1，程序则使用 flits.ownerinfo.leasecar.name。</p>
<h3 id="匿名联合-C11"><a href="#匿名联合-C11" class="headerlink" title="匿名联合(C11)"></a>匿名联合(C11)</h3><p>匿名联合和匿名结构的工作原理相同，即匿名联合是一个结构或联合的 无名联合成员。例如，我们重新定义car_data结构如下：’’</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">owner</span>&#123;</span></span><br><span class="line">  <span class="keyword">char</span> socsecurity[<span class="number">12</span>];</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">leasecompany</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">40</span>];</span><br><span class="line">  <span class="keyword">char</span> headquarter[<span class="number">40</span>];</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">car_data</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> make[<span class="number">15</span>];</span><br><span class="line">  <span class="keyword">int</span> status; <span class="comment">//0 = owned, 1=leased</span></span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">owner</span> <span class="title">owncar</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">leasecompany</span> <span class="title">leasecar</span>;</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在，如果 flits 是car_data 类型的结构变量，可以用flits.owncar.socsecurity代替flits.ownerinfo.owncar.socsecurity。</p>
<h2 id="枚举-Enumerated-类型"><a href="#枚举-Enumerated-类型" class="headerlink" title="枚举(Enumerated)类型"></a>枚举(Enumerated)类型</h2><p>可以用枚举类型（enumerated type）<strong>声明符号名称来表示整型常量</strong>。使用enum关键字，可以创建一个新“类型”并指定它可具有的值（实际上，enum 常量是int类型，因此，只要能使用int类型的地方就可以使用枚举类型）。枚举类型的目的是提高程序的可读性。它的语法与结构的语法相同。例如，可以这样声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> spectrum &#123;red, orange, yellow, green, blue, violet&#125;;  <span class="comment">// 声明枚举类型，以spectrum为tag</span></span><br><span class="line"><span class="keyword">enum</span> spectrum color;                                       <span class="comment">// 创建枚举变量</span></span><br></pre></td></tr></table></figure>

<p>color可能的值是 red、 orange、yellow 等。这些符号常量被称为枚举符（enumerator）。</p>
<p>虽然枚举符（如red和blue）是int类型，但是枚举变量可以是任意整数类型，前提是该整数类型可以储存枚举常量。例如，spectrum的枚举符范围是 0～5，所以编译器可以用unsigned char来表示color变量。</p>
<blockquote>
<p><strong>C和C++的枚举</strong></p>
<p>C枚举的一些特性并不适用于C++。例如，C允许枚举变量 使用++运算符，但是C++标准不允许。所以，如果编写的代码将来会并入 C++程序，那么必须把上面例子中的color声明为int类型，才能C和C++都兼 容。</p>
</blockquote>
<h3 id="enum常量"><a href="#enum常量" class="headerlink" title="enum常量"></a>enum常量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> spectrum &#123;red, orange, yellow, green, blue, violet&#125;;</span><br></pre></td></tr></table></figure>

<p>red，orange本质是int类型常量，但他们是“有名称”的常量，只要是能使用整型常量的地方就可以使用枚举常 量。例如，在声明数组时，可以用枚举常量表示数组的大小；在switch语句 中，可以把枚举常量作为标签。</p>
<h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>默认情况下，枚举列表中的常量都被赋予0、1、2等。因此，下面的声 明中nina的值是3：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> kids&#123;nippy, slats, skippy, nina, liz&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>在枚举声明中，可以为枚举常量指定整数值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> levels &#123;low = <span class="number">100</span>, medium = <span class="number">500</span>, high = <span class="number">2000</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>如果只给一个枚举常量赋值，没有对后面的枚举常量赋值，那么后面的常量会被赋予后续的值。例如，假设有如下的声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> feline &#123;cat, lynx = <span class="number">10</span>, puma, tiger&#125;;</span><br></pre></td></tr></table></figure>

<p>那么，cat的值是0（默认），lynx、puma和tiger的值分别是10、11、 12。</p>
<h3 id="enum的用法"><a href="#enum的用法" class="headerlink" title="enum的用法"></a>enum的用法</h3><p>枚举类型的目的是为了提高程序的可读性和可维护性。如果要处理颜色，使用red和blue比使用0和1更直观。注意，枚举类型只能在内部使用。如果要输入color中orange的值，只能输入1，而不是单词orange。或者，让程序 先读入字符串”orange”，再将其转换为orange代表的值。</p>
<p>因为枚举类型是整数类型，所以可以在表达式中以使用整数变量的方式 使用enum变量。它们用在case语句中很方便。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> spectrum &#123;red, orange, yellow, green, blue, violet&#125;;</span><br><span class="line"><span class="keyword">enum</span> spectrum color;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (color)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> red: <span class="built_in">puts</span>(<span class="string">"Rose are red"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> yellow: <span class="built_in">puts</span>(<span class="string">"Sunflower are yellow"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> green: <span class="built_in">puts</span>(<span class="string">"Grass is green"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> blue: <span class="built_in">puts</span>(<span class="string">"Bluebells are blue"</span>);</span><br><span class="line">   	<span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> violet: <span class="built_in">puts</span>(<span class="string">"Violets are violet"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="共享名称空间"><a href="#共享名称空间" class="headerlink" title="共享名称空间"></a>共享名称空间</h2><p>C语言使用名称空间（namespace）标识程序中的各部分，即通过名称来识别。名称空间是分类别的。在特定作用域中的结构标记、联合标记和枚举标记都共享相同的名称空间，该名称空间与普通变量使用的空间不同。这意味着在相同作用域中变量和标记的名称可以相同，不会引起冲突，但是不能在相同作用域中声明两个同名标签或同名变量。例如，在C中，下面的代码不会产生冲突：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rect</span>&#123;</span><span class="keyword">double</span> x; <span class="keyword">double</span> y;&#125;;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">rect</span>; <span class="comment">// 在C中不会产生冲突</span></span><br></pre></td></tr></table></figure>



<h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><p>typedef工具是一个高级数据特性，利用typedef可以为某一类型自定义名称。这方面与#define类似，但是两者有3处不同：</p>
<ul>
<li>与#define不同，typedef创建的符号名只受限于类型，不能用于值。</li>
<li>typedef由编译器解释，不是预处理器。</li>
<li>在其受限范围内，typedef比#define更灵活。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE;  <span class="comment">// 像定义char类型变量一样定义BYTE</span></span><br><span class="line">BYTE x, y[<span class="number">10</span>], *z            <span class="comment">// 便可使用BYTE来定义变量</span></span><br></pre></td></tr></table></figure>

<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>该定义的作用域取决于typedef定义所在的位置。如果定义在函数中，就 具有局部作用域，受限于定义所在的函数。如果定义在函数外面，就具有文件作用域。</p>
<h3 id="define的缺陷"><a href="#define的缺陷" class="headerlink" title="#define的缺陷"></a>#define的缺陷</h3><p>typedef的一些特性与#define的功能重合。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BYTE unsigned char</span></span><br><span class="line">BTYE x;  <span class="comment">// 预处理器把BYTE替换为unsigned char,因此x为unsigned char类型</span></span><br></pre></td></tr></table></figure>

<p>但是，使用#define实现以上功能以下问题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STRING char *</span></span><br><span class="line">STRING name, sign; <span class="comment">//预处理翻译为 char * name, sign，因此name是pointer-to-char，而sign是char</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<p>使用typedef时要记住，typedef并没有创建任何新类型，它只是为某个已存在的类型增加了一个方便使用的标签。</p>
<h3 id="多重typedef"><a href="#多重typedef" class="headerlink" title="多重typedef"></a>多重typedef</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arr5[<span class="number">5</span>];         </span><br><span class="line"><span class="keyword">typedef</span> arr5 *p_arr5;</span><br><span class="line"><span class="keyword">typedef</span> p_arr5 arrp10[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">arr5 togs;  <span class="comment">// togs是一个含有5个int元素的数组</span></span><br><span class="line">p_arr5 p2;  <span class="comment">// p2是一个指向含有5个int元素的数组的指针</span></span><br><span class="line">arrp10 ap;  <span class="comment">// ap是一个含有10个指针的数组，每个指针指向一个含有5个int元素的数组</span></span><br></pre></td></tr></table></figure>



<h2 id="函数的指针"><a href="#函数的指针" class="headerlink" title="函数的指针"></a>函数的指针</h2><p>函数也有地址，因为函数的机器语言实现由载入内存的代码组成。指向函数的指针中储存着函数代码的起始处的地址。声明一个数据指针时，必须声明指针所指向的数据类型。声明一个函数指针时，必须声明指针指向的函数类型。为了指明函数类型，要指明函数签名，即函数的返回类型和形参类型。例如，考虑下面的函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ToUpper</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br></pre></td></tr></table></figure>

<p>ToUpper()函数的类型是“带char * 类型参数、返回类型是void的函数”。 下面声明了一个指针pf指向该函数类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*pf)(<span class="keyword">char</span> ());  <span class="comment">// pf 是一个指向函数的指针</span></span><br></pre></td></tr></table></figure>

<p>从该声明可以看出，第1对圆括号把和pf括起来，表明pf是一个指向函数的指针。因此，<code>(*pf)</code>是一个参数列表为<code>(char *)</code>、返回类型为<code>void</code>的函数。</p>
<p> <strong>注意，把函数名ToUpper替换为表达式<code>(*pf)</code>是创建指向函数指针最简单的方式。所以，如果想声明一个指向某类型函数的指针，可以写出该函数的原型 后把函数名替换成<code>(*pf)</code>形式的表达式，创建函数指针声明。</strong></p>
<p>声明了函数指针后，可以把类型匹配的函数地址赋给它。函数名可以用于表示函数的地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ToUpeer</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ToLower</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">round</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">void</span> (*pf)(<span class="keyword">char</span> *);</span><br><span class="line"></span><br><span class="line">pf = ToUpper;    <span class="comment">// 有效</span></span><br><span class="line">pf = ToLower;    <span class="comment">// 有效</span></span><br><span class="line">pf = round;      <span class="comment">// 无效，round与指针类型不匹配</span></span><br><span class="line">pf = ToLower();  <span class="comment">// 无效，ToLower()不是地址</span></span><br></pre></td></tr></table></figure>

<p>最后一条语句是无效的，不仅因为 ToLower()不是地址，而且ToLower()的返回类型是 void，它没有返回值，不能在赋值语句中进行赋值。</p>
<h3 id="两种函数指针访问函数的方法"><a href="#两种函数指针访问函数的方法" class="headerlink" title="两种函数指针访问函数的方法"></a>两种函数指针访问函数的方法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ToUpper</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ToLower</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="keyword">void</span> (*pf)(<span class="keyword">char</span> *);</span><br><span class="line"><span class="keyword">char</span> mis[] = <span class="string">"Nina Metier"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种</span></span><br><span class="line">pf = ToUpper;</span><br><span class="line">(*pf)(mis);</span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line">pf = ToLower;</span><br><span class="line">pf(mis);</span><br></pre></td></tr></table></figure>

<p>这两种方法看上去互相矛盾，但是又合情合理。</p>
<ul>
<li>第一种方法：由于<code>pf</code>指向ToUpper 函数，那么<code>(*pf</code>)就相当于ToUpper函数，所以表达式<code>(*pf)(mis)</code>和<code>ToUpper(mis)</code> 相同</li>
<li>第二种方法：由于函数名是指针，那么指针和函数名可以互换使用，所以pf(mis) 和ToUpper(mis)相同</li>
</ul>
<p>由于历史的原因，贝尔实验室的C和UNIX的开发者采用第1种形式，而伯克利的UNIX推广者却采用第2种形式。K&amp;R C不允许第2种形式。但是，为了与现有代码兼容，ANSI C认为这两种形式（本例中是(*pf)(mis)和 pf(mis)）等价。后续的标准也延续了这种矛盾的和谐。</p>
<h3 id="作为函数的形式参数"><a href="#作为函数的形式参数" class="headerlink" title="作为函数的形式参数"></a>作为函数的形式参数</h3><p>作为函数的参数是数据指针最常见的用法之一，函数指针亦如此。例如，考虑下面的函数原型和定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">void</span> (* fp)(<span class="keyword">char</span> *), <span class="keyword">char</span> * str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">void</span> (*fp)(<span class="keyword">char</span> *), <span class="keyword">char</span> * str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  (*pf)(mis);</span><br><span class="line">  <span class="built_in">puts</span>(mis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它声明了两个形参：fp和str。fp形参是一个函数指针，str是一个数据指针。更具体地说，fp指向的函数接受char * 类型的参数，其返回类型为void；str指向一个char类型的值。因此，假设有上面的声明，可以这样调用函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show(ToLower, mis);</span><br><span class="line">show(pf, mis)        <span class="comment">// pf = ToLower;</span></span><br></pre></td></tr></table></figure>

<p>还可以使用typedef简化一下复杂的函数原型和函数头</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*V_FP_CHAR)</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(V_FP_CHAR fp, <span class="keyword">char</span> * str)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="函数指针的数组"><a href="#函数指针的数组" class="headerlink" title="函数指针的数组"></a>函数指针的数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*V_FP_CHAR)</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line">V_FP_CHAR pf_arr[<span class="number">4</span>] = &#123;TuUpper, ToLower, Transpose, Dummy&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="复杂的声明"><a href="#复杂的声明" class="headerlink" title="复杂的声明"></a>复杂的声明</h2><p>C 允许用户自定义数据形式。虽然我们常用的是一些简单的形式，但是 根据需要有时还会用到一些复杂的形式。在一些复杂的声明中，常包含下面的符号，如表14.1所示：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>表示一个指针</td>
</tr>
<tr>
<td>()</td>
<td>表示一个函数</td>
</tr>
<tr>
<td>[]</td>
<td>表示一个数组</td>
</tr>
</tbody></table>
<p>*、()和[]的优先级</p>
<ul>
<li><p>数组名后面的[]和函数名后面的()具有相同的优先级。它们比*（解引用运算符）的优先级高。因此下面声明的risk是一个指针数组，不是指向数组的指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *risk[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>[]和()的优先级相同，由于都是从左往右结合，所以下面的声明中，在应用方括号之前，*先与rusks结合。因此rusks是一个指向数组的指针，该数组内含10个int类型的元素：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*rusks)[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>[]和()都是从左往右结合。因此下面声明的goods是一个由12个内含50 个int类型值的数组组成的二维数组，不是一个有50个内含12个int类型值的数组组成的二维数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> goods[<span class="number">12</span>][<span class="number">50</span>];</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *off[<span class="number">3</span>][<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<p>[3]比<code>*</code>的优先级高，由于从左往右结合，所以[3]先与oof结合。因此， oof首先是一个内含3个元素的数组。然后再与[4]结合，所以oof的每个元素 都是内含4个元素的数组。*说明这些元素都是指针。最后，int表明了这4个元素都是指向int的指针。因此，这条声明要表达的是：foo是一个内含3个元素的数组，其中每个元素是由4个指向int的指针组成的数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*uuf)[<span class="number">3</span>][<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<p>圆括号使得*先与uuf结合，说明uuf是一个指针，所以uuf是一个指向3×4，的int类型二维数组的指针。编译器要为一个指针预留存储空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*uof[<span class="number">3</span>])[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<p>一个内含3个指针元素的数组，其中每个指针都指向一个内含4个int类型元素的数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">fump</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>返回字符指针的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> (*frump)(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>

<p>指向函数的指针，该函数的返回类型为char,参数类型为int。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> (* flump[<span class="number">3</span>])(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>

<p>内含三个指向函数指针的数组，函数的返回值类型为char，参数类型为int</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/13/%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="崔梓坤">
      <meta itemprop="description" content="我的计算机学习经历和笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="崔梓坤的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/13/%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA/" class="post-title-link" itemprop="url">文件输入和输出</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-13 18:25:48 / 修改时间：18:26:16" itemprop="dateCreated datePublished" datetime="2020-06-13T18:25:48+08:00">2020-06-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="与文件进行通信"><a href="#与文件进行通信" class="headerlink" title="与文件进行通信"></a>与文件进行通信</h2><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>文件（file）通常是在磁盘或固态硬盘上的一段已命名的存储区。对我们而言，stdio.h就是一个文件的名称，该文件中包含一些有用的信息。对于操作系统而言，文件更复杂一些。例如，大型文件会被分开储存，或者包含一些额外的数据，方便操作系统确定文件的种类。</p>
<p>C把文件看作是一系列连续的字节，每个字节都能被单独读取。这与 UNIX环境中（C的发源地）的文件结构相对应。由于其他环境中可能无法完全对应这个模型，C提供两种文件模式：文本模式和二进制模式。</p>
<h3 id="文本模式和二进制模型"><a href="#文本模式和二进制模型" class="headerlink" title="文本模式和二进制模型"></a>文本模式和二进制模型</h3><p><strong>文本内容和二进制内容</strong></p>
<p>所有文件的内容都以二进制形式（0或1）储存。但是，如果文件最初使用二进制编码的字符（例如， ASCII或Unicode表示文本），该文件就是文本文件，其中包含文本内容。如果文件中的二进制值代表机器语言代码或数值数据（使用相同的内部表示，假设，用于long或 double类型的值）或图片或音乐编码，该文件就是二进制文件，其中包含二进制内容。</p>
<p><strong>不同的操作系统有保存和使用文本的方式：</strong></p>
<ul>
<li>UNIX用同一种文件格式处理文本文件和二进制文件的内容。C和UNIX在文本中都使用<code>\n</code>表示换行。UNIX目录中有一个统计文件大小的计数(counter)，程序可使用该计数确定是否读到文件结尾。</li>
<li>早期的Mac OS X系统使用<code>\r</code> （回车符）表示换行。</li>
<li>早期的MS-DOS文件用<code>\r\n</code>组合表示新的一行，用嵌入的<code>Ctrl+Z</code>字符表示文件结尾，即使实际文件用添加空字符的方法使其总大小是256的倍数。</li>
<li>其他系统可能保持文本文件中的每一 行长度相同，如有必要，用空字符填充每一行，使其长度保持一致。或者，系统可能在每行的开始标出每行的长度。</li>
</ul>
<p><strong>二进制模式和文本模型</strong></p>
<p>为了规范文本文件的处理，C 提供两种访问文件的途径：二进制模式和文本模式。</p>
<ul>
<li>在二进制模式中，程序可以访问文件的每个字节。如果读写一个旧式MS-DOS文本文件，程序会看到文件中的<code>\r</code>和<code>\n</code> 字符，不会进行转换。</li>
<li>文本模式中，程序所见的内容和文件的实际内容不同。程序以文本模式读取文件时，把本地环境表示的行末尾或文件结尾映射为C模式。例如，C程序在旧式Mac OS X中以文本模式读取文件时，把文件中的<code>\r</code>转换成<code>\n</code>；以文本模式写入文件时，把<code>\n</code>转换成<code>\r</code>。或者，C文本模式程序在MS-DOS平台读取文件 时，把<code>\r\n</code>转换成<code>\n</code>；写入文件时，把<code>\n</code>转换成<code>\r\n</code>。在其他环境中编写的文本 模式程序也会做类似的转换。</li>
</ul>
<img src="https://gitee.com/Carlisle345748/cloudimg/raw/master/img/二进制模型和文本模式.png" alt="二进制模型和文本模式" style="zoom:50%;" />

<h3 id="I-O级别"><a href="#I-O级别" class="headerlink" title="I/O级别"></a>I/O级别</h3><ul>
<li>底层I/O（low-level I/O）：使用操作系统提供的基本I/O服务</li>
<li>标准高级I/O（standard high-level I/O）：使用C库的标准包和 stdio.h头文件定义。因为无法保证所有的操作系统都使用相同的底层I/O模型，C标准只支持标准I/O包</li>
</ul>
<h3 id="标准文件"><a href="#标准文件" class="headerlink" title="标准文件"></a>标准文件</h3><p>C程序运行时会自动打开3个文件，它们被称为<strong>标准输入（standard input）、标准输出（standard output）和标准错误输出（standard error output）</strong>。在默认情况下，标准输入是系统的普通输入设备，通常为键盘；标准输出和标准错误输出是系统的普通输出设备，通常为显示屏。</p>
<p>通常，标准输入(stdin)为程序提供输入，它是 getchar()和 scanf()使用的文件。程序通常输出到标准输出(stdout)，它是putchar()、puts()和printf()使用的文件。标准错误输出(stderr)提供了一个逻辑上不同的地方来发送错误消息。</p>
<h2 id="标准IO"><a href="#标准IO" class="headerlink" title="标准IO"></a>标准IO</h2><h3 id="fopen-函数"><a href="#fopen-函数" class="headerlink" title="fopen()函数"></a>fopen()函数</h3><p>fopen()函数为标准 I/O 打开一个文件，并创建一个用于存储文件信息和缓冲区信息的结构体。因为标准库中的I/O函数使用缓冲区，所以它们不仅要知道缓冲区的位置，还要知道缓冲区被填充的程度以及操作哪一个文件。标准I/O函数根据这些信息在必要时决定再次填充或清空缓冲区。 fopen()函数返回指向该结构体的指针，其他函数可以使用该指针指定待处理的文件。</p>
<p>fopen()函数</p>
<ul>
<li>参数1:   文件名称（字符串）</li>
<li>参数2：打开文件的模型（字符串）</li>
</ul>
<p><img src="https://gitee.com/Carlisle345748/cloudimg/raw/master/img/fopen%E6%A8%A1%E5%9E%8B.png" alt="fopen模型"></p>
<p>新的C11新增了带x字母的写模式，与以前的写模式相比具有更多特性。</p>
<ul>
<li>第一，如果以传统的一种写模式打开一个现有文件，fopen()会把该文件 的长度截为 0，这样就丢失了该文件的内容。但是使用带 x字母的写模式， 即使fopen()操作失败，原文件的内容也不会被删除。</li>
<li>第二，如果环境允许，x模式的独占特性使得其他程序或线程无法访问正在被打开的文件。</li>
</ul>
<h3 id="fclose"><a href="#fclose" class="headerlink" title="fclose()"></a>fclose()</h3><p>fclose()函数关闭指定的文件，必要时刷新缓冲区。对于较正式的程序，应该检查是否成功关闭文件。如果成功关闭，fclose()函数返回0，否则返回EOF。如果磁盘已满、移动硬盘被移除或出现I/O错误，都会导致调用fclose() 函数失败。</p>
<p>参数1: 待关闭的文件(字符串)</p>
<h3 id="指向标准文件的指针"><a href="#指向标准文件的指针" class="headerlink" title="指向标准文件的指针"></a>指向标准文件的指针</h3><p>stdio.h头文件把3个文件指针与3个标准文件相关联，C程序会自动打开 这3个标准文件。如表13.2所示：</p>
<table>
<thead>
<tr>
<th>标准文件</th>
<th>文件指针</th>
<th>通常使用的设备</th>
</tr>
</thead>
<tbody><tr>
<td>标准输入</td>
<td>stdin</td>
<td>键盘</td>
</tr>
<tr>
<td>标准输出</td>
<td>stdout</td>
<td>屏幕</td>
</tr>
<tr>
<td>标准错误</td>
<td>stderr</td>
<td>屏幕</td>
</tr>
</tbody></table>
<h2 id="标准IO的机理"><a href="#标准IO的机理" class="headerlink" title="标准IO的机理"></a>标准IO的机理</h2><ul>
<li><p><strong>第一步</strong>：调用fopen()打开文件。fopen()函数不仅打开一个文件，还创建了一个缓冲区（在读写模式下会创建两个缓冲区）以及一个包含文件和缓冲区数据的结构。另外，fopen()返回一个指向该结构的指针，以便其他函数知道如何找到该结构。假设把该指针赋给一个指针变量fp，我们说fopen()函数“打开一个流”。如果以文本模式打开该文件，就获得一个文本流；如果以二进 制模式打开该文件，就获得一个二进制流。</p>
<p>这个结构通常包含一个指定流中当前位置的文件位置指示器。除此之外，它还包含错误和文件结尾的指示器、一个指向缓冲区开始处的指针、一个文件标识符和一个计数（统计实际拷贝进缓冲区的字节数）。</p>
</li>
<li><p><strong>第二步</strong>：调用一个定义在 stdio.h中的输入函数，如fscanf()、getc()或 fgets()。一调用这些函数，文件中的数据块就被拷贝到缓冲区中。缓冲区的大小因实现而异，一般是512字节或是它的倍数，如4096或16384（随着计算机硬盘容量越来越大，缓冲区的大小也越来越大）。最初调用函数，除了填充缓冲区外，还要设置fp所指向的结构中的值。尤其要设置流中的当前位置和拷贝进缓冲区的字节数。通常，当前位置从字节0开始。</p>
<p>当输入函数发现已读完缓冲区中的所有字符时，会请求把下一个缓冲大小的数据块从文件拷贝到该缓冲区中。以这种方式，输入函数可以读取文件中的所有内容，直到文件结尾。函数在读取缓冲区中的最后一个字符后，把结尾指示器设置为真。于是，下一次被调用的输入函数将返回EOF。</p>
</li>
<li><p><strong>第三步</strong>：输出函数以类似的方式把数据写入缓冲区。当缓冲区被填满时，数据将被拷贝至文件中。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/13/%E5%AD%97%E7%AC%A6%E4%B8%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="崔梓坤">
      <meta itemprop="description" content="我的计算机学习经历和笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="崔梓坤的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/13/%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="post-title-link" itemprop="url">字符串</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-13 18:24:49 / 修改时间：18:25:23" itemprop="dateCreated datePublished" datetime="2020-06-13T18:24:49+08:00">2020-06-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="表示字符串和字符串I-O"><a href="#表示字符串和字符串I-O" class="headerlink" title="表示字符串和字符串I/O"></a>表示字符串和字符串I/O</h2><h3 id="初始化字符串"><a href="#初始化字符串" class="headerlink" title="初始化字符串"></a>初始化字符串</h3><ul>
<li><p><strong>字符串字面量(string literals)</strong></p>
<p>用双引号括起来的内容称为字符串字面量（string literal），也叫作字符串常量（string constant）。双引号中的字符加上编译器自动加入末尾的\0字符，组成字符串储存在内存中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">23</span>] = <span class="string">"I am a symbolic string"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果字符串字面量之间没有间隔，或者用空白字符分隔，C会将其视为串联起来的字符串字面量</span></span><br><span class="line"><span class="keyword">char</span> str_s[<span class="number">23</span>] = <span class="string">"I"</span> <span class="string">"am"</span> <span class="string">"a"</span> <span class="string">"symbolic"</span> <span class="string">"string"</span>;</span><br></pre></td></tr></table></figure>

<p>字符串常量属于静态存储类别（static storage class），这说明如果在函数中使用字符串常量，即使函数被调用多次，在整个程序的运行过程中该字符串只会被储存一次。</p>
</li>
<li><p><strong>字符串数字和初始化</strong></p>
<p>在使用{}初始化字符串数组中，要在最后加上空字符<code>/0</code>，否则声明的字符数组而不是字符串数组。在指定数组大小时，要确保数组的元素个数至少比字符串长度多1，所有未被使用的元素都被自动初始化为<code>\0</code>。与数组类型，也可以让编译器自己计算数组的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> greet[<span class="number">6</span>] = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> greet[<span class="number">6</span>] = &#123;<span class="string">'H'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>, <span class="string">'\0'</span>&#125;; <span class="comment">// 注意最后要加\0</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> greet[] = <span class="string">"Hello"</span>;  <span class="comment">// 让编译器计算数组大小，必须初始化才能使用[]</span></span><br><span class="line"><span class="keyword">const</span> chat pets[<span class="number">12</span>] = <span class="string">"nice cat."</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/Carlisle345748/cloudimg/raw/master/img/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E5%A4%A7%E5%B0%8F%E5%A4%A7%E4%BA%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E7%94%A8%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F.png" alt="字符串数组大小大于初始化用的字符串常量"></p>
</li>
<li><p><strong>字符串和指针</strong></p>
<p>字符串数组名、字符串字面量和其他数组名一样，是该字符串储存位置的地址。所以可以使用以下表达式，也可以使用指针表示法创建字符串：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与其他数组类型，字符串字面量也是指向该字符串储存位置的指针，pt1和ar1都是该字符串的地址</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * pt1 = <span class="string">"Something is pointting at me."</span>;   <span class="comment">// pt1是一个指向字符串字面量的指针</span></span><br><span class="line"><span class="keyword">char</span> ar1[] = <span class="string">"Something is pointting at me."</span>;   <span class="comment">// ar1是一个字符串数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与其他数组类似的指针操作</span></span><br><span class="line">char car[10] = 'Tata';</span><br><span class="line">car == &amp;car[<span class="number">0</span>];</span><br><span class="line">*car = <span class="string">'T'</span>;</span><br><span class="line">*(car + <span class="number">1</span>) == car[<span class="number">1</span>] == <span class="string">'a'</span>;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="字符串的数组形式和指针形式"><a href="#字符串的数组形式和指针形式" class="headerlink" title="字符串的数组形式和指针形式"></a>字符串的数组形式和指针形式</h3><h3 id="数组形式和指针形式的不同"><a href="#数组形式和指针形式的不同" class="headerlink" title="数组形式和指针形式的不同"></a>数组形式和指针形式的不同</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * pt1 = <span class="string">"Something is pointting at me."</span>;   <span class="comment">// pt1是一个指向字符串字面量的指针</span></span><br><span class="line"><span class="keyword">char</span> ar1[] = <span class="string">"Something is pointting at me."</span>;   <span class="comment">// ar1是一个字符串数组</span></span><br></pre></td></tr></table></figure>

<p>数组形式和指针形式有何不同？以上面的代码为例：</p>
<ul>
<li><p><strong>数组形式 (ar1[])</strong> 在计算机的内存中分配为一个内含29个元素的数组，每个元素被初始化为字符串字面量对应的字符。通常，字符串字面量都作为可执行文件的一部分储存在数据段中。当把程序载入内存时，也载入了程序中的字符串字面量。因此字符串字面量储存在静态内存中。程序在开始运行时才会为该数组分配内存，然后将字符串字面量中的字符拷贝到数组中。注意，此时字符串有两个副本。一个是在静态内存中的字符串字面量，另一个是储存在ar1数组中的字符串。</p>
<p>此后，编译器便把数组名ar1识别为该数组首元素地址（&amp;ar1[0]）的别名(alias)。这里关键要理解，在数组形式中，ar1是地址常量。不能更改ar1，如果改变了ar1，则意味着改变了数组的存储位置。可以进行类似 ar1+1这样的操作，标识数组的下一个元素。但是不允许进行++ar1这样的操作。</p>
</li>
<li><p><strong>指针形式(*pt1)</strong>也使得编译器在静态内存储存字符串字面量。一旦开始执行程序，它会为指针变量pt1留出一个储存位置，并把字符串的地址储存在pt1中。pt1指向该字符串的首字符， 但是它的值可以改变。因此，可以使用递增运算符。例如，++pt1将指向第 2 个字符 (o)。</p>
<p>字符串字面量被视为const数据。由于pt1指向这个const数据，所以应该把pt1声明为指向const数据的指针。这意味着不能用pt1改变它所指向的数 据，但是仍然可以改变pt1的值（即pt1指向的位置）。如果把一个字符串字面量拷贝给一个数组，就可以随意改变数据，除非把数组声明为const。</p>
</li>
</ul>
<p><strong>总之，初始化数组把静态存储区的字符串拷贝到数组中，而初始化指针只把字符串的地址拷贝给指针</strong>。下面的例子演示了上述内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG <span class="meta-string">"I am special"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ar[] = MSG;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * pt = MSG;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Address of \"I am special\" : %p\n"</span>, <span class="string">"I am special"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Address ar: %p\n"</span>, ar);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Address pt: %p\n"</span>, pt);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Address of MSG: %p\n"</span>, MSG);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Address of \"I am special\" : %p\n"</span>, <span class="string">"I am special"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Address of "I am special" : 0x1038e8f48</span></span><br><span class="line"><span class="comment">Address ar: 0x7ffeec3175fb</span></span><br><span class="line"><span class="comment">Address pt: 0x1038e8f48</span></span><br><span class="line"><span class="comment">Address of MSG: 0x1038e8f48</span></span><br><span class="line"><span class="comment">Address of "I am special" : 0x1038e8f48</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>该程序中，pt和MSG的地址相同，而ar的地址不同，说明pt指向字符串字面量，ar指向一个字符串数组，符合上述说明。</li>
<li>虽然字符串字面量<code>&quot;I&#39;m special&quot;</code>在程序的两个printf()函数中出现了两次，但是编译器只使用了一个存储位置，而且与MSG的地址相同。编译器可以把多次使用的相同字面量储存在一处或多处。另一个编译器可能在不同的位置储存3个”I’m special”。</li>
<li>第三，静态数据使用的内存与ar使用的动态内存不同。不仅值不同，特定编译器甚至使用不同的位数表示两种内存。</li>
</ul>
<h3 id="数组与指针的不同"><a href="#数组与指针的不同" class="headerlink" title="数组与指针的不同"></a>数组与指针的不同</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ar[] = <span class="string">"I am a string"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * pt = <span class="string">"I am a string"</span>;</span><br><span class="line"></span><br><span class="line">pt = ar; <span class="comment">// 允许，可以把数组的地址赋给指针变量</span></span><br><span class="line">ar = pt; <span class="comment">// 不允许，数组地址是常量</span></span><br></pre></td></tr></table></figure>

<p>这类似于<code>x = 3;</code>和<code>3 = x;</code>的情况。赋值运算符的左侧必须是变量（或概括地说是可修改的左值）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * <span class="keyword">word</span> = <span class="string">"frame"</span>;   <span class="comment">// 未使用const限定符</span></span><br><span class="line"><span class="keyword">word</span>[<span class="number">1</span>] = <span class="string">'k'</span>;           <span class="comment">// 不一定允许，可能触发内存访问错误</span></span><br></pre></td></tr></table></figure>

<p>未使用const限定符的指针初始化后，使用指针修改字符串的行为在C标准中是为定义的。这样的语句可能导致内存访问错误。原因前面提到过，编译器可能把所有完全相同的字符串字面量储存一个位置，而不是多处，使用指针修改字符串字面量可能导致其他地方使用相同的字符串字面量时出错，比如下面的例子 ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * p1 = <span class="string">"Klingon"</span>;</span><br><span class="line">    <span class="comment">// p1[0] = 'F';</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Klingon"</span>);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">": Beware the %s!\n"</span>, <span class="string">"Klingon"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Flingon: Beware the Flingons!</span></span><br></pre></td></tr></table></figure>

<p>一些编译器可以运行上述代码，而一些编译器会直接报错。因为编译器可以用相同的地址替换每个”Klingon”实例。如果编译器使用这种单次副本表示法，并允许p1[0]修改’F’，那将影响所有使用该字符串的代码。所以以上语句打印字符串字面量”Klingon”时实际上显示的 是”Flingon”。</p>
<p><strong>因此，建议在把指针初始化为字符串字面量时使用const限定符。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * pl = <span class="string">"Klingon"</span>;</span><br></pre></td></tr></table></figure>



<h2 id="字符串的数组"><a href="#字符串的数组" class="headerlink" title="字符串的数组"></a>字符串的数组</h2><p>C语言中可以创建包含字符串的数组，数组中的每个元素都是一个字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SLEN 40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIM 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mytalents[LIM] = &#123;</span><br><span class="line">        <span class="string">"Adding　numbers　swiftly"</span>, </span><br><span class="line">        <span class="string">"Multiplying　accurately"</span>,</span><br><span class="line">        <span class="string">"Stashing　data"</span>, <span class="string">"Following　instructions　to　the　letter"</span>, </span><br><span class="line">        <span class="string">"Understanding　the　C　language"</span> </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> yourtalents[LIM][SLEN] = &#123;</span><br><span class="line">        <span class="string">"Walking　in　a　straight　line"</span>,</span><br><span class="line">        <span class="string">"Sleeping"</span>,</span><br><span class="line">        <span class="string">"Watching　television"</span>,</span><br><span class="line">        <span class="string">"Mailing　letters"</span>,</span><br><span class="line">        <span class="string">"Reading　email"</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Let's compare talent."</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%-36s　 %-25s\n"</span>, <span class="string">"My　Talents"</span>, <span class="string">"Your　Talents"</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LIM; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%-36s　 %-25s\n"</span>, mytalents[i], yourtalents[i]);</span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mytalents</code>和<code>yourtalents</code>非常相似。两者都代表5个字符串。使用一个下标时都分别表示一个字符串，如<code>mytalents[0]</code>和 <code>yourtalents[0]</code>；使用两个下标时都分别表示一个字符，如<code>mytalents[1][2]</code>和<code>yourtalents[1][2]</code>。</p>
<p>但是，它们也有区别:</p>
<ul>
<li><code>mytalents</code>数组是一个<strong>内含5个指针的数组</strong>，在我们的系统中共占用40字节。<code>mytalents</code>中的指针指向初始化时所用的字符串字面量的位置，这些字符串字面量被储存在静态内存中</li>
<li><code>yourtalents</code>是一个<strong>内含5个数组的数组</strong>，每个数组内含40个char类型的值，共占用200字节。yourtalents 中的数组储存着字符串字面量的副本，所以每个字符串都被储存了两次。</li>
</ul>
<p>所以，虽然<code>mytalents[0]</code>和 <code>yourtalents[0]</code>都分别表示一个字符串，但mytalents和yourtalents的类型并不相同。此外，为字符串数组分配内存的使用率较低。yourtalents 中的每个元素的大小必须相同，而且必须是能储存最长字符串的大小。我们可以把yourtalents想象成矩形二维数组，每行的长度都是40字节； 把mytalents想象成不规则的数组，每行的长度可以不同。</p>
<img src="https://gitee.com/Carlisle345748/cloudimg/raw/master/img/字符串指针数组和字符串数组.png" alt="字符串指针数组和字符串数组" style="zoom:30%;" />

<h3 id="字符串数组与函数"><a href="#字符串数组与函数" class="headerlink" title="字符串数组与函数"></a>字符串数组与函数</h3><p>在函数的形式参数声明中，比如上面的例子中，包含字符串的数组<code>yourtalents</code>和包含指向字符串的指针的数组<code>mytalents</code>需要使用不同的形式参数类型：</p>
<ul>
<li><p>包含字符串的数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROW 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 40</span></span><br><span class="line"><span class="keyword">char</span> strarr[ROW][SIZE];  <span class="comment">// 包含10个大小为40的字符串数组的数组</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">myfunction</span><span class="params">(<span class="keyword">char</span> (*str)[SIZE])</span></span>;  <span class="comment">// 形式参数是pointer-to-array of char</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>包含指向字符串的指针的数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROW 10</span></span><br><span class="line"><span class="keyword">char</span> * ptstr[ROW];  <span class="comment">// 包含十个指向字符串的指针的数组</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">myfunction</span><span class="params">(<span class="keyword">char</span> * str[])</span></span>;  <span class="comment">// 形式参数是pointer-to-pointer-to-char</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">myfunction</span><span class="params">(<span class="keyword">char</span> **str)</span></span>;  <span class="comment">// 与上式等效</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="EOF问题"><a href="#EOF问题" class="headerlink" title="EOF问题"></a>EOF问题</h2><p>在linux或Mac系统中，键盘输入<code>ctrl + D</code>可以模拟EOF。但是后续若再想使用scanf()等函数读取stdin的里的数据时，最后的EOF一直无法被消除，无法通过常用的<code>while(ch=getchar()!= &#39;\n&#39; &amp;&amp; ch != EOF);</code>来清除缓冲区中的EOF，最后只能使用<code>setbuf(stdin, NULL)</code>来重置缓冲区。这个问题日后需要再研究研究。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROW 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 40</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> input[ROW][SIZE];</span><br><span class="line">    <span class="keyword">char</span> * ptstr[ROW];</span><br><span class="line">    <span class="keyword">int</span> ct = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> choice = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Input up to %d lines (EOF) to stop:\n"</span>, ROW);</span><br><span class="line">    <span class="keyword">while</span>(ct &lt; ROW &amp;&amp; fgets(input[ct], SIZE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ptstr[ct] = input[ct];</span><br><span class="line">        ct++;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="keyword">while</span>(ch=getchar()!= <span class="string">'\n'</span> &amp;&amp; ch != EOF);     <span class="comment">// 清空缓冲区失败，无法清除EOF</span></span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);                         <span class="comment">// setbuf重置缓冲区成功</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;choice);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, choice);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="strncpy和strncat"><a href="#strncpy和strncat" class="headerlink" title="strncpy和strncat"></a>strncpy和strncat</h2><p>strncpy 把一个字符串拷贝到另一个字符串数组中并限定拷贝字符的数量。</p>
<p>注意：如果源字符串小于最大拷贝字符数量n，则拷贝整个字符串，包括空字符。但是，strncpy()拷贝字符串的长度不会超过n，如果拷贝到第n个字符时还未拷贝完整个源字符串，就不会拷贝空字符 (编译器可能会报错)。所以，拷贝的副本中不一定有空字符。鉴于此，要把 n 设置为比目标数组大小少1。</p>
<ul>
<li>参数1: 目标字符串数组的地址(指针)</li>
<li>参数2: 待拷贝字符串(源字符串)的地址(指针)或字符串字面量</li>
<li>参数3: 最大拷贝字符数量</li>
</ul>
<p>strcat()（用于拼接字符串）函数接受两个字符串和最大添加字符数作为参数。该函数把第 2个字符串的副本附加在第1个字符串末尾，并把拼接后形成的新字符串作为第1个字符串，第2个字符串不变。</p>
<p>注意：如果源字符串长度小于最大添加字符数量n，则添加整个字符串，并在末尾加上空字符。但是，如果源字符串长度大于n，拷贝到第n个字符时还未拷贝完整个源字符串，就不会拷贝空字符 (编译器可能会报错)。所以，第1个字符串末尾不一定有空字符。鉴于此，要把 n 设置为比目标数组大小少1。</p>
<ul>
<li>参数1: 目标字符串数组的地址(指针)</li>
<li>参数2: 待添加字符串(源字符串)的地址(指针)或字符串字面量</li>
<li>参数3: 最大拷贝字符数量</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/13/%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="崔梓坤">
      <meta itemprop="description" content="我的计算机学习经历和笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="崔梓坤的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/13/%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">数组和指针</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-13 18:23:44 / 修改时间：18:45:22" itemprop="dateCreated datePublished" datetime="2020-06-13T18:23:44+08:00">2020-06-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h3><ul>
<li><strong>正常初始化</strong>：用以逗号分隔的值列表（用花括号括起来）来初始化数组，各值之间用逗号分隔。在逗号和值之间可以使用空格。根据上面的初始化，把 1 赋给数组的首元素（powers[0]），以此类推（不支持ANSI的编译器会把这种形式的初始化识别为语法错误，在数组声明前加上关键字static可解决此问题。</li>
<li><strong>未初始化的数组</strong>：编译器使用的值是内存相应位置上的现有值。</li>
<li><strong>初始化列表中的值少于数组元素个数</strong>：编译器会把剩余的元素都初始化为0</li>
<li><strong>初始化列表中的值多于数组元素个数</strong>：编译器报错</li>
<li><strong>不指定数组大小</strong>：编译器会根据初始化列表中的项数来确定数组的大小</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> with_data[SIZE] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 逗号分隔的值列表初始化数组</span></span><br><span class="line">    <span class="keyword">int</span> no_data[SIZE];                     <span class="comment">// 未初始化</span></span><br><span class="line">    <span class="keyword">int</span> less[SIZE] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;            <span class="comment">// 值列表项数小于数组大小</span></span><br><span class="line">    <span class="keyword">int</span> more[SIZE] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;   <span class="comment">// 值列表项数大于数组大小</span></span><br><span class="line">    <span class="keyword">int</span> no_size[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;       <span class="comment">// 让编译器自动匹配数组大小</span></span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*打印以上数组*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">i with_date[i]</span></span><br><span class="line"><span class="comment">0            1</span></span><br><span class="line"><span class="comment">1            2</span></span><br><span class="line"><span class="comment">2            3</span></span><br><span class="line"><span class="comment">3            4</span></span><br><span class="line"><span class="comment">4            5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">i   no_date[i]</span></span><br><span class="line"><span class="comment">0            0</span></span><br><span class="line"><span class="comment">1       421546</span></span><br><span class="line"><span class="comment">2      4551233</span></span><br><span class="line"><span class="comment">3        45652</span></span><br><span class="line"><span class="comment">4       714564</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">i less_date[i]</span></span><br><span class="line"><span class="comment">0            1</span></span><br><span class="line"><span class="comment">1            2</span></span><br><span class="line"><span class="comment">2            3</span></span><br><span class="line"><span class="comment">3            0</span></span><br><span class="line"><span class="comment">4            0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">i more_data[i]</span></span><br><span class="line"><span class="comment">编译器报错</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">i   no_size[i]</span></span><br><span class="line"><span class="comment">0            1</span></span><br><span class="line"><span class="comment">1            2</span></span><br><span class="line"><span class="comment">2            3</span></span><br><span class="line"><span class="comment">3            4</span></span><br><span class="line"><span class="comment">4            5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="指定初始化器-Desinated-Initializers"><a href="#指定初始化器-Desinated-Initializers" class="headerlink" title="指定初始化器(Desinated Initializers)"></a>指定初始化器(Desinated Initializers)</h4><p>C99 增加了一个新特性：指定初始化器（designated initializer）。<strong>利用该特性可以初始化指定的数组元素。例如，只初始化数组中的最后一个元素,其他为初始化的元素设为0，比如 <code>int arr[6] = {[5] = 212};</code></strong>。对于传统的C初始化语法，必须初始化最后一个元素之前的所有元素。</p>
<h5 id="指定初始化器的两个重要特性："><a href="#指定初始化器的两个重要特性：" class="headerlink" title="指定初始化器的两个重要特性："></a>指定初始化器的两个重要特性：</h5><ul>
<li>如果指定初始化器后面有更多的值，如该例中的初始化列表中的片段：<code>[4] = 31,30,31</code>，那么后面的值将被用于初始化指定元素后面的元素。也就是说，在days[4]被初始化为31后，days[5]和days[6]将分别被初始化为30和31。</li>
<li>如果再次初始化指定的元素，那么最后的初始化将会取代之前的初始化。例如下面例子中，初始化列表开始时把days[1]初始化为28，但是days[1]又被后面的指定初始化<code>[1] = 29</code>初始化为29。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MONTH 12</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> days[MONTH] = &#123;<span class="number">31</span>, <span class="number">28</span>, [<span class="number">4</span>] = <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, [<span class="number">1</span>] = <span class="number">29</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MONTH; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%2d %d\n"</span>, i, days[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment"> 0 31</span></span><br><span class="line"><span class="comment"> 1 29  （先被初始化为28，然后被[1] = 29	初始化为29）</span></span><br><span class="line"><span class="comment"> 2 0</span></span><br><span class="line"><span class="comment"> 3 0</span></span><br><span class="line"><span class="comment"> 4 31</span></span><br><span class="line"><span class="comment"> 5 30  （根据 [4] = 31, 30,31，days[4	]被初始化为31后，days[5]和days[6]被初始化为30和31）</span></span><br><span class="line"><span class="comment"> 6 31</span></span><br><span class="line"><span class="comment"> 7 0</span></span><br><span class="line"><span class="comment"> 8 0</span></span><br><span class="line"><span class="comment"> 9 0</span></span><br><span class="line"><span class="comment">10 0</span></span><br><span class="line"><span class="comment">11 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>如果未指定元素大小会怎样？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> stuff[] = &#123;<span class="number">1</span>, [<span class="number">6</span>] = <span class="number">23</span>&#125;;　</span><br><span class="line"><span class="keyword">int</span> staff[] = &#123;<span class="number">1</span>, [<span class="number">6</span>] = <span class="number">4</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>编译器会把数组的大小设置为足够装得下初始化的值。所以，stuff数组 有7个元素，编号为0～6；而staff数组的元素比stuff数组多两个（即有9个元素）。</p>
<blockquote>
<p><strong>Const 和数组大小</strong></p>
<p>是否可以在声明数组时使用const变量？ </p>
<p>const int SZ = 80;</p>
<p>double ar[SIZE];</p>
<p>C90标准不允许（也可能允许）。数组的大小必须是给定的整型常量表达式，可以是整型常量组合，如20、sizeof表达式或其他不是const的内容。 由于C实现可以扩大整型常量表达式的范围，所以可能会允许使用const，但是这种代码可能无法移植。</p>
<p>C99/C11 标准允许在声明变长数组(VLA)时使用 const 变量。所以该数组的定义必须是声明在块(block)中的自动存储类别数组(automatic storage class array)。</p>
</blockquote>
<h3 id="数组赋值"><a href="#数组赋值" class="headerlink" title="数组赋值"></a>数组赋值</h3><p>声明数组后，可以借助数组下标（或索引）给数组元素赋值。在C语言中，数组的索引从<code>0</code>开始，直到<code>数组长度 -1</code>。<strong>注意：C 不允许把数组作为 一个单元赋给另一个数组，除初始化以外也不允许使用花括号列表的形式赋值</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> oxen[SIZE] = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> yask[SIZE];</span><br><span class="line"></span><br><span class="line">yask[<span class="number">0</span>] = oxen[<span class="number">0</span>];   <span class="comment">// 允许</span></span><br><span class="line">yask = oxen;         <span class="comment">// 不允许</span></span><br><span class="line">yask = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>&#125;     <span class="comment">// 不允许</span></span><br></pre></td></tr></table></figure>



<h3 id="数组边界"><a href="#数组边界" class="headerlink" title="数组边界"></a>数组边界</h3><p>注意，C语言不会检查编号是否正确，如果编号超出数组的范围，C语言不会报错，C语言会按指令直接修改对应的内存位置，导致不可预料的错误。</p>
<p>C 语言为何会允许这种麻烦事发生？这要归功于 C 信任程序员的原则。不检查边界，C 程序可以运行更快。编译器没必要捕获所有的下标错误，因为在程序运行之前，数组的下标值可能尚未确定。因此，为安全起见，编译器必须在运行时添加额外代码检查数组的每个下标值，这会降低程序的运行速度。C 相信程序员能编写正确的代码，这样的程序运行速度更快。但并不是所有的程序员都能做到这一点，所以就出现了下标越界的问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 4</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value1 = <span class="number">44</span>;</span><br><span class="line">    <span class="keyword">int</span> arr[SIZE];</span><br><span class="line">    <span class="keyword">int</span> value2 = <span class="number">88</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Value1 = %d, Value2 = %d\n"</span>, value1, value2);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">-1</span>; i &lt;= SIZE; i ++)</span><br><span class="line">        arr[i] = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">-1</span>; i &lt;= <span class="number">7</span>; i ++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%2d %d\n"</span>, i, arr[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">-1 -1 (修改了arr[-1]对应的内存位置的值)</span></span><br><span class="line"><span class="comment"> 0 1</span></span><br><span class="line"><span class="comment"> 1 3</span></span><br><span class="line"><span class="comment"> 2 5</span></span><br><span class="line"><span class="comment"> 3 7</span></span><br><span class="line"><span class="comment"> 4 9  (修改了arr[4]对应的内存位置的值)</span></span><br><span class="line"><span class="comment"> 5 32766</span></span><br><span class="line"><span class="comment"> 6 383647857</span></span><br><span class="line"><span class="comment"> 7 -326505489</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="指定数组的大小"><a href="#指定数组的大小" class="headerlink" title="指定数组的大小"></a>指定数组的大小</h3><p>在C99标准之前，声明数组时只能在方括号中使用整型常量表达式。所谓整型常量表达式，是由整型常量构成的表达式。<strong>sizeof表达式被视为整型 常量，但是（与C++不同）const值不是</strong>。另外，表达式的值必须大于0：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">5</span>, m = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> a1[<span class="number">5</span>];               <span class="comment">// yes</span></span><br><span class="line"><span class="keyword">float</span> a1[<span class="number">5</span> * <span class="number">2</span> + <span class="number">1</span>];       <span class="comment">// yes</span></span><br><span class="line"><span class="keyword">float</span> a3[<span class="keyword">sizeof</span>(<span class="keyword">int</span>) + <span class="number">1</span>]; <span class="comment">// yes</span></span><br><span class="line"><span class="keyword">float</span> a4[<span class="number">0</span>];               <span class="comment">// no</span></span><br><span class="line"><span class="keyword">float</span> a5[(<span class="keyword">int</span>)<span class="number">2.5</span>];        <span class="comment">// yes</span></span><br><span class="line"><span class="keyword">float</span> a6[n];               <span class="comment">// not allowed before C99</span></span><br><span class="line"><span class="keyword">float</span> a7[m];               <span class="comment">// not allowed before C99</span></span><br></pre></td></tr></table></figure>

<p>上面的注释表明，以前支持C90标准的编译器不允许后两种声明方式。 而C99标准允许这样声明，这创建了一种新型数组，称为变长数组 （variable-length array）或简称 VLA（C11 放弃了这一创新的举措，把VLA 设定为可选，而不是语言必备的特性）。</p>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> rain[<span class="number">5</span>][<span class="number">12</span>]</span><br></pre></td></tr></table></figure>

<p>主数组（master array）有5个元素 ，每个元素是内含12个元素的数组。rain的首元素<code>rain[0]</code>是一个内含12个float类型值的数组。所以，<code>rain[1]</code>、<code>rain[2]</code>等也是如此。 <code>rain[0]</code>是一个数组，那么它的首元素就是 <code>rain[0][0]</code>，第 2 个元素是<code>rain[0][1]</code>，以此类推。</p>
<p><strong>计算机的储存方式：</strong>在计算机内部， 多维数组是按顺序储存的，从第1个内含12个元素的数组开始，然后是第2 个内含12个元素的数组，以此类推。</p>
<h4 id="初始化多维数组"><a href="#初始化多维数组" class="headerlink" title="初始化多维数组"></a>初始化多维数组</h4><p><strong>方法一</strong>：这个使用了5个数值列表，每个数值列表都用花括号括起来。第1 个列表的数据用于初始化数组的第1行，第2个列表的数据用于初始化数组的第2行</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> rain[<span class="number">5</span>][<span class="number">12</span>]　= </span><br><span class="line">&#123; </span><br><span class="line">&#123;<span class="number">4.3</span>,<span class="number">4.3</span>,<span class="number">4.3</span>,<span class="number">3.0</span>,<span class="number">2.0</span>,<span class="number">1.2</span>,<span class="number">0.2</span>,<span class="number">0.2</span>,<span class="number">0.4</span>,<span class="number">2.4</span>,<span class="number">3.5</span>,<span class="number">6.6</span>&#125;,</span><br><span class="line">&#123;<span class="number">8.5</span>,<span class="number">8.2</span>,<span class="number">1.2</span>,<span class="number">1.6</span>,<span class="number">2.4</span>,<span class="number">0.0</span>,<span class="number">5.2</span>,<span class="number">0.9</span>,<span class="number">0.3</span>,<span class="number">0.9</span>,<span class="number">1.4</span>,<span class="number">7.3</span>&#125;,</span><br><span class="line">&#123;<span class="number">9.1</span>,<span class="number">8.5</span>,<span class="number">6.7</span>,<span class="number">4.3</span>,<span class="number">2.1</span>,<span class="number">0.8</span>,<span class="number">0.2</span>,<span class="number">0.2</span>,<span class="number">1.1</span>,<span class="number">2.3</span>,<span class="number">6.1</span>,<span class="number">8.4</span>&#125;,</span><br><span class="line">&#123;<span class="number">7.2</span>,<span class="number">9.9</span>,<span class="number">8.4</span>,<span class="number">3.3</span>,<span class="number">1.2</span>,<span class="number">0.8</span>,<span class="number">0.4</span>,<span class="number">0.0</span>,<span class="number">0.6</span>,<span class="number">1.7</span>,<span class="number">4.3</span>,<span class="number">6.2</span>&#125;,</span><br><span class="line">&#123;<span class="number">7.6</span>,<span class="number">5.6</span>,<span class="number">3.8</span>,<span class="number">2.8</span>,<span class="number">3.8</span>,<span class="number">0.2</span>,<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">1.3</span>,<span class="number">2.6</span>,<span class="number">5.2</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>方法二</strong>：初始化时也可省略内部的花括号，只保留最外面的一对花括号。只要保证初始化的数值个数正确，初始化的效果与上面相同。但是如果初始化的数值不够，则按照先后顺序逐行初始化，直到用完所有的值。后面没有值初始化的元素被统一初始化为0。</p>
<p><img src="https://gitee.com/Carlisle345748/cloudimg/raw/master/img/%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95.png" alt="初始化多维数组的两种方法"></p>
<h2 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h2><p>在C语言中，<strong>数组名实际上是该数组首元素的地址</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr = &amp;arr[<span class="number">0</span>] <span class="comment">// 数组名是数组首元素的地址</span></span><br></pre></td></tr></table></figure>



<h3 id="数组中的指针运算"><a href="#数组中的指针运算" class="headerlink" title="数组中的指针运算"></a>数组中的指针运算</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 4</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    short dates[SIZE];</span><br><span class="line">    short * pti;</span><br><span class="line">    short index;</span><br><span class="line">    <span class="keyword">double</span> bills[SIZE];</span><br><span class="line">    <span class="keyword">double</span> * ptf;</span><br><span class="line"></span><br><span class="line">    pti = dates;  <span class="comment">// 数组名为数组首元素的地址</span></span><br><span class="line">    ptf = bills;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%23s %15s\n"</span>, <span class="string">"short"</span>, <span class="string">"double"</span>);</span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; SIZE; index++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pointers + %d: %10p %10p\n"</span>, index, pti + index, ptf + index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">                  short          double</span></span><br><span class="line"><span class="comment">pointers + 0: 0x7ffeee394600 0x7ffeee3945e0</span></span><br><span class="line"><span class="comment">pointers + 1: 0x7ffeee394602 0x7ffeee3945e8</span></span><br><span class="line"><span class="comment">pointers + 2: 0x7ffeee394604 0x7ffeee3945f0</span></span><br><span class="line"><span class="comment">pointers + 3: 0x7ffeee394606 0x7ffeee3945f8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>我们的操作系统中，地址按字节编址，short类型占用2字节，double类型占用8字节。<strong>在C中，“指针加1”指的是增加1个存储单元。对数组而言，这意味着“指针加1”后的地址是下一个元素的地址，而不是下一个字节的地址</strong>（见下图）。这就是为什么必须声明指针所指向对象类型的原因之一：只知道地址还不够，因为计算机要知道储存对象需要多少字节（即使指针指向的是scalar variable，也要知道变量的类型，否则<code>*pt</code> 就无法正确地取回地址上的值）。</p>
<img src="https://gitee.com/Carlisle345748/cloudimg/raw/master/img/数组中的指针运算.png" alt="数组中的指针运算" style="zoom:45%;" />



<h3 id="数组表示法和指针表示法"><a href="#数组表示法和指针表示法" class="headerlink" title="数组表示法和指针表示法"></a>数组表示法和指针表示法</h3><p>C语言中可以用<strong>数组表示法</strong>和<strong>指针表示法</strong>来表示数组中的对象<code>ar[n] = *(ar + n)</code>、<code>&amp;ar[n] = ar + n</code>。可以认为<code>*(ar + n)</code>的意思是“到内存的ar位置，然后移动n个储存单元，检索储存在那里的值”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dates + <span class="number">2</span> = &amp;date[<span class="number">2</span>]    <span class="comment">// 相同的地址</span></span><br><span class="line">dates[<span class="number">2</span>] = *(date + <span class="number">2</span>)  <span class="comment">// 相同的值</span></span><br></pre></td></tr></table></figure>

<p>在使用指针表示法的时候，要注意<code>*(date+2)</code>和<code>*date + 2</code>表示的意思是不一样的，<code>*</code>运算符的优先级比<code>+</code>高，所以<code>*date + 2</code>表示取得data数组第1个值并加2，而不去的date数组的第三个值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*(date + <span class="number">2</span>);  <span class="comment">// date数组的第三个值</span></span><br><span class="line">*date + <span class="number">2</span>;    <span class="comment">// date数组的第一个值加2</span></span><br></pre></td></tr></table></figure>



<h2 id="函数、指针和数组"><a href="#函数、指针和数组" class="headerlink" title="函数、指针和数组"></a>函数、指针和数组</h2><h3 id="将数组信息传递给函数"><a href="#将数组信息传递给函数" class="headerlink" title="将数组信息传递给函数"></a>将数组信息传递给函数</h3><p>假设要编写一个处理数组的函数，该函数返回数组中所有元素之和，待处理的是名为marbles的int类型数组。</p>
<p>首先定义函数原型：注意，数组名是该数组首元素的地址，所以应该把它赋给一个指针类型的参数，即该形参是一个指向int的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> * ar)</span></span>; <span class="comment">// 函数原型</span></span><br></pre></td></tr></table></figure>

<p>sum()从该参数获得了什么信息？它获得了该数组首元素的地址，知道要在该位置上找出一个int。注意，该参数并未包含数组元素个数的信息。 我们有两种方法让函数获得这一信息：</p>
<ul>
<li><p><strong>传递数组的大小：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第1个形参告诉函数该数组的地址和数据类型，第2个形参告诉函数该数组中元素的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> * ar, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    total += ar[i];        <span class="comment">// ar[i]等于*(ar + 1)</span></span><br><span class="line">  <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>传递数组的开始和结尾指针：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> * start, <span class="keyword">int</span> * <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (start &lt; <span class="built_in">end</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    total += *start;</span><br><span class="line">    start++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以把循环体压缩成一行代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">total += *start++;    <span class="comment">//先指向位置上的值，将值加到total上，然后递增指针</span></span><br></pre></td></tr></table></figure>

<p>一元运算符<code>*</code>和<code>++</code>的优先级相同，但结合律是从右往左，所以<code>start++</code>先求值，然后才是<code>*start</code>。也就是说，是start被递增，而不是*start被递增。</p>
<p><strong>注意，如果写成<code>*++start</code>，则是先递增指针，再使用指针指向位置上的值;如果写成<code>(*start)++</code>，则先指向位置上的值，然后递增改值，将递增后的值加到total上。下面的程序演示了这些优先级情况</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> date[<span class="number">2</span>] = &#123;<span class="number">100</span>, <span class="number">200</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> moredata[<span class="number">2</span>] = &#123;<span class="number">300</span>, <span class="number">400</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> * p1, * p2, * p3;</span><br><span class="line"></span><br><span class="line">    p1 = p2 = date;</span><br><span class="line">    p3 = moredata;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  *p1 = %d,    *p2 = %d,     *p3 = %d\n"</span>, *p1, *p2, *p3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"*p1++ = %d,  *++p2 = %d, (*p3)++ = %d\n"</span>, *p1++, *++p2, (*p3)++);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  *p1 = %d,    *p2 = %d,     *p3 = %d\n"</span>, *p1, *p2, *p3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  *p1 = 100,    *p2 = 100,     *p3 = 300</span></span><br><span class="line"><span class="comment">*p1++ = 100,  *++p2 = 200, (*p3)++ = 300</span></span><br><span class="line"><span class="comment">  *p1 = 200,    *p2 = 200,     *p3 = 301</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>所以，为了使提高程序可读性，避免出错，通常将<code>*start++</code>    写成<code>*(start++)</code>。</p>
</li>
</ul>
<blockquote>
<p><strong>注意 声明数组形参</strong></p>
<p>在函数原型或函数定义头中，可以用int ar[]代替int * ar：</p>
<p>int sum(int ar[], int n);</p>
<p>int sum(int [], int);</p>
<p>int <em>ar形式和int ar[]形式都表示ar是一个指向int的指针。但是，*</em>int ar[]只能用于声明形式参数**。第2种形式(int ar[]) 提醒读者指针ar指向的不仅仅 一个int类型值，还是一个int类型数组的元素。因为数组名是该数组首元素的地址，作为实际参数的数组名要求形式参数是一个与之匹配的指针。只有在这种情况下，C才会把int ar[]和int * ar解释成一样。</p>
</blockquote>
<h2 id="指针操作"><a href="#指针操作" class="headerlink" title="指针操作"></a>指针操作</h2><ul>
<li><strong>赋值</strong>：可以把地址赋给指针。例如，用数组名、带地址运算符(&amp;)的变量名、另一个指针进行赋值;</li>
<li><strong>解引用(dereferencing)</strong>：<code>*</code>运算符给出指针指向地址上储存的值;</li>
<li><strong>取址</strong>：和所有变量一样，指针变量也有自己的地址和值。对指针而言， &amp;运算符给出指针本身的地址。</li>
<li><strong>指针与整数相加</strong>：可以使用+运算符把指针与整数相加，或整数与指针相加。无论哪种情况，整数都会和指针所指向类型的大小（以字节为单位） 相乘，然后把结果与初始地址相加。因此ptr1 + 4与&amp;part1[4]等价；</li>
<li><strong>递增指针</strong>：递增指向数组元素的指针可以让该指针移动至数组的下一个元素，与指针与整数1相加等效；</li>
<li><strong>指针与整数相减</strong>：可以使用-运算符从一个指针中减去一个整数。<strong>指针必须是第1个运算对象，整数是第 2 个运算对象</strong>。该整数将乘以指针指向类型的大小（以字节为单位），然后用初始地址减去乘积。</li>
<li>递减指针：当然，除了递增指针还可以递减指针，前缀或后缀的递增和递减运算 符都可以使用；</li>
<li><strong>指针求差</strong>：可以计算两个指针的差值。通常，求差的两个指针分别指向同一个数组的不同元素，通过计算求出两元素之间的距离。差值的单位与数组类型的单位相同。比如<code>&amp;arr[3] - &amp;arr[1] = 2</code>；</li>
<li><strong>比较</strong>：使用关系运算符可以比较两个指针的值，前提是两个指针都指向相同类型的对象。</li>
</ul>
<h3 id="array、pointer和-、–"><a href="#array、pointer和-、–" class="headerlink" title="array、pointer和++、–"></a>array、pointer和++、–</h3><p>array和pointer的值都是数组的第一个元素的地址，但是<strong>pointer可以使用++和–运算符而array不可以</strong>。</p>
<p>在声明数组的时候，虽然编译器把array识别为数组首元素的地址(&amp;array[0])的别名(alias)，但是<strong>array是地址常量(const)</strong>，不能更改array。如果更改了array1，则意味改变了数组的地址。但是可以进行类型ar+1这样的操作，这个表达式的值是数组下一个元素的地址。递增运算符只能用于变量名，不能用于常量，所以不能使用++array。</p>
<p>在声明指针的时候，指针指向数组首元素的储存位置。但是指针是变量，其值可以改变，所以可以使用++pointer表示数组下一个元素的地址。</p>
<h2 id="保护数组中的数据"><a href="#保护数组中的数据" class="headerlink" title="保护数组中的数据"></a>保护数组中的数据</h2><h3 id="在函数中保护数组数据"><a href="#在函数中保护数组数据" class="headerlink" title="在函数中保护数组数据"></a>在函数中保护数组数据</h3><p>编写一个处理基本类型（如，int）的函数时，要选择是传递int类型的值还是传递指向int的指针。通常都是直接传递数值，只有程序需要在函数中改变该数值时，才会传递指针。对于数组别无选择，必须传递指针。传递指针会导致一些问题：编程错误可能会破坏原始数据。ANSI C提供了一种预防手段。如果函数的意图不是修改数组中的数据内容，那么在函数原型和函数定义中声明形式参数时应使用关键字const。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> * ar, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *ar, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    total += arr[i];</span><br><span class="line">  <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>const</code>告诉编译器，该函数不能修改ar指向的数组中的内容。如果在函数中不小心使用类似ar[i]++的表达式，编译器会捕获这个错误，并生成一条错误信息。这里一定要理解，这样使用const并不是要求原数组是常量，而是该函 数在处理数组时将其视为常量，不可更改。</p>
<h3 id="const的其他作用"><a href="#const的其他作用" class="headerlink" title="const的其他作用"></a>const的其他作用</h3><ul>
<li><p>声明只读数组，如果程序尝试改变数组元素的值，编译器将生成一个错误；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> days[<span class="number">12</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line">days[<span class="number">10</span>] = <span class="number">11</span>;  <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>声明<strong>不可用于改变指向值的指针</strong>：无论是使用指针表示法还是数组表示法，都不允许使用pd修改它所指向 数据的值。但是要注意，因为rates并未被声明为const，所以仍然可以通过 rates修改元素的值；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> rates[<span class="number">5</span>] = &#123;<span class="number">88.99</span>, <span class="number">100.12</span>, <span class="number">59.34</span>, <span class="number">183.22</span>, <span class="number">343.23</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> * pd = rate;</span><br><span class="line">*pd = <span class="number">100.1</span>;      <span class="comment">// 编译错误</span></span><br><span class="line">pd[<span class="number">2</span>] = <span class="number">222.2</span>；   <span class="comment">// 编译错误</span></span><br><span class="line">rate2[<span class="number">2</span>] = <span class="number">99.99</span>; <span class="comment">// 允许，因为rates没有被const限定</span></span><br></pre></td></tr></table></figure>

<p>关于指针赋值和const需要注意一些规则。首先，把const数据或非const 数据的地址赋值给const的指针是允许的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> rates[<span class="number">5</span>] = &#123;<span class="number">88.99</span>, <span class="number">100.12</span>, <span class="number">59.34</span>, <span class="number">183.22</span>, <span class="number">343.23</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> locked[<span class="number">5</span>] = &#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> * pc = rates;</span><br><span class="line">pc = rates;   <span class="comment">// 允许 </span></span><br><span class="line">pc = locked; <span class="comment">// 允许</span></span><br></pre></td></tr></table></figure>

<p>但是，只能把非const数据的地址赋给普通指针(非const)。这个规则非常合理。否则，通过指针就能改变const数组中的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> rates[<span class="number">5</span>] = &#123;<span class="number">88.99</span>, <span class="number">100.12</span>, <span class="number">59.34</span>, <span class="number">183.22</span>, <span class="number">343.23</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> locked[<span class="number">5</span>] = &#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>&#125;;</span><br><span class="line"><span class="keyword">double</span> * pnc = rates;</span><br><span class="line">pnc = rates;   <span class="comment">// 允许 </span></span><br><span class="line">pnc = locked; <span class="comment">// 不允许</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>声明并初始化一个<strong>不能指向别处的指针(但是可以修改指向的值)</strong>，与声明“不可用于改变值的指针”的差别在于const的位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> rates[<span class="number">5</span>] = &#123;<span class="number">88.99</span>, <span class="number">100.12</span>, <span class="number">59.34</span>, <span class="number">183.22</span>, <span class="number">343.23</span>&#125;;</span><br><span class="line"><span class="keyword">double</span> <span class="keyword">const</span> * pc = rates;</span><br><span class="line">pc = &amp;rates[<span class="number">2</span>]; <span class="comment">// 不允许</span></span><br><span class="line">*pc = <span class="number">92.99</span>;    <span class="comment">// 允许</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>声明既不能修改地址也不能修改地址上的指的指针（使用两次const）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> rates[<span class="number">5</span>] = &#123;<span class="number">88.99</span>, <span class="number">100.12</span>, <span class="number">59.34</span>, <span class="number">183.22</span>, <span class="number">343.23</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> <span class="keyword">const</span> * pc = rates;</span><br><span class="line">pc = &amp;rates[<span class="number">2</span>]; <span class="comment">// 不允许</span></span><br><span class="line">*pc = <span class="number">92.99</span>;    <span class="comment">// 不允许</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="指针与多维数组"><a href="#指针与多维数组" class="headerlink" title="指针与多维数组"></a>指针与多维数组</h2><p>假设有下面的声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> zippo[<span class="number">4</span>][<span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li><p>因为<code>zippo</code>是数组首元素的地址，所以<code>zippo</code>的值和<code>&amp;zippo[0]</code>的值相同。 而<code>zippo[0]</code>本身是一个内含两个整数的数组，所以<code>zippo[0]</code>的值和它首元素 （一个整数）的地址（即<code>&amp;zippo[0][0]</code>的值）相同。简而言之，<code>zippo[0]</code>是一 个占用一个int大小对象的地址，而<code>zippo</code>是一个占用两个int大小对象的地址。<strong>由于这个整数和内含两个整数的数组都开始于同一个地址，所以zippo 和zippo[0]的值相同。</strong></p>
<p><code>zippo = &amp;zippo[0]</code></p>
<p><code>zippo[0] = &amp;zippo[0][0]</code></p>
</li>
<li><p>给指针或地址加1，其值会增加对应类型大小的数值。在这方面，zippo 和zippo[0]不同，因为zippo指向的对象占用了两个int大小，而zippo[0]指向的对象只占用一个int大小。</p>
</li>
<li><p>因为<code>zippo[0]</code>是该数组首元素<code>zippo[0][0]</code>的地址，所以<code>*(zippo[0])</code>表示储存在<code>zippo[0][0]</code>上的值（int类型值）。与此类似，<code>*zippo</code>代表该数组首元素<code>zippo[0]</code>的值，但是 <code>zippo[0]</code>本身是一个int类型值的地址。该值的地址是<code>&amp;zippo[0][0]</code>，所以 <code>*zippo</code>就是<code>&amp;zippo[0][0]</code>。对两个表达式应用解引用运算符表明，<code>**zippo = *&amp;zippo[0][0] = zippo[0][0]</code>，即一个int类型的值。简而言之，<code>zippo</code>是地址的地址，必须解引用两次才能获得原始值。</p>
<p><code>*zippo = zippo[0] = &amp;zippo[0][0]</code></p>
<p><code>**zippo= *zippo[0] = zippo[0][0]</code></p>
</li>
<li><p><code>zippo</code>是一个二位数组，所以需要对数组名解引用2次才能获得数组中的值，使用两个<code>*</code>运算符或<code>[]</code>都可以实现：<code>zippo[2][1] = *(*(zippo + 2) + 1)</code>。</p>
<p><img src="https://gitee.com/Carlisle345748/cloudimg/raw/master/img/%E8%8E%B7%E5%8F%96%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%80%BC.png" alt="获取二维数组的值"></p>
</li>
</ul>
<img src="https://gitee.com/Carlisle345748/cloudimg/raw/master/img/数组的数组中的地址.png" alt="/数组的数组中的地址" style="zoom:50%;" />

<h3 id="声明一个指向多维数组的指针"><a href="#声明一个指向多维数组的指针" class="headerlink" title="声明一个指向多维数组的指针"></a>声明一个指向多维数组的指针</h3><p>处理类似zippo这样的二维数组时，把指针声明为指向int的类型还不够。因为指向int只能与zippo[0]的类型匹配，说明该指针指向一个int类型的值。但是zippo是它首元素的地址，该元素是一个内含两个int类型值的一维数组。因此，pz必须指向一个内含两个int类型值的数组，而不是指向一个int类型值。具体的声明方式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*pz)[<span class="number">2</span>]; <span class="comment">// pz指向一个含有两个int数值的数组，正确</span></span><br></pre></td></tr></table></figure>

<p>为什么要在声明中使用<code>()</code>？因为<code>[]</code>的优先级高于<code>*</code>，考虑以下声明语句：<code>[2]</code>先与<code>pax</code>结合，<code>pax</code>成为一个含有两个元素的数组，然后<code>*</code>表示pax数组内含有2个指针，最后int表示pax数组中的指针指向int类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pax[<span class="number">2</span>]; <span class="comment">// pax是一个含有两个指向int类型指针的数组，错误</span></span><br></pre></td></tr></table></figure>

<p>下面的例子演示如何使用指向二维数组的指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> zippo[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">2</span>,<span class="number">4</span>&#125;,&#123;<span class="number">3</span>,<span class="number">5</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> (*pz)[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    pz = zippo;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"   pz = %p,    pz + 1 = %p\n"</span>, pz, pz + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pz[0] = %p, pz[0] + 1 = %p\n"</span>, pz[<span class="number">0</span>], pz[<span class="number">0</span>] + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  *pz = %p,   *pz + 1 = %p\n"</span>, *pz, *pz + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"   pz[0][0] = %d,   *pz[0] = %d,  **pz = %d\n"</span>, pz[<span class="number">0</span>][<span class="number">0</span>], *pz[<span class="number">0</span>], **pz);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"   pz[2][1] = %d,    *(*(pz + 2) + 1) = %d\n"</span>, pz[<span class="number">2</span>][<span class="number">1</span>], *(*(pz + <span class="number">2</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"zippo[2][1] = %d, *(*(zippo + 2) + 1) = %d\n"</span>, zippo[<span class="number">2</span>][<span class="number">1</span>], *(*(zippo + <span class="number">2</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   pz = 0x7ffee60595e0,    pz + 1 = 0x7ffee60595e8</span></span><br><span class="line"><span class="comment">pz[0] = 0x7ffee60595e0, pz[0] + 1 = 0x7ffee60595e4</span></span><br><span class="line"><span class="comment">  *pz = 0x7ffee60595e0,   *pz + 1 = 0x7ffee60595e4</span></span><br><span class="line"><span class="comment">   pz[0][0] = 2,   *pz[0] = 2,  **pz = 2</span></span><br><span class="line"><span class="comment">   pz[2][1] = 2,    *(*(pz + 2) + 1) = 2</span></span><br><span class="line"><span class="comment">zippo[2][1] = 2, *(*(zippo + 2) + 1) = 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>虽然<code>pz</code>是一个指针，不是数组名，但是也可以使用 <code>pz[2][1]</code>这样的写法。可以用数组表示法或指针表示法来表示一个数组元素，既可以使用数组名，也可以使用指针名：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zippo[m][n] = *(*(zippo + m) + n);</span><br><span class="line">pz[m][n] = *(*(pz + m) + n);</span><br></pre></td></tr></table></figure>



<h3 id="指针类型的兼容性"><a href="#指针类型的兼容性" class="headerlink" title="指针类型的兼容性"></a>指针类型的兼容性</h3><p>指针之间的赋值比数值类型之间的赋值要严格。例如，不用类型转换就可以把 int 类型的值赋给double类型的变量，但是两个类型的指针不能这样做。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">double</span> x;</span><br><span class="line"><span class="keyword">int</span> * pi = &amp;n;</span><br><span class="line"><span class="keyword">double</span> * pd = &amp;x;</span><br><span class="line">x = n;   <span class="comment">// 允许</span></span><br><span class="line">pi = pd; <span class="comment">// 不允许,pi是pointer-to-int,pd是pointer-to-double</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * pt;</span><br><span class="line"><span class="keyword">int</span> (*pa)[<span class="number">3</span>];    <span class="comment">// pointer-to-int[3]</span></span><br><span class="line"><span class="keyword">int</span> ar1[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> ar2[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> **p2;        <span class="comment">// pointer-to-pointer-to-int</span></span><br><span class="line"></span><br><span class="line">pt = &amp;ar1[<span class="number">0</span>][<span class="number">0</span>]; <span class="comment">// pointer-to-int</span></span><br><span class="line">pt = ar1[<span class="number">0</span>];     <span class="comment">// pointer-to-int</span></span><br><span class="line">pt = ar1;        <span class="comment">// not valid, ar1 is pointer-to-int[3]</span></span><br><span class="line">pa = ar1;        <span class="comment">// pointer-to-int[3]</span></span><br><span class="line">pa = ar2;        <span class="comment">// not valid, ar2 is pointer-to-int[2]</span></span><br><span class="line">p2 = &amp;pt;        <span class="comment">// pointer-to-pointer</span></span><br><span class="line">*p2 = ar2[<span class="number">0</span>];    <span class="comment">// pointer-to-int</span></span><br><span class="line">p2 = ar2;        <span class="comment">// not valid, ar2 i pointer-to-int[2]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> y = <span class="number">23</span>;</span><br><span class="line"><span class="keyword">int</span> * p1 = &amp;x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * p2 = &amp;y;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ** pp2;</span><br><span class="line"></span><br><span class="line">p1 = p2;    <span class="comment">// 不安全，const指针赋给非const指针</span></span><br><span class="line">p2 = p1;    <span class="comment">// 安全，把非const指针赋给const指针</span></span><br><span class="line">pp2 = &amp;p1;  <span class="comment">// 不安全，嵌套指针类型赋值</span></span><br></pre></td></tr></table></figure>

<p>前面提到过，把const指针赋给非const指针不安全，因为这样可以使用新的指针改变const指针指向的数据。编译器在编译代码时，可能会给出警告，执行这样的代码是未定义的。但是把非const指针赋给const指针没问题，前提是只进行一级解引用<code>p2 = p1</code>。进行两集解引用的时候，这样赋值也不安全。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ** pp2;</span><br><span class="line"><span class="keyword">int</span> * p1;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">13</span>;</span><br><span class="line">pp2 = &amp;p1;  <span class="comment">// 允许，但是pp2的const限定符失效，因为p1非const</span></span><br><span class="line">*pp2 = &amp;n;  <span class="comment">// 允许，两者都声明为const，但是这导致p1指向n</span></span><br><span class="line">*p1 = <span class="number">10</span>;   <span class="comment">// 允许，但是这将改变n的值</span></span><br></pre></td></tr></table></figure>

<p>pp2指向p1，p1指向n。pp2和n为const，但是p1非const。C标准规定了通过非const指针更改const数据是未定义的行为。例如，在Terminal中（OS X对底层UNIX系统的访问）使用gcc编译包含以上代码的程序，导致n最终的值是13，但是在相同系统下使用 clang来编译，n最终的值是10。两个编译器都给出指针类型不兼容的警告。</p>
<blockquote>
<p>C const和C++ const</p>
<p>C和C++中const的用法很相似，但是并不完全相同。区别之一是， C++允许在声明数组大小时使用const整数，而C却不允许。区别之二是， C++的指针赋值检查更严格：</p>
<p>const int y;</p>
<p>const int * p2 = &y;</p>
<p>int * p1;</p>
<p>p1 = p2;   // C++中不允许这样做，但是C可能只给出警告</p>
<p>C++不允许把const指针赋给非const指针。而C则允许这样做，但是如果通过p1更改y，其行为是未定义的。</p>
</blockquote>
<h3 id="函数和多维数组"><a href="#函数和多维数组" class="headerlink" title="函数和多维数组"></a>函数和多维数组</h3><p>声明函数原型和定义函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二维数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">somefuntion</span><span class="params">(<span class="keyword">int</span>(*pt)[<span class="number">4</span>])</span></span>;     <span class="comment">// 多维函数指针作为形参</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">somefuntion2</span><span class="params">(<span class="keyword">int</span> pt[][<span class="number">4</span>])</span></span>;    <span class="comment">// 当且仅当pt是函数的形参时，可以这样声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">somefuntion</span><span class="params">(<span class="keyword">int</span>(*pt)[<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  some code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">somefuntion</span><span class="params">(<span class="keyword">int</span> pt[][<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  some code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，下面的声明不正确：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> ar[][], <span class="keyword">int</span> rows)</span></span>;  <span class="comment">// 错误声明</span></span><br></pre></td></tr></table></figure>

<p>编译器会把数组表示法转换成指针表示法。例如，编译器会把 <code>ar[1]</code>转换成<code>ar+1</code>。编译器对<code>ar+1</code>求值，要知道<code>ar</code>所指向的对象大小。下面的声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> ar[][<span class="number">4</span>], <span class="keyword">int</span> rows)</span></span>;  <span class="comment">// 有效声明</span></span><br></pre></td></tr></table></figure>

<p>表示ar指向一个内含4个int类型值的数组（在我们的系统中，<code>ar</code>指向的对象占16字节），所以<code>ar+1</code>的意思是“该地址加上16字节”。如果第2对方括号是空的，编译器就不知道该怎样处理。也可以在第1对方括号中写上大小，如下所示，但是编译器会忽略该值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> ar[<span class="number">3</span>][<span class="number">4</span>], <span class="keyword">int</span> rows)</span></span>;  <span class="comment">// 有效声明，但是3会被忽略</span></span><br></pre></td></tr></table></figure>

<p><strong>声明一个指向N维数组的指针时，只能省略最左边方括号中的值：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum4d</span><span class="params">(<span class="keyword">int</span> ar[][<span class="number">12</span>][<span class="number">20</span>][<span class="number">30</span>], <span class="keyword">int</span> rows)</span></span>;    <span class="comment">// 等价于下式</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum4d</span><span class="params">(<span class="keyword">int</span> (*ar)[<span class="number">12</span>][<span class="number">20</span>][<span class="number">30</span>], <span class="keyword">int</span> rows)</span></span>;</span><br></pre></td></tr></table></figure>



<h2 id="复合字面量-compound-literals"><a href="#复合字面量-compound-literals" class="headerlink" title="复合字面量(compound literals)"></a>复合字面量(compound literals)</h2><p>假设给带int类型形参的函数传递一个值，要传递int类型的变量，但是也可以传递int类型常量，如5。在C99 标准以前，对于带数组形参的函数，可以传递数组，但是没有等价的数组常量。C99新增了复合字面量 （compound literal）。字面量是除符号常量外的常量。例如，5是int类型字 面量， 81.3是double类型的字面量，’Y’是char类型的字面量，”elephant”是字符串字面量。发布C99标准的委员会认为，如果有代表数组和结构内容的复合字面量，在编程时会更方便。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> diva[<span class="number">2</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;  <span class="comment">// 普通数组声明；</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">int</span> [<span class="number">2</span>])&#123;<span class="number">10</span>, <span class="number">20</span>&#125;;       <span class="comment">// 复合字面量(compound literals)，int [2]即是复合字面量的类型名</span></span><br><span class="line">(<span class="keyword">int</span> [])&#123;<span class="number">50</span>, <span class="number">70</span>, <span class="number">90</span>&#125;     <span class="comment">// 与普通数组初始化一样，也可以让编译器自动计算数组大小</span></span><br></pre></td></tr></table></figure>

<p>因为复合字面量是<strong>匿名的</strong>，所以不能先创建然后再使用它，必须在创建的同时使用它。使用指针记录地址就是一种用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * pt1;</span><br><span class="line">pt1 = (<span class="keyword">int</span>[<span class="number">2</span>])&#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>与有数组名的数组类似，复合字面量的类型名也代表首元素的地址，所以可以把它赋给指向int的指针，然后便可使用这个指针。例如，<code>*pt1</code>是10，<code>pt1[1]</code>是20。</p>
<p>还可以把复合字面量作为实际参数传递给带有匹配形式参数的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> ar[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span> total;</span><br><span class="line">total = sum((<span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>第1个实参是内含6个int类型值的数组，和数组名类似，这同时也是该数组首元素的地址。这种用法的好处是，把信息传入函数前不必先创建数组，这是复合字面量的典型用法。</p>
<p>可以把这种用法应用于二维数组或多维数组。例如，下面的代码演示了如何创建二维int数组并储存其地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*pt2)[<span class="number">4</span>];</span><br><span class="line">pt2 = (<span class="keyword">int</span>[<span class="number">2</span>][<span class="number">4</span>])&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/13/%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="崔梓坤">
      <meta itemprop="description" content="我的计算机学习经历和笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="崔梓坤的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/13/%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/" class="post-title-link" itemprop="url">重定向输入输出</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-13 18:22:51 / 修改时间：18:23:16" itemprop="dateCreated datePublished" datetime="2020-06-13T18:22:51+08:00">2020-06-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="重定向输入和输出"><a href="#重定向输入和输出" class="headerlink" title="重定向输入和输出"></a>重定向输入和输出</h2><p>绝大部分C系统都可以使用重定向，可以通过操作系统重定向所有程 序，或只在C编译器允许的情况下重定向C程序。假设prog是可执行程序名，file1和file2是文件名。</p>
<ul>
<li><strong>重定向输出至文件</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./prog &gt; file1</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>重定向输入至文件</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./prog &lt; file2</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>组合重定向</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./prog &lt; file1 &gt; file2</span><br><span class="line">./prog &gt; file2 &lt; file1</span><br></pre></td></tr></table></figure>

<p>一些系统要求重定向运算符左侧有一个空格，右侧没有空格。而其他系统（如，UNIX）允许在重定位运算符两侧有空格或没有空格。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/13/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="崔梓坤">
      <meta itemprop="description" content="我的计算机学习经历和笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="崔梓坤的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/13/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/" class="post-title-link" itemprop="url">流程控制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-13 18:21:28 / 修改时间：18:21:54" itemprop="dateCreated datePublished" datetime="2020-06-13T18:21:28+08:00">2020-06-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="else与if的配对"><a href="#else与if的配对" class="headerlink" title="else与if的配对"></a>else与if的配对</h2><p>如果程序中有多个if和else，<strong>如果没有花括号划分，else将与最后一个if配对</strong>。C语言编译器会忽略缩进，所以不要被缩进混淆。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虽然第二个if看起来是嵌套在第一个if里面，else看起来是与第一个if匹配</span></span><br><span class="line"><span class="comment">// 但是C编译器忽略缩进，所以else是与最后一个if（第二个）匹配</span></span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">6</span>)</span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">12</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"You're lose!\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Sorry, you lose a turn.\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用花括号划分，才能使else与第一个if匹配</span></span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">6</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">12</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"You're lose!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Sorry, you lose a turn.\n"</span>);</span><br></pre></td></tr></table></figure>



<h2 id="continue和break在循环中的作用"><a href="#continue和break在循环中的作用" class="headerlink" title="continue和break在循环中的作用"></a>continue和break在循环中的作用</h2><ul>
<li>在循环中，continue命令的作用是跳过当前迭代，直接开始下一代。<strong>对于while和do while，continue后会直接跳转到test condition；对于for，continue后会跳到update expression。</strong></li>
<li>在循环中，break命令直接跳过循环至循环下的第一条语句，而不会执行update expression。</li>
</ul>
<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>程序根据expression的值跳转至相应的case标签处。<strong>然后，执行剩下的所有语句，除非执行到break语句进行重定向</strong>。<strong>expression和case标签都必须是整数值（包括char类型），标签必须是常量或完全由常量组成的表达式。</strong>如果没有case标签与expression的值匹配，控制则转至标有default的语句（如果有的话）；否则，将转至执行紧跟在switch语句后面的语句。</p>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> label1 : statement1; <span class="comment">//use break to skip to the end</span></span><br><span class="line">  <span class="keyword">case</span> label2 : statement2;</span><br><span class="line">  <span class="keyword">default</span> : statement3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (choice)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span> :</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span> : <span class="built_in">printf</span>(<span class="string">"This is case 2.\n"</span>);</span><br><span class="line">    			 <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span> : <span class="built_in">printf</span>(<span class="string">"This is case 3.\n"</span>);</span><br><span class="line">    			 <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span> : <span class="built_in">printf</span>(<span class="string">"This is case 4.\n"</span>);</span><br><span class="line">    			 <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span> : <span class="built_in">printf</span>(<span class="string">"This is default.\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="与if-else比较"><a href="#与if-else比较" class="headerlink" title="与if else比较"></a>与if else比较</h3><p>如果是根据浮点类型的变量或表达式来选择，就无法使用 switch。如果根据变量在某范围内决定程序流的去向，使用 switch 就很麻烦，这种情况用if就很方便：<code>if (integer &lt; 1000 &amp;&amp; integer &gt; 2)</code>。使用switch要涵盖以上范围，需要为每个整数（3～999）设置case标签。但是，如果使用switch，程序通常运行快一些，生成的代码少一些。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/13/printf%E5%92%8Cscanf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="崔梓坤">
      <meta itemprop="description" content="我的计算机学习经历和笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="崔梓坤的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/13/printf%E5%92%8Cscanf/" class="post-title-link" itemprop="url">printf和scanf</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-13 18:20:33 / 修改时间：18:21:01" itemprop="dateCreated datePublished" datetime="2020-06-13T18:20:33+08:00">2020-06-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="printf-函数"><a href="#printf-函数" class="headerlink" title="printf()函数"></a>printf()函数</h2><h3 id="清空缓冲区-buffer"><a href="#清空缓冲区-buffer" class="headerlink" title="清空缓冲区(buffer)"></a>清空缓冲区(buffer)</h3><p>C语言中，printf()的结果被放置在一个暂存空间，称为缓存区(buffer)。C语言规定，当遇到以下情况时，缓冲区中的结果会输出到屏幕：</p>
<ul>
<li>缓冲区空间已满</li>
<li>遇到换行符<code>\n</code></li>
<li>遇到即将发生的<code>scanf()</code></li>
<li><code>fflush()</code>，<u>待补充</u></li>
</ul>
<h3 id="printf-转换说明修饰符"><a href="#printf-转换说明修饰符" class="headerlink" title="printf()转换说明修饰符"></a>printf()转换说明修饰符</h3><img src="https://gitee.com/Carlisle345748/cloudimg/raw/master/img/printf()转换说明修饰符.png" style="zoom:68%;" />

<p><img src="https://gitee.com/Carlisle345748/cloudimg/raw/master/img/printf()%E6%A0%87%E8%AE%B0%E4%BF%AE%E9%A5%B0%E7%AC%A6.png" alt=""></p>
<h3 id="printf-输入长字符串"><a href="#printf-输入长字符串" class="headerlink" title="printf()输入长字符串"></a>printf()输入长字符串</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, my name is Carl. Nice to meet you!\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// method 1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, my name is Carl. "</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Nice to meet you!\n"</span>);</span><br><span class="line">    <span class="comment">// method 2</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, my name is Carl. \</span></span><br><span class="line"><span class="string">Nice to meet you!\n"</span>);</span><br><span class="line">    <span class="comment">// method 3</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, my name is Carl. "</span></span><br><span class="line">        <span class="string">"Nice to meet you!\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">Hello, my name is Carl. Nice to meet you!</span></span><br><span class="line"><span class="comment">Hello, my name is Carl. Nice to meet you!</span></span><br><span class="line"><span class="comment">Hello, my name is Carl. Nice to meet you!</span></span><br><span class="line"><span class="comment">Hello, my name is Carl. Nice to meet you!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>方法一：使用2个printf()</li>
<li>方法二：用反斜杠<code>\</code>来断行。这使得光标移至下一行，而且字符串中不会包含换行符。其效果是在下一行继续输出。 但是，下一行代码必须和程序清单中的代码一样从最左边开始。如果缩进该行，比如缩进5个空格，那么这5个空格就会成为字符串的一部分。</li>
<li>方法三：ANSI C引入的字符串连接。在两个用双引号括起来的字符串之间用空白隔开，C编译器会把多个字符串看作是一个字符串。</li>
</ul>
<h3 id="printf-的传参过程和转换说明作用过程"><a href="#printf-的传参过程和转换说明作用过程" class="headerlink" title="printf()的传参过程和转换说明作用过程"></a>printf()的传参过程和转换说明作用过程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> n1 = <span class="number">3.0F</span>;</span><br><span class="line">    <span class="keyword">double</span> n2 = <span class="number">3.0</span>;</span><br><span class="line">    <span class="keyword">long</span> n3 = <span class="number">2000000000</span>;</span><br><span class="line">    <span class="keyword">long</span> n4 = <span class="number">1234567890</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld %ldå %ld% ld\n"</span>, n1, n2, n3, n4); <span class="comment">// 使用了错误的转换说明</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果部分参数的转换说明使用错误，其他的参数的转换说明即使是正确的，也可能输出错误的结果。</strong></p>
<p>该调用告诉计算机把变量n1、n2、n3和n4的值传递给程序。这是一种常见的参数传递方式。程序把传入的值放入被称为栈（stack）的内存区域。 计算机根据变量类型（不是根据转换说明）把这些值放入栈中。因此，n1被储存在栈中，占8字节（float类型被转换成double类型）。同样，n2也在栈中占8字节，而n3和n4在栈中分别占4字节。然后，控制转到printf()函数。该函数根据转换说明（不是根据变量类型）从栈中读取值。%ld转换说明表明 printf()应该读取4字节，所以printf()读取栈中的前4字节作为第1个值。这是 n1的前半部分，将被解释成一个long类型的整数。根据下一个%ld转换说 明，printf()再读取4字节，这是n1的后半部分，将被解释成第2个long类型的 整数。类似地，根据第3个和第4个%ld，printf()读取n2的前半部 分和后半部分，并解释成两个long类型的整数。因此，对于n3和n4，虽然用对了转换说明，但printf()还是读错了字节。</p>
<img src="https://gitee.com/Carlisle345748/cloudimg/raw/master/img/printf()函数运行过程.png" alt="printf()函数运行过程" style="zoom:40%;" />



<h2 id="scanf-函数"><a href="#scanf-函数" class="headerlink" title="scanf()函数"></a>scanf()函数</h2><h3 id="scanf-转换说明和修饰符"><a href="#scanf-转换说明和修饰符" class="headerlink" title="scanf()转换说明和修饰符"></a>scanf()转换说明和修饰符</h3><ul>
<li>转换说明</li>
</ul>
<p><img src="https://gitee.com/Carlisle345748/cloudimg/raw/master/img/scanf()%E8%BD%AC%E6%8D%A2%E8%AF%B4%E6%98%8E.png" alt="scanf()转换说明"></p>
<ul>
<li>转换说明修饰符</li>
</ul>
<p><img src="https://gitee.com/Carlisle345748/cloudimg/raw/master/img/scanf()%E8%BD%AC%E6%8D%A2%E8%AF%B4%E6%98%8E%E4%BF%AE%E9%A5%B0%E7%AC%A61.png" alt="转换说明修饰符"></p>
<p><img src="https://gitee.com/Carlisle345748/cloudimg/raw/master/img/scanf()%E8%BD%AC%E6%8D%A2%E8%AF%B4%E6%98%8E%E4%BF%AE%E9%A5%B0%E7%AC%A62.png" alt="转换说明修饰符"></p>
<h2 id="printf-和scanf-中的-修饰符"><a href="#printf-和scanf-中的-修饰符" class="headerlink" title="printf()和scanf()中的 * 修饰符"></a>printf()和scanf()中的 * 修饰符</h2><ul>
<li><p>printf()：如果你不想预先指定字段宽度，希望通过程序来指定，那么可以用<code>*</code>修饰符代替字段宽度。但还是要用一个参数告诉函数，字段宽度应该是多少。 也就是说，如果转换说明是<code>%*d</code>，那么参数列表中应包含<code>*</code>和<code>d</code>对应的值。这个技巧也可用于浮点值指定精度和字段宽度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="built_in">width</span>, precision;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">double</span> weight = <span class="number">242.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Enter a field width:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%u"</span>, &amp;<span class="built_in">width</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The number is: %*d\n"</span>, <span class="built_in">width</span>, number);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Now enter a width and a precision:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%u %u"</span>, &amp;<span class="built_in">width</span>, &amp;precision);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Weight = %*.*f\n"</span>, <span class="built_in">width</span>, precision, weight);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">Enter a field width:</span></span><br><span class="line"><span class="comment">12</span></span><br><span class="line"><span class="comment">The number is:          256</span></span><br><span class="line"><span class="comment">Now enter a width and a precision:</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">Weight = 242.50</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>scanf()：把*放在%和转换字符之间时，会使得 scanf()跳过相应的输出项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Please enter 3 integers.\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%*d %*d %d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The third integer was %d"</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output</span></span><br><span class="line"><span class="comment">12 11 13</span></span><br><span class="line"><span class="comment">The third integer was 13</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="混合使用scanf-读取数值和getchar-读取字符的常见错误"><a href="#混合使用scanf-读取数值和getchar-读取字符的常见错误" class="headerlink" title="混合使用scanf()读取数值和getchar()读取字符的常见错误"></a>混合使用scanf()读取数值和getchar()读取字符的常见错误</h2><p>假设程序要求用 getchar()处理字符输入，用 scanf()处理数值输入，这两个函数都能很好地完成任务，但是把它们混用会容易出错。因为 <strong>getchar()读取每个字符，包括空格、制表符和换行符；而 scanf()在读取数字时则会跳过空格、制表符和换行符，比如</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num);</span><br><span class="line"><span class="comment">// 输入 1[enter]</span></span><br><span class="line">ch = getchar();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, ch);</span><br><span class="line"><span class="comment">// (ch的值为换行符'\n')</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>

<p>按[enter]确认输入后，scanf()读取<code>1</code>赋值给<code>num</code>，但是会将将输入[enter]带来的<code>\n</code>保留在缓冲区。但是，getchar()不会跳过换行符，所以你还没来得及输入字符，它就读取了换行符<code>\n</code>，然后将其赋给<code>ch</code>。</p>
<p>要解决这个问题，程序要跳过一轮输入结束与下一轮输入开始之间的所有换行符或空格。使用以下方式可以丢弃scanf()输入后面的所有字符(包括换行符)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num);</span><br><span class="line"><span class="comment">// 输入 1[enter]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (getchar != <span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">ch = getchar();</span><br><span class="line"><span class="comment">// 输入a</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, ch);</span><br><span class="line"><span class="comment">// a</span></span><br></pre></td></tr></table></figure>

<p>while循环不断读取剩余的字符，直到读取到换行符结束循环(此时<code>\n</code>已被读取，所以缓冲区中已经没有<code>\n</code>)。注意，这个方法要求缓冲区内存在<code>\n</code>，如果缓冲区内没有<code>\n</code>，比如缓冲区为空，则会陷入无限循环。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">崔梓坤</p>
  <div class="site-description" itemprop="description">我的计算机学习经历和笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">崔梓坤</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
