<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="结构(structure)C 结构提供在相同的数据对象中储存多个不同类型数据项的方法。可以 使用标记来标识一个具体的结构模板，并声明该类型的变量。通过成员点运 算符（.）可以使用结构模版中的标签来访问结构的各个成员。 建立结构声明12345struct book&amp;#123;        &#x2F;&#x2F; book是该结构的标记 tag  char title[40];  char author[40];">
<meta property="og:type" content="article">
<meta property="og:title" content="结构和其他数据形式">
<meta property="og:url" content="http://yoursite.com/2020/06/13/%E7%BB%93%E6%9E%84%E5%92%8C%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E5%BD%A2%E5%BC%8F/index.html">
<meta property="og:site_name" content="崔梓坤的个人博客">
<meta property="og:description" content="结构(structure)C 结构提供在相同的数据对象中储存多个不同类型数据项的方法。可以 使用标记来标识一个具体的结构模板，并声明该类型的变量。通过成员点运 算符（.）可以使用结构模版中的标签来访问结构的各个成员。 建立结构声明12345struct book&amp;#123;        &#x2F;&#x2F; book是该结构的标记 tag  char title[40];  char author[40];">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/Carlisle345748/cloudimg/raw/master/img/%E7%BB%93%E6%9E%84%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.png">
<meta property="article:published_time" content="2020-06-13T10:26:47.000Z">
<meta property="article:modified_time" content="2020-06-13T10:27:21.399Z">
<meta property="article:author" content="崔梓坤">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/Carlisle345748/cloudimg/raw/master/img/%E7%BB%93%E6%9E%84%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.png">

<link rel="canonical" href="http://yoursite.com/2020/06/13/%E7%BB%93%E6%9E%84%E5%92%8C%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E5%BD%A2%E5%BC%8F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>结构和其他数据形式 | 崔梓坤的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">崔梓坤的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/13/%E7%BB%93%E6%9E%84%E5%92%8C%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E5%BD%A2%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="崔梓坤">
      <meta itemprop="description" content="我的计算机学习经历和笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="崔梓坤的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          结构和其他数据形式
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-13 18:26:47 / 修改时间：18:27:21" itemprop="dateCreated datePublished" datetime="2020-06-13T18:26:47+08:00">2020-06-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="结构-structure"><a href="#结构-structure" class="headerlink" title="结构(structure)"></a>结构(structure)</h2><p>C 结构提供在相同的数据对象中储存多个不同类型数据项的方法。可以 使用标记来标识一个具体的结构模板，并声明该类型的变量。通过成员点运 算符（.）可以使用结构模版中的标签来访问结构的各个成员。</p>
<h3 id="建立结构声明"><a href="#建立结构声明" class="headerlink" title="建立结构声明"></a>建立结构声明</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span>&#123;</span>        <span class="comment">// book是该结构的标记 tag</span></span><br><span class="line">  <span class="keyword">char</span> title[<span class="number">40</span>];</span><br><span class="line">  <span class="keyword">char</span> author[<span class="number">40</span>];</span><br><span class="line">  <span class="keyword">float</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该声明描述了一个由两个字符数组和一个float类型变量组成的结构。<strong>上述声明并未创建实际的数据对象</strong>，只描述了该对象由什么组成。下一步是创建一个结构变量，即是结构的另一层含义。程序中创建结构变量的一行是:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span>;</span></span><br></pre></td></tr></table></figure>

<p>这把library声明为一个使用book结构布局的结构变量。在结构的变量的声明中，struct book的作用相当于int或float。例如，可以定义两个struct book类型的变量，还可以定义指向struct book类型的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">doyle</span>, <span class="title">panshin</span>, * <span class="title">ptbook</span>;</span></span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/Carlisle345748/cloudimg/raw/master/img/结构的内存分配.png" alt="结构的内存分配" style="zoom:50%;" />

<p><strong>简化声明形式</strong></p>
<p>声明结构的过程和定义结构变量的过程可以组合成一个步骤，甚至不需要tag。不使用tag声明的结构不会创建结构模型，所以如果打算多次使用这样的结构，就需要使用tag。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span>&#123;</span></span><br><span class="line">  <span class="keyword">char</span> title[<span class="number">40</span>];</span><br><span class="line">  <span class="keyword">char</span> author[<span class="number">40</span>];</span><br><span class="line">  <span class="keyword">float</span> value;</span><br><span class="line">&#125; library;   <span class="comment">// 声明的右花括号后跟变量名</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span>      <span class="comment">// 不需要标记tag</span></span><br><span class="line">  <span class="keyword">char</span> title[<span class="number">40</span>];</span><br><span class="line">  <span class="keyword">char</span> author[<span class="number">40</span>];</span><br><span class="line">  <span class="keyword">float</span> value;</span><br><span class="line">&#125; library;   <span class="comment">// 声明的右花括号后跟变量名</span></span><br></pre></td></tr></table></figure>



<h3 id="初始化结构变量"><a href="#初始化结构变量" class="headerlink" title="初始化结构变量"></a>初始化结构变量</h3><p>可以使用普通初始化或指定初始化器来初始化结构变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span> = &#123;</span></span><br><span class="line">  <span class="string">"The Pious Pirate amd the Devious Damsel"</span>,</span><br><span class="line">  <span class="string">"Remme Vivotte"</span>,</span><br><span class="line">  <span class="number">1.95</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定初始化器</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span> = &#123;</span>.value = <span class="number">10.99</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任意顺序使用指定初始化器</span></span><br><span class="line">struct book gift = &#123;</span><br><span class="line">  .value = <span class="number">25.99</span>,</span><br><span class="line">  .author = <span class="string">"James"</span>,</span><br><span class="line">  .title = <span class="string">"Red and Black"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与数组类似，在指定初始化器后面的普通初始化器，为指定成员后面的成员提供初始值。另外，对特定成员的最后一次赋值才是它实际获得的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">gitf</span> = &#123;</span></span><br><span class="line">  .valie = <span class="number">18.90</span>,</span><br><span class="line">  .author = <span class="string">"Pestle"</span>,</span><br><span class="line">  <span class="number">0.25</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>赋给value的值是0.25，因为它在结构声明中紧跟在author成员之后。新值0.25取代了之前的18.9。</p>
<h3 id="访问结构成员"><a href="#访问结构成员" class="headerlink" title="访问结构成员"></a>访问结构成员</h3><p>使用结构成员运算符——点（.）访问结构中的成员。注意，虽然library是一个结构，但是library.value是一个float类型的变量，可以像使用其他 float 类型变量那样使用它</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span> = &#123;</span></span><br><span class="line">  .value = <span class="number">25.99</span>,</span><br><span class="line">  .author = <span class="string">"James"</span>,</span><br><span class="line">  .title = <span class="string">"Red and Black"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">library.author;   <span class="comment">// "James"</span></span><br><span class="line">library.title;	  <span class="comment">// "Red and Black"</span></span><br><span class="line">library.value;    <span class="comment">//  25.99</span></span><br></pre></td></tr></table></figure>



<h3 id="结构之间赋值"><a href="#结构之间赋值" class="headerlink" title="结构之间赋值"></a>结构之间赋值</h3><p>现在的C允许把一个结构赋值给另一个结构，但是数组不能这样做。也就是说，如果n_data和o_data都是相同类型的结构，可以这样做：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o_data = n_data;</span><br></pre></td></tr></table></figure>

<p><strong>这条语句把n_data的每个成员的值都赋给o_data的相应成员。即使成员是数组，也能完成赋值</strong>。另外，还可以把一个结构初始化为相同类型的另一 个结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">right_field</span> = &#123;</span><span class="string">"Ruthie"</span>, <span class="string">"George"</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">captain</span> = <span class="title">right_field</span>;</span></span><br></pre></td></tr></table></figure>



<h3 id="结构数组"><a href="#结构数组" class="headerlink" title="结构数组"></a>结构数组</h3><p>类似其他变量，结构也可以创建结构数组。声明结构数组和声明其他类型的数组类似，下面是一个声明结构数组的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span>[100];</span></span><br></pre></td></tr></table></figure>

<p>访问结构数组内结构的成员</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">library[<span class="number">1</span>].author</span><br></pre></td></tr></table></figure>



<h3 id="嵌套结构"><a href="#嵌套结构" class="headerlink" title="嵌套结构"></a>嵌套结构</h3><p>在结构中中还可以包含另外一个结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">name</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> first[<span class="number">40</span>];</span><br><span class="line">  <span class="keyword">char</span> last[<span class="number">40</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">friend</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">name</span> <span class="title">handle</span>;</span>  <span class="comment">// 嵌套结构</span></span><br><span class="line">  <span class="keyword">char</span> favfood[<span class="number">40</span>];</span><br><span class="line">  <span class="keyword">char</span> job[<span class="number">40</span>];</span><br><span class="line">  <span class="keyword">float</span> income;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化嵌套结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">friend</span> <span class="title">Jack</span> = &#123;</span></span><br><span class="line">  &#123;<span class="string">"Jack"</span>, <span class="string">"Cral"</span>&#125;,</span><br><span class="line">  <span class="string">"grilled salmon"</span>,</span><br><span class="line">  <span class="string">"Personality coach"</span>,</span><br><span class="line">  <span class="number">68112.00</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问嵌套结构成员</span></span><br><span class="line">Jack.handle.first; <span class="comment">// "Jack"</span></span><br><span class="line">Jack.handle.last;  <span class="comment">// "Carl"</span></span><br></pre></td></tr></table></figure>



<h3 id="指向结构的指针"><a href="#指向结构的指针" class="headerlink" title="指向结构的指针"></a>指向结构的指针</h3><p>使用结构指针的四大理由：</p>
<ul>
<li>比结构本身更容易操控(比如排序)</li>
<li>一些早期的C实现中，结构不能作为参数传递给函数，但是可以传递指向结构的指针（向后兼容）</li>
<li>传递指针比传递结构更有效率</li>
<li>一些数据结构中需要使用指向其他结构的指针</li>
</ul>
<h4 id="声明结构指针"><a href="#声明结构指针" class="headerlink" title="声明结构指针"></a>声明结构指针</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">guy</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">name</span> <span class="title">handle</span>;</span></span><br><span class="line">  <span class="keyword">char</span> favfood[<span class="number">40</span>];</span><br><span class="line">  <span class="keyword">char</span> job[<span class="number">40</span>];</span><br><span class="line">  <span class="keyword">float</span> income;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">friend</span> * <span class="title">him</span>;</span>   <span class="comment">// 声明结构指针</span></span><br></pre></td></tr></table></figure>

<p>指针him现在可以指向任意现有的guy类型的结构，例如如果barney是一个guy类型的结构，可以这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">him = &amp;barney;   <span class="comment">// 结构名不是结构地址，要加上&amp;</span></span><br></pre></td></tr></table></figure>

<p><strong>和数组不同的是，结构名并不是结构的地址，因此要在结构名前面加上 &amp;运算符。</strong></p>
<h4 id="用指针访问结构成员"><a href="#用指针访问结构成员" class="headerlink" title="用指针访问结构成员"></a>用指针访问结构成员</h4><ul>
<li><p>使用<code>-&gt;</code>运算符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">him = &amp;barney;</span><br><span class="line">him-&gt;income   <span class="comment">// 等价于barney.income</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解引用后访问</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">him = &amp;barney;</span><br><span class="line">(*him).income <span class="comment">// 等价于barney.income</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="向函数传递结构信息"><a href="#向函数传递结构信息" class="headerlink" title="向函数传递结构信息"></a>向函数传递结构信息</h3><h4 id="传递结构成员"><a href="#传递结构成员" class="headerlink" title="传递结构成员"></a>传递结构成员</h4><p>只要结构成员是一个具有单个值的数据类型（即，int及其相关类型、 char、float、double或指针），便可把它作为参数传递给接受该特定类型的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNDLEN 50</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">funds</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> bank[FUNDLEN];</span><br><span class="line">  <span class="keyword">double</span> bankfund;</span><br><span class="line">  <span class="keyword">char</span> save[FUNDLEN];</span><br><span class="line">  <span class="keyword">double</span> savefund;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">funds</span> <span class="title">stan</span> = &#123;</span></span><br><span class="line">    <span class="string">"Garlic"</span>,</span><br><span class="line">    <span class="number">40532.27</span>,</span><br><span class="line">    <span class="string">"Lucky"</span>,</span><br><span class="line">    <span class="number">8543.94</span></span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Stan has a total of $%.2f\n"</span>, sum(stan.bankfund, stan.savefund));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="传递结构的地址"><a href="#传递结构的地址" class="headerlink" title="传递结构的地址"></a>传递结构的地址</h4><p>继续解决前面的问题，但是这次把结构的地址作为参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNDLEN 50</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">funds</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> bank[FUNDLEN];</span><br><span class="line">  <span class="keyword">double</span> bankfund;</span><br><span class="line">  <span class="keyword">char</span> save[FUNDLEN];</span><br><span class="line">  <span class="keyword">double</span> savefund;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于该函数不能改变指针所指向值的内容，所以把money声明为一个指向const的指针。</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> struct funds *)</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">funds</span> <span class="title">stan</span> = &#123;</span></span><br><span class="line">    <span class="string">"Garlic"</span>,</span><br><span class="line">    <span class="number">40532.27</span>,</span><br><span class="line">    <span class="string">"Lucky"</span>,</span><br><span class="line">    <span class="number">8543.94</span></span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Stan has a total of $%.2f\n"</span>, sum(&amp;stan));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> struct funds * money)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> money-&gt;savefund + money-&gt;bankfund;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="传递结构"><a href="#传递结构" class="headerlink" title="传递结构"></a>传递结构</h4><p>新的编译器允许把结构直接作为参数，因此可以把上述程序重写为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNDLEN 50</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">funds</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> bank[FUNDLEN];</span><br><span class="line">  <span class="keyword">double</span> bankfund;</span><br><span class="line">  <span class="keyword">char</span> save[FUNDLEN];</span><br><span class="line">  <span class="keyword">double</span> savefund;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于该函数不能改变指针所指向值的内容，所以把money声明为一个指向const的指针。</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> struct funds)</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">funds</span> <span class="title">stan</span> = &#123;</span></span><br><span class="line">    <span class="string">"Garlic"</span>,</span><br><span class="line">    <span class="number">40532.27</span>,</span><br><span class="line">    <span class="string">"Lucky"</span>,</span><br><span class="line">    <span class="number">8543.94</span></span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Stan has a total of $%.2f\n"</span>, sum(stan));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> struct funds money)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> money.avefund + money.bankfund;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用sum()时，编译器根据funds模板创建 了一个名为money的自动结构变量。然后，该结构的各成员被初始化为 stan 结构变量相应成员的值的副本，因此函数中使用原来结构的副本来进行计算，而传递结构地址的函数中，函数使用原始结构进行运算。</p>
<h4 id="结构作为返回值"><a href="#结构作为返回值" class="headerlink" title="结构作为返回值"></a>结构作为返回值</h4><p>现在的C（包括ANSI C），函数不仅能把结构本身作为参数传递，还能把结构作为返回值返回。把结构作为函数参数可以把结构的信息传送给函数；把结构作为返回值的函数能把结构的信息从被调函数传回主调函数。结构指针也允许这种双向通信，因此可以选择任一种方法来解决编程问题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NLEN 30</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">namect</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> fname[NLEN];</span><br><span class="line">  <span class="keyword">char</span> lname[NLEN];</span><br><span class="line">  <span class="keyword">int</span> letters;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct namect <span class="title">getinfo</span><span class="params">(<span class="keyword">void</span>)</span></span>;           <span class="comment">// 以结构作为返回值</span></span><br><span class="line"><span class="function">struct namect <span class="title">makeinfo</span><span class="params">(struct namect)</span></span>; <span class="comment">// 以结构作为参数和返回值</span></span><br></pre></td></tr></table></figure>



<h4 id="函数中结构和结构指针的选择"><a href="#函数中结构和结构指针的选择" class="headerlink" title="函数中结构和结构指针的选择"></a>函数中结构和结构指针的选择</h4><p>把指针作为参数有两个优点和一个缺点：</p>
<ul>
<li><p>优点1：无论是以前还是现在的C实现都能使用这种方法</p>
</li>
<li><p>优点2：效率高，只需要传递一个地址。</p>
</li>
<li><p>缺点1：无法保护数据。 被调函数中的某些操作可能会意外影响原来结构中的数据。</p>
</li>
</ul>
<p>把结构作为参数传递的优点和缺点：</p>
<ul>
<li><p>优点1：函数处理的是原始数据的副本，保护了原始数据</p>
</li>
<li><p>优点2：代码风格更清楚</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vector</span> &#123;</span></span><br><span class="line">  <span class="keyword">double</span> x; </span><br><span class="line">  <span class="keyword">double</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vector</span> <span class="title">ans</span>, <span class="title">a</span>, <span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递结构版本</span></span><br><span class="line"><span class="function">struct <span class="built_in">vector</span> <span class="title">sum_vect</span><span class="params">(struct <span class="built_in">vector</span>, struct <span class="built_in">vector</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line">ans = sum_vect(a,b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递指针版本</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum_vect</span><span class="params">(<span class="keyword">const</span> struct <span class="built_in">vector</span> *, <span class="keyword">const</span> struct <span class="built_in">vector</span> *, struct <span class="built_in">vector</span> *)</span></span>;</span><br><span class="line">....</span><br><span class="line">sum_vect(&amp;a, &amp;b, &amp;ans);</span><br><span class="line"><span class="comment">// 另外，如果使用指针版本，程序员必须记住总和的地址应该是第1个参数还是第2个参数的地址。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>缺点1：较老版本的实现可能无法处理这样的代码</p>
</li>
<li><p>缺点2：传递结构浪费时间和存储空间。尤其是把大型结构传递给函数，而它只使 用结构中的一两个成员时特别浪费</p>
</li>
</ul>
<h3 id="结构中的字符数组和字符指针"><a href="#结构中的字符数组和字符指针" class="headerlink" title="结构中的字符数组和字符指针"></a>结构中的字符数组和字符指针</h3><p>到目前为止，我们在结构中都使用字符数组来储存字符串。是否可以使用指向 char 的指针来代替字符数组？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 20</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> first[LEN];</span><br><span class="line">  <span class="keyword">char</span> last[LEN]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pnames</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> * first;</span><br><span class="line">  <span class="keyword">char</span> * last;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">veep</span> = &#123;</span><span class="string">"Tilia"</span>, <span class="string">"Summbers"</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pnames</span> <span class="title">treas</span> = &#123;</span><span class="string">"Brad"</span>, <span class="string">"Fallingjaw"</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>对于struct names类型的结构变量veep，以上字符串都储存在结构内部， 结构总共要分配40字节储存姓名。然而，对于struct pnames类型的结构变量 treas，<strong>以上字符串储存在编译器储存常量的地方</strong>。结构本身只储存了两个地址，在我们的系统中共占16字节。尤其是，struct pnames结构不用为字符串分配任何存储空间。它使用的是储存在别处的字符串（如，字符串常量或数组中的字符串）。简而言之，在pnames结构变量中的指针应该只用来在程序中管理那些已分配和在别处分配的字符串。</p>
<p>我们看看这种限制在什么情况下出问题。考虑下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">accountant</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pnames</span> <span class="title">attorney</span>;</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Enter the last name of your accountant:"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, accountant.last);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Enter the last name of your attorney: "</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, attorney.last);  <span class="comment">// 这里有潜在危险</span></span><br></pre></td></tr></table></figure>

<p>就语法而言，这段代码没问题。但是，用户的输入储存到哪里去了？对于accountant，他的名储存在accountant结构变量的last成员中，该结构中有一个储存字符串的数组。<strong>对于attorney，scanf()把字符串放到attorney.last表示的地址上。由于这是未经初始化的变量，地址可以是任何值，因此程序可以把名放在任何地方。如果走运的话，程序不会出问题，至少暂时不会出问题，否则这一操作会导致程序崩溃</strong>。实际上，如果程序能正 常运行并不是好事，因为这意味着一个未被觉察的危险潜伏在程序中。</p>
<h3 id="结构、指针和malloc"><a href="#结构、指针和malloc" class="headerlink" title="结构、指针和malloc()"></a>结构、指针和malloc()</h3><p><strong>如果使用malloc()分配内存并使用指针储存该地址，那么在结构中使用指针处理字符串就比较合理</strong>。这种方法的优点是，可以请求malloc()为字符串分配合适的存储空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pnames</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> * first;</span><br><span class="line">  <span class="keyword">char</span> * last;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pnames</span> <span class="title">father</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pnames</span> <span class="title">attorney</span>;</span></span><br><span class="line">father.first (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">40</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">father.last (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">40</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br></pre></td></tr></table></figure>

<p><strong>要注意，first和last指向的两个字符串都不储存在结构中，它们储存在 malloc()分配的内存块中。</strong>在结构使用完毕后，要使用free()函数释放动态分配的内存块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(father.first);</span><br><span class="line"><span class="built_in">free</span>(father.last);</span><br></pre></td></tr></table></figure>



<h3 id="复合字面量和结构"><a href="#复合字面量和结构" class="headerlink" title="复合字面量和结构"></a>复合字面量和结构</h3><p>如果只需要一个临时结构值，复合字面量很好用。例如，可以使用复合字面量创建一个数组作为函数的参数或赋给另一个结构。语法是把类型名放在圆括号中，后面紧跟一个用花括号括起来的初始化列表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="class"><span class="keyword">struct</span> <span class="title">book</span>&#125;&#123;</span><span class="string">"The idiot"</span>, <span class="string">"Fyodor"</span>, <span class="number">6.99</span>&#125;;</span><br><span class="line">&#123;<span class="class"><span class="keyword">struct</span> <span class="title">names</span>&#125;&#123;</span><span class="string">"Jack"</span>, <span class="string">"Chan"</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>还可以把复合字面量作为函数的参数。如果函数接受一个结构，可以把复合字面量作为实际参数传递：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(struct book, struct book)</span></span>;</span><br><span class="line">sum(&#123;struct book&#125;&#123;<span class="string">"The idiot"</span>, <span class="string">"Fyodor"</span>, <span class="number">6.99</span>&#125;, &#123;struct book&#125;&#123;<span class="string">"Flower"</span>, <span class="string">"Mark"</span>, <span class="number">15.0</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>复合字面量在所有函数的外部，具有静态存储期；如果复合字面量在块中，则具有自动存储期。复合字面量和普通初始化列表的语法规则相同。这意味着，可以在复合字面量中使用指定初始化器。</p>
<h3 id="伸缩型-Flexible-数组成员-C99"><a href="#伸缩型-Flexible-数组成员-C99" class="headerlink" title="伸缩型(Flexible)数组成员(C99)"></a>伸缩型(Flexible)数组成员(C99)</h3><p>C99新增了一个特性：伸缩型数组成员（flexible array member），利用 这项特性声明的结构，其最后一个数组成员具有一些特性。</p>
<ul>
<li>该数组不会立即存在。</li>
<li>使用这个伸缩型数组成员可以编写合适的代码，就好像它确实存在并具有所需数目的元素一样。</li>
</ul>
<p>首先，声明一个伸缩型数组成员有如下规则：</p>
<ul>
<li><p>伸缩型数组成员必须是结构的最后一个成员；</p>
</li>
<li><p>结构中必须至少有一个成员；</p>
</li>
<li><p>伸缩数组的声明类似于普通数组，只是它的方括号中是空的</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flex</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> count;</span><br><span class="line">  <span class="keyword">double</span> average;</span><br><span class="line">  <span class="keyword">double</span> scores[];  <span class="comment">// 伸缩数组成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明一个struct flex类型的结构变量时，不能用scores做任何事，因为没有给这个数组预留存储空间。实际上，C99的意图并不是让你声明struct flex 类型的变量，而是希望你声明一个指向struct flex类型的指针，然后用 malloc()来分配足够的空间，以储存struct flex类型结构的常规内容和伸缩型 数组成员所需的额外空间。例如，假设用scores表示一个内含5个double类型 值的数组，可以这样做：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flex</span> * <span class="title">pf</span>;</span></span><br><span class="line">pf = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct flex) + <span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br></pre></td></tr></table></figure>

<p>现在有足够的存储空间储存count、average和一个内含5个double类型值 的数组。可以用指针pf访问这些成员：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pf-&gt;count = <span class="number">5</span>;</span><br><span class="line">pf-&gt;score[<span class="number">2</span>] = <span class="number">18.5</span>;</span><br></pre></td></tr></table></figure>

<p>下面的程序进一步扩展了这个例子，让伸缩型数组成员在第1种情况下表示5个值，在第2种情况下代表9个值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flex</span>&#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    <span class="keyword">double</span> average;</span><br><span class="line">    <span class="keyword">double</span> scores[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showFlex</span><span class="params">(<span class="keyword">const</span> struct flex * p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flex</span> * <span class="title">pf1</span>, *<span class="title">pf2</span>;</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pf1 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct flex) + n * <span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">    pf1-&gt;count = n;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pf1-&gt;scores[i] = <span class="number">20.0</span> - i;</span><br><span class="line">        tot += pf1-&gt;scores[i];</span><br><span class="line">    &#125;</span><br><span class="line">    pf1-&gt;average = tot / n;</span><br><span class="line">    showFlex(pf1);</span><br><span class="line"></span><br><span class="line">    n = <span class="number">9</span>;</span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">    pf2 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct flex) + n * <span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">    pf2-&gt;count = n;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pf2-&gt;scores[i] = <span class="number">20.0</span> - i/<span class="number">2.0</span>;</span><br><span class="line">        tot += pf2-&gt;scores[i];</span><br><span class="line">    &#125;</span><br><span class="line">    pf2-&gt;average = tot / n;</span><br><span class="line">    showFlex(pf2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showFlex</span><span class="params">(<span class="keyword">const</span> struct flex * p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Scores: "</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; p-&gt;count;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%g "</span>, p-&gt;scores[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nAverage: %g\n"</span>, p-&gt;average);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>带伸缩型数组成员的结构确实有一些特殊的处理要求：</p>
<ul>
<li>第一，不能用结构进行赋值或拷贝：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*pf2 = *pf1; <span class="comment">// 不允许</span></span><br></pre></td></tr></table></figure>

<ul>
<li>第二，不能以按值的方式把这种结构传递给函数，要把结构的地址传递给函数。</li>
<li>第三，不要使用带伸缩型数组成员的结构作为数组成员或另一个结构的 成员。</li>
</ul>
<h3 id="匿名结构-C11"><a href="#匿名结构-C11" class="headerlink" title="匿名结构(C11)"></a>匿名结构(C11)</h3><p>匿名结构是一个没有名称的结构成员。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> id;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span><span class="keyword">char</span> first[<span class="number">20</span>]; <span class="keyword">char</span> last[<span class="number">20</span>]&#125;; <span class="comment">// 匿名结构成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化方式与普通结构一样</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> <span class="title">ted</span> = &#123;</span><span class="number">8483</span>, &#123;<span class="string">"Ted"</span>, <span class="string">"Grace"</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>匿名结构的特征，就是简化了成员访问的步骤，只需要吧把first看作person成员那样使用它：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(ted.frist);</span><br></pre></td></tr></table></figure>



<h3 id="使用结构数组的函数"><a href="#使用结构数组的函数" class="headerlink" title="使用结构数组的函数"></a>使用结构数组的函数</h3><ul>
<li><p>可以把数组名作为数组中第1个结构的地址传递给函数。</p>
</li>
<li><p>可以用数组表示法访问数组中的其他结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">funds</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> bank[<span class="number">40</span>];</span><br><span class="line">  <span class="keyword">double</span> bankfund;</span><br><span class="line">  <span class="keyword">char</span> save[<span class="number">40</span>];</span><br><span class="line">  <span class="keyword">double</span> savefund;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> struct fund * money, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">funds</span> <span class="title">jones</span>[2] = &#123;</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"Jack"</span>,</span><br><span class="line">      <span class="number">1000.0</span>,</span><br><span class="line">      <span class="string">"Mark"</span>,</span><br><span class="line">      <span class="number">2000.0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"Teddy"</span>,</span><br><span class="line">      <span class="number">500.0</span>,</span><br><span class="line">      <span class="string">"Delores"</span>,</span><br><span class="line">      <span class="number">50000.0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  sum(jones, <span class="number">2</span>);</span><br><span class="line">  <span class="comment">// 等效 sum(&amp;jones[0], 2);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> struct funds meney[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">double</span> total;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    total += money[i].savefund + money[i].bankfund;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="联合-Union"><a href="#联合-Union" class="headerlink" title="联合(Union)"></a>联合(Union)</h2><p>联合（union）是一种数据类型，它能在同一个内存空间中储存不同的数据类型<strong>（不是同时储存）</strong>。其典型的用法是，设计一种表以储存既无规律、事先也不知道顺序的混合类型。使用联合类型的数组，其中的联合都大小相等，每个联合可以储存各种数据类型。</p>
<h3 id="创建联合"><a href="#创建联合" class="headerlink" title="创建联合"></a>创建联合</h3><p>创建联合和创建结构的方式相同，需要一个联合模板和联合变量。可以用一个步骤定义联合，也可以用联合标记分两步定义。下面是一个带标记的联合模板：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> hold &#123;</span><br><span class="line">  <span class="keyword">int</span> digit;</span><br><span class="line">  <span class="keyword">double</span> biglf;</span><br><span class="line">  <span class="keyword">char</span> letter;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>根据以上形式声明的结构可以储存一个int类型、一个double类型和char 类型的值。然而，声明的联合只能储存一个int类型的值或一个double类型的值或char类型的值。</strong></p>
<p>下面定义了3个hold类型相关变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> hold fit;       <span class="comment">// hold类型联合变量</span></span><br><span class="line"><span class="keyword">union</span> hold save[<span class="number">10</span>];  <span class="comment">// 内含10ge联合变量的数组</span></span><br><span class="line"><span class="keyword">union</span> hold * pu;      <span class="comment">// 指向hold类型联合变量的指针</span></span><br></pre></td></tr></table></figure>

<p>第1个声明创建了一个单独的联合变量fit。编译器分配足够的空间以便 它能储存联合声明中占用最大字节的类型。在本例中，占用空间最大的是double类型的数据。在我们的系统中，double类型占64位，即8字节。第2个 声明创建了一个数组save，内含10个元素，每个元素都是8字节。第3个声明创建了一个指针，该指针变量储存hold类型联合变量的地址。</p>
<h3 id="初始化联合"><a href="#初始化联合" class="headerlink" title="初始化联合"></a>初始化联合</h3><p>联合只能储存一个值，这与结构不同。有 3 种初始化的方法：把一个联合初始化为另一个同类型的联合；初始化联合的第1个元素；或者根据C99标准，使用指定初始化器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> hold valA;</span><br><span class="line">valA.letter = <span class="string">'R'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> hold valB = valA;            <span class="comment">// 用另一个联合初始化</span></span><br><span class="line"><span class="keyword">union</span> hold valC = &#123;<span class="number">88</span>&#125;;            <span class="comment">// 初始化联合的digit成员</span></span><br><span class="line"><span class="keyword">union</span> hold valD = &#123;.bigfl = <span class="number">18.2</span>&#125;  <span class="comment">// 指定初始化器</span></span><br></pre></td></tr></table></figure>



<h3 id="使用联合"><a href="#使用联合" class="headerlink" title="使用联合"></a>使用联合</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> hold fit;</span><br><span class="line">fit.digit = <span class="number">23</span>;     <span class="comment">// 把23储存在fit，占用4字节</span></span><br><span class="line">fit.bigfl = <span class="number">2.0</span>;    <span class="comment">// 清除23，储存2.0，占用8字节</span></span><br><span class="line">fit.letter = <span class="string">'h'</span>;   <span class="comment">// 清除2.0，储存h，占用1字节</span></span><br></pre></td></tr></table></figure>

<p>点运算符表示正在使用哪种数据类型。在联合中，一次只储存一个值。 即使有足够的空间，也不能同时储存一个char类型值和一个int类型值。编写 代码时要注意当前储存在联合中的数据类型。</p>
<p>和用指针访问结构使用<code>-&gt;</code>运算符一样，用指针访问联合时也要使用<code>-&gt;</code>运 算符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> hould *pu;</span><br><span class="line">pu = &amp;fit;</span><br><span class="line">x = pu-&gt;digit;</span><br></pre></td></tr></table></figure>

<p>联合的另一种用法是，在结构中储存与其成员有从属关系的信息。例如，假设用一个结构表示一辆汽车。如果汽车属于驾驶者，就要用一个结构 成员来描述这个所有者。如果汽车被租赁，那么需要一个成员来描述其租赁公司。可以用下面的代码来完成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">owner</span>&#123;</span></span><br><span class="line">  <span class="keyword">char</span> socsecurity[<span class="number">12</span>];</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">leasecompany</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">40</span>];</span><br><span class="line">  <span class="keyword">char</span> headquarter[<span class="number">40</span>];</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> data&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">owner</span> <span class="title">owcar</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">leasecompany</span> <span class="title">leasecar</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">car_data</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> make[<span class="number">15</span>];</span><br><span class="line">  <span class="keyword">int</span> status; <span class="comment">//0 = owned, 1=leased</span></span><br><span class="line">  <span class="keyword">union</span> data ownerinfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设flits是car_data类型的结构变量，如果flits.status为0，程序将使用 flits.ownerinfo.owncar.socsecurity，如果flits.status为1，程序则使用 flits.ownerinfo.leasecar.name。</p>
<h3 id="匿名联合-C11"><a href="#匿名联合-C11" class="headerlink" title="匿名联合(C11)"></a>匿名联合(C11)</h3><p>匿名联合和匿名结构的工作原理相同，即匿名联合是一个结构或联合的 无名联合成员。例如，我们重新定义car_data结构如下：’’</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">owner</span>&#123;</span></span><br><span class="line">  <span class="keyword">char</span> socsecurity[<span class="number">12</span>];</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">leasecompany</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">40</span>];</span><br><span class="line">  <span class="keyword">char</span> headquarter[<span class="number">40</span>];</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">car_data</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> make[<span class="number">15</span>];</span><br><span class="line">  <span class="keyword">int</span> status; <span class="comment">//0 = owned, 1=leased</span></span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">owner</span> <span class="title">owncar</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">leasecompany</span> <span class="title">leasecar</span>;</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在，如果 flits 是car_data 类型的结构变量，可以用flits.owncar.socsecurity代替flits.ownerinfo.owncar.socsecurity。</p>
<h2 id="枚举-Enumerated-类型"><a href="#枚举-Enumerated-类型" class="headerlink" title="枚举(Enumerated)类型"></a>枚举(Enumerated)类型</h2><p>可以用枚举类型（enumerated type）<strong>声明符号名称来表示整型常量</strong>。使用enum关键字，可以创建一个新“类型”并指定它可具有的值（实际上，enum 常量是int类型，因此，只要能使用int类型的地方就可以使用枚举类型）。枚举类型的目的是提高程序的可读性。它的语法与结构的语法相同。例如，可以这样声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> spectrum &#123;red, orange, yellow, green, blue, violet&#125;;  <span class="comment">// 声明枚举类型，以spectrum为tag</span></span><br><span class="line"><span class="keyword">enum</span> spectrum color;                                       <span class="comment">// 创建枚举变量</span></span><br></pre></td></tr></table></figure>

<p>color可能的值是 red、 orange、yellow 等。这些符号常量被称为枚举符（enumerator）。</p>
<p>虽然枚举符（如red和blue）是int类型，但是枚举变量可以是任意整数类型，前提是该整数类型可以储存枚举常量。例如，spectrum的枚举符范围是 0～5，所以编译器可以用unsigned char来表示color变量。</p>
<blockquote>
<p><strong>C和C++的枚举</strong></p>
<p>C枚举的一些特性并不适用于C++。例如，C允许枚举变量 使用++运算符，但是C++标准不允许。所以，如果编写的代码将来会并入 C++程序，那么必须把上面例子中的color声明为int类型，才能C和C++都兼 容。</p>
</blockquote>
<h3 id="enum常量"><a href="#enum常量" class="headerlink" title="enum常量"></a>enum常量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> spectrum &#123;red, orange, yellow, green, blue, violet&#125;;</span><br></pre></td></tr></table></figure>

<p>red，orange本质是int类型常量，但他们是“有名称”的常量，只要是能使用整型常量的地方就可以使用枚举常 量。例如，在声明数组时，可以用枚举常量表示数组的大小；在switch语句 中，可以把枚举常量作为标签。</p>
<h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>默认情况下，枚举列表中的常量都被赋予0、1、2等。因此，下面的声 明中nina的值是3：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> kids&#123;nippy, slats, skippy, nina, liz&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>在枚举声明中，可以为枚举常量指定整数值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> levels &#123;low = <span class="number">100</span>, medium = <span class="number">500</span>, high = <span class="number">2000</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>如果只给一个枚举常量赋值，没有对后面的枚举常量赋值，那么后面的常量会被赋予后续的值。例如，假设有如下的声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> feline &#123;cat, lynx = <span class="number">10</span>, puma, tiger&#125;;</span><br></pre></td></tr></table></figure>

<p>那么，cat的值是0（默认），lynx、puma和tiger的值分别是10、11、 12。</p>
<h3 id="enum的用法"><a href="#enum的用法" class="headerlink" title="enum的用法"></a>enum的用法</h3><p>枚举类型的目的是为了提高程序的可读性和可维护性。如果要处理颜色，使用red和blue比使用0和1更直观。注意，枚举类型只能在内部使用。如果要输入color中orange的值，只能输入1，而不是单词orange。或者，让程序 先读入字符串”orange”，再将其转换为orange代表的值。</p>
<p>因为枚举类型是整数类型，所以可以在表达式中以使用整数变量的方式 使用enum变量。它们用在case语句中很方便。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> spectrum &#123;red, orange, yellow, green, blue, violet&#125;;</span><br><span class="line"><span class="keyword">enum</span> spectrum color;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (color)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> red: <span class="built_in">puts</span>(<span class="string">"Rose are red"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> yellow: <span class="built_in">puts</span>(<span class="string">"Sunflower are yellow"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> green: <span class="built_in">puts</span>(<span class="string">"Grass is green"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> blue: <span class="built_in">puts</span>(<span class="string">"Bluebells are blue"</span>);</span><br><span class="line">   	<span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> violet: <span class="built_in">puts</span>(<span class="string">"Violets are violet"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="共享名称空间"><a href="#共享名称空间" class="headerlink" title="共享名称空间"></a>共享名称空间</h2><p>C语言使用名称空间（namespace）标识程序中的各部分，即通过名称来识别。名称空间是分类别的。在特定作用域中的结构标记、联合标记和枚举标记都共享相同的名称空间，该名称空间与普通变量使用的空间不同。这意味着在相同作用域中变量和标记的名称可以相同，不会引起冲突，但是不能在相同作用域中声明两个同名标签或同名变量。例如，在C中，下面的代码不会产生冲突：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rect</span>&#123;</span><span class="keyword">double</span> x; <span class="keyword">double</span> y;&#125;;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">rect</span>; <span class="comment">// 在C中不会产生冲突</span></span><br></pre></td></tr></table></figure>



<h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><p>typedef工具是一个高级数据特性，利用typedef可以为某一类型自定义名称。这方面与#define类似，但是两者有3处不同：</p>
<ul>
<li>与#define不同，typedef创建的符号名只受限于类型，不能用于值。</li>
<li>typedef由编译器解释，不是预处理器。</li>
<li>在其受限范围内，typedef比#define更灵活。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE;  <span class="comment">// 像定义char类型变量一样定义BYTE</span></span><br><span class="line">BYTE x, y[<span class="number">10</span>], *z            <span class="comment">// 便可使用BYTE来定义变量</span></span><br></pre></td></tr></table></figure>

<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>该定义的作用域取决于typedef定义所在的位置。如果定义在函数中，就 具有局部作用域，受限于定义所在的函数。如果定义在函数外面，就具有文件作用域。</p>
<h3 id="define的缺陷"><a href="#define的缺陷" class="headerlink" title="#define的缺陷"></a>#define的缺陷</h3><p>typedef的一些特性与#define的功能重合。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BYTE unsigned char</span></span><br><span class="line">BTYE x;  <span class="comment">// 预处理器把BYTE替换为unsigned char,因此x为unsigned char类型</span></span><br></pre></td></tr></table></figure>

<p>但是，使用#define实现以上功能以下问题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STRING char *</span></span><br><span class="line">STRING name, sign; <span class="comment">//预处理翻译为 char * name, sign，因此name是pointer-to-char，而sign是char</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<p>使用typedef时要记住，typedef并没有创建任何新类型，它只是为某个已存在的类型增加了一个方便使用的标签。</p>
<h3 id="多重typedef"><a href="#多重typedef" class="headerlink" title="多重typedef"></a>多重typedef</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arr5[<span class="number">5</span>];         </span><br><span class="line"><span class="keyword">typedef</span> arr5 *p_arr5;</span><br><span class="line"><span class="keyword">typedef</span> p_arr5 arrp10[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">arr5 togs;  <span class="comment">// togs是一个含有5个int元素的数组</span></span><br><span class="line">p_arr5 p2;  <span class="comment">// p2是一个指向含有5个int元素的数组的指针</span></span><br><span class="line">arrp10 ap;  <span class="comment">// ap是一个含有10个指针的数组，每个指针指向一个含有5个int元素的数组</span></span><br></pre></td></tr></table></figure>



<h2 id="函数的指针"><a href="#函数的指针" class="headerlink" title="函数的指针"></a>函数的指针</h2><p>函数也有地址，因为函数的机器语言实现由载入内存的代码组成。指向函数的指针中储存着函数代码的起始处的地址。声明一个数据指针时，必须声明指针所指向的数据类型。声明一个函数指针时，必须声明指针指向的函数类型。为了指明函数类型，要指明函数签名，即函数的返回类型和形参类型。例如，考虑下面的函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ToUpper</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br></pre></td></tr></table></figure>

<p>ToUpper()函数的类型是“带char * 类型参数、返回类型是void的函数”。 下面声明了一个指针pf指向该函数类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*pf)(<span class="keyword">char</span> ());  <span class="comment">// pf 是一个指向函数的指针</span></span><br></pre></td></tr></table></figure>

<p>从该声明可以看出，第1对圆括号把和pf括起来，表明pf是一个指向函数的指针。因此，<code>(*pf)</code>是一个参数列表为<code>(char *)</code>、返回类型为<code>void</code>的函数。</p>
<p> <strong>注意，把函数名ToUpper替换为表达式<code>(*pf)</code>是创建指向函数指针最简单的方式。所以，如果想声明一个指向某类型函数的指针，可以写出该函数的原型 后把函数名替换成<code>(*pf)</code>形式的表达式，创建函数指针声明。</strong></p>
<p>声明了函数指针后，可以把类型匹配的函数地址赋给它。函数名可以用于表示函数的地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ToUpeer</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ToLower</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">round</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">void</span> (*pf)(<span class="keyword">char</span> *);</span><br><span class="line"></span><br><span class="line">pf = ToUpper;    <span class="comment">// 有效</span></span><br><span class="line">pf = ToLower;    <span class="comment">// 有效</span></span><br><span class="line">pf = round;      <span class="comment">// 无效，round与指针类型不匹配</span></span><br><span class="line">pf = ToLower();  <span class="comment">// 无效，ToLower()不是地址</span></span><br></pre></td></tr></table></figure>

<p>最后一条语句是无效的，不仅因为 ToLower()不是地址，而且ToLower()的返回类型是 void，它没有返回值，不能在赋值语句中进行赋值。</p>
<h3 id="两种函数指针访问函数的方法"><a href="#两种函数指针访问函数的方法" class="headerlink" title="两种函数指针访问函数的方法"></a>两种函数指针访问函数的方法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ToUpper</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ToLower</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="keyword">void</span> (*pf)(<span class="keyword">char</span> *);</span><br><span class="line"><span class="keyword">char</span> mis[] = <span class="string">"Nina Metier"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种</span></span><br><span class="line">pf = ToUpper;</span><br><span class="line">(*pf)(mis);</span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line">pf = ToLower;</span><br><span class="line">pf(mis);</span><br></pre></td></tr></table></figure>

<p>这两种方法看上去互相矛盾，但是又合情合理。</p>
<ul>
<li>第一种方法：由于<code>pf</code>指向ToUpper 函数，那么<code>(*pf</code>)就相当于ToUpper函数，所以表达式<code>(*pf)(mis)</code>和<code>ToUpper(mis)</code> 相同</li>
<li>第二种方法：由于函数名是指针，那么指针和函数名可以互换使用，所以pf(mis) 和ToUpper(mis)相同</li>
</ul>
<p>由于历史的原因，贝尔实验室的C和UNIX的开发者采用第1种形式，而伯克利的UNIX推广者却采用第2种形式。K&amp;R C不允许第2种形式。但是，为了与现有代码兼容，ANSI C认为这两种形式（本例中是(*pf)(mis)和 pf(mis)）等价。后续的标准也延续了这种矛盾的和谐。</p>
<h3 id="作为函数的形式参数"><a href="#作为函数的形式参数" class="headerlink" title="作为函数的形式参数"></a>作为函数的形式参数</h3><p>作为函数的参数是数据指针最常见的用法之一，函数指针亦如此。例如，考虑下面的函数原型和定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">void</span> (* fp)(<span class="keyword">char</span> *), <span class="keyword">char</span> * str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">void</span> (*fp)(<span class="keyword">char</span> *), <span class="keyword">char</span> * str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  (*pf)(mis);</span><br><span class="line">  <span class="built_in">puts</span>(mis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它声明了两个形参：fp和str。fp形参是一个函数指针，str是一个数据指针。更具体地说，fp指向的函数接受char * 类型的参数，其返回类型为void；str指向一个char类型的值。因此，假设有上面的声明，可以这样调用函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show(ToLower, mis);</span><br><span class="line">show(pf, mis)        <span class="comment">// pf = ToLower;</span></span><br></pre></td></tr></table></figure>

<p>还可以使用typedef简化一下复杂的函数原型和函数头</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*V_FP_CHAR)</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(V_FP_CHAR fp, <span class="keyword">char</span> * str)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="函数指针的数组"><a href="#函数指针的数组" class="headerlink" title="函数指针的数组"></a>函数指针的数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*V_FP_CHAR)</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line">V_FP_CHAR pf_arr[<span class="number">4</span>] = &#123;TuUpper, ToLower, Transpose, Dummy&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="复杂的声明"><a href="#复杂的声明" class="headerlink" title="复杂的声明"></a>复杂的声明</h2><p>C 允许用户自定义数据形式。虽然我们常用的是一些简单的形式，但是 根据需要有时还会用到一些复杂的形式。在一些复杂的声明中，常包含下面的符号，如表14.1所示：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>表示一个指针</td>
</tr>
<tr>
<td>()</td>
<td>表示一个函数</td>
</tr>
<tr>
<td>[]</td>
<td>表示一个数组</td>
</tr>
</tbody></table>
<p>*、()和[]的优先级</p>
<ul>
<li><p>数组名后面的[]和函数名后面的()具有相同的优先级。它们比*（解引用运算符）的优先级高。因此下面声明的risk是一个指针数组，不是指向数组的指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *risk[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>[]和()的优先级相同，由于都是从左往右结合，所以下面的声明中，在应用方括号之前，*先与rusks结合。因此rusks是一个指向数组的指针，该数组内含10个int类型的元素：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*rusks)[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>[]和()都是从左往右结合。因此下面声明的goods是一个由12个内含50 个int类型值的数组组成的二维数组，不是一个有50个内含12个int类型值的数组组成的二维数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> goods[<span class="number">12</span>][<span class="number">50</span>];</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *off[<span class="number">3</span>][<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<p>[3]比<code>*</code>的优先级高，由于从左往右结合，所以[3]先与oof结合。因此， oof首先是一个内含3个元素的数组。然后再与[4]结合，所以oof的每个元素 都是内含4个元素的数组。*说明这些元素都是指针。最后，int表明了这4个元素都是指向int的指针。因此，这条声明要表达的是：foo是一个内含3个元素的数组，其中每个元素是由4个指向int的指针组成的数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*uuf)[<span class="number">3</span>][<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<p>圆括号使得*先与uuf结合，说明uuf是一个指针，所以uuf是一个指向3×4，的int类型二维数组的指针。编译器要为一个指针预留存储空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*uof[<span class="number">3</span>])[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<p>一个内含3个指针元素的数组，其中每个指针都指向一个内含4个int类型元素的数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">fump</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>返回字符指针的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> (*frump)(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>

<p>指向函数的指针，该函数的返回类型为char,参数类型为int。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> (* flump[<span class="number">3</span>])(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>

<p>内含三个指向函数指针的数组，函数的返回值类型为char，参数类型为int</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/06/13/%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA/" rel="prev" title="文件输入和输出">
      <i class="fa fa-chevron-left"></i> 文件输入和输出
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/06/13/%E5%82%A8%E5%AD%98%E7%B1%BB%E5%9E%8B%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="next" title="储存类型、链接和内存管理">
      储存类型、链接和内存管理 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#结构-structure"><span class="nav-number">1.</span> <span class="nav-text">结构(structure)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#建立结构声明"><span class="nav-number">1.1.</span> <span class="nav-text">建立结构声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化结构变量"><span class="nav-number">1.2.</span> <span class="nav-text">初始化结构变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问结构成员"><span class="nav-number">1.3.</span> <span class="nav-text">访问结构成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结构之间赋值"><span class="nav-number">1.4.</span> <span class="nav-text">结构之间赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结构数组"><span class="nav-number">1.5.</span> <span class="nav-text">结构数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#嵌套结构"><span class="nav-number">1.6.</span> <span class="nav-text">嵌套结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指向结构的指针"><span class="nav-number">1.7.</span> <span class="nav-text">指向结构的指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#声明结构指针"><span class="nav-number">1.7.1.</span> <span class="nav-text">声明结构指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用指针访问结构成员"><span class="nav-number">1.7.2.</span> <span class="nav-text">用指针访问结构成员</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#向函数传递结构信息"><span class="nav-number">1.8.</span> <span class="nav-text">向函数传递结构信息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#传递结构成员"><span class="nav-number">1.8.1.</span> <span class="nav-text">传递结构成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#传递结构的地址"><span class="nav-number">1.8.2.</span> <span class="nav-text">传递结构的地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#传递结构"><span class="nav-number">1.8.3.</span> <span class="nav-text">传递结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#结构作为返回值"><span class="nav-number">1.8.4.</span> <span class="nav-text">结构作为返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数中结构和结构指针的选择"><span class="nav-number">1.8.5.</span> <span class="nav-text">函数中结构和结构指针的选择</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结构中的字符数组和字符指针"><span class="nav-number">1.9.</span> <span class="nav-text">结构中的字符数组和字符指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结构、指针和malloc"><span class="nav-number">1.10.</span> <span class="nav-text">结构、指针和malloc()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复合字面量和结构"><span class="nav-number">1.11.</span> <span class="nav-text">复合字面量和结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#伸缩型-Flexible-数组成员-C99"><span class="nav-number">1.12.</span> <span class="nav-text">伸缩型(Flexible)数组成员(C99)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#匿名结构-C11"><span class="nav-number">1.13.</span> <span class="nav-text">匿名结构(C11)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用结构数组的函数"><span class="nav-number">1.14.</span> <span class="nav-text">使用结构数组的函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#联合-Union"><span class="nav-number">2.</span> <span class="nav-text">联合(Union)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建联合"><span class="nav-number">2.1.</span> <span class="nav-text">创建联合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化联合"><span class="nav-number">2.2.</span> <span class="nav-text">初始化联合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用联合"><span class="nav-number">2.3.</span> <span class="nav-text">使用联合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#匿名联合-C11"><span class="nav-number">2.4.</span> <span class="nav-text">匿名联合(C11)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#枚举-Enumerated-类型"><span class="nav-number">3.</span> <span class="nav-text">枚举(Enumerated)类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#enum常量"><span class="nav-number">3.1.</span> <span class="nav-text">enum常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#默认值"><span class="nav-number">3.2.</span> <span class="nav-text">默认值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#赋值"><span class="nav-number">3.3.</span> <span class="nav-text">赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#enum的用法"><span class="nav-number">3.4.</span> <span class="nav-text">enum的用法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#共享名称空间"><span class="nav-number">4.</span> <span class="nav-text">共享名称空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#typedef"><span class="nav-number">5.</span> <span class="nav-text">typedef</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#作用域"><span class="nav-number">5.1.</span> <span class="nav-text">作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#define的缺陷"><span class="nav-number">5.2.</span> <span class="nav-text">#define的缺陷</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多重typedef"><span class="nav-number">5.3.</span> <span class="nav-text">多重typedef</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数的指针"><span class="nav-number">6.</span> <span class="nav-text">函数的指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#两种函数指针访问函数的方法"><span class="nav-number">6.1.</span> <span class="nav-text">两种函数指针访问函数的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作为函数的形式参数"><span class="nav-number">6.2.</span> <span class="nav-text">作为函数的形式参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数指针的数组"><span class="nav-number">6.3.</span> <span class="nav-text">函数指针的数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#复杂的声明"><span class="nav-number">7.</span> <span class="nav-text">复杂的声明</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#例子"><span class="nav-number">7.1.</span> <span class="nav-text">例子</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">崔梓坤</p>
  <div class="site-description" itemprop="description">我的计算机学习经历和笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">崔梓坤</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
