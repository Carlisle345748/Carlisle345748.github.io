<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="存储类型标识符程序需要一种方法访问储存在内存中的数据对象(object)，这可以通过声明变量来完成： 1int entity &#x3D; 3;  该声明创建了一个名为entity的标识符（identifier）。标识符是一个名称，可以用来指定（designate）特定对象的内容。该声明还提供了储存在对象中的值(3)。 变量名不是指定对象的唯一途径。考虑下面的声明： 12int * pt &#x3D; &amp;en">
<meta property="og:type" content="article">
<meta property="og:title" content="储存类型、链接和内存管理">
<meta property="og:url" content="http://yoursite.com/2020/06/13/%E5%82%A8%E5%AD%98%E7%B1%BB%E5%9E%8B%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/index.html">
<meta property="og:site_name" content="崔梓坤的个人博客">
<meta property="og:description" content="存储类型标识符程序需要一种方法访问储存在内存中的数据对象(object)，这可以通过声明变量来完成： 1int entity &#x3D; 3;  该声明创建了一个名为entity的标识符（identifier）。标识符是一个名称，可以用来指定（designate）特定对象的内容。该声明还提供了储存在对象中的值(3)。 变量名不是指定对象的唯一途径。考虑下面的声明： 12int * pt &#x3D; &amp;en">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/Carlisle345748/cloudimg/raw/master/img/5%E7%A7%8D%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB.png">
<meta property="article:published_time" content="2020-06-13T10:28:00.000Z">
<meta property="article:modified_time" content="2020-06-13T10:28:25.491Z">
<meta property="article:author" content="崔梓坤">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/Carlisle345748/cloudimg/raw/master/img/5%E7%A7%8D%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB.png">

<link rel="canonical" href="http://yoursite.com/2020/06/13/%E5%82%A8%E5%AD%98%E7%B1%BB%E5%9E%8B%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>储存类型、链接和内存管理 | 崔梓坤的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">崔梓坤的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/13/%E5%82%A8%E5%AD%98%E7%B1%BB%E5%9E%8B%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="崔梓坤">
      <meta itemprop="description" content="我的计算机学习经历和笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="崔梓坤的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          储存类型、链接和内存管理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-13 18:28:00 / 修改时间：18:28:25" itemprop="dateCreated datePublished" datetime="2020-06-13T18:28:00+08:00">2020-06-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="存储类型"><a href="#存储类型" class="headerlink" title="存储类型"></a>存储类型</h2><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>程序需要一种方法访问储存在内存中的数据对象(object)，这可以通过声明变量来完成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> entity = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>该声明创建了一个名为<code>entity</code>的<strong>标识符（identifier）</strong>。标识符是一个名称，可以用来指定（designate）特定对象的内容。该声明还提供了储存在对象中的值(3)。</p>
<p>变量名不是指定对象的唯一途径。考虑下面的声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * pt = &amp;entity;</span><br><span class="line"><span class="keyword">int</span> ranks[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p><code>pt</code>是一个标识符，它指定了一个储存地址的对象。但是，表达式<code>*pt</code>不是标识符，因为它不是一个名称。然而，它确实指定了一 个对象，在这种情况下，它与 entity 指定的对象相同。一般而言，那些指定对象的表达式被称为左值(lvalue)，所以，<code>entity</code>既是标识符也是左值；<code>*pt</code>既是表达式也是左值。</p>
<h3 id="作用域、链接、储存期"><a href="#作用域、链接、储存期" class="headerlink" title="作用域、链接、储存期"></a>作用域、链接、储存期</h3><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p><strong>作用域描述程序中可访问标识符的区域</strong>。一个C变量的作用域可以是块作用域(花括号括起来的代码区域})、函数作用域、函数原型作用域或文件作用域(file scope)。</p>
<ul>
<li><p>块作用域</p>
<p>花括号{}括起来的代码区域属于一个块，比如复合语句(compound statement)。C99把块的概念扩展到包括for循环、while循环、 do while循环和if语句所控制的代码，即使这些代码没有用花括号括起来， 也算是块的一部分。<strong>注意：对于for、while、if等块，其判断语句是一个块，而其循环体是其子块。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)  <span class="comment">// 判断语句本身是一个块</span></span><br><span class="line">&#123;</span><br><span class="line">  	<span class="comment">// 循环体是判断语句这个块的子块</span></span><br><span class="line">  	count += <span class="number">1</span>;</span><br><span class="line">  	totoal += arr[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"This is also a block"</span>);   <span class="comment">// C99中在while、for、do while中即使没有花括号也算作块</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数原型作用域</p>
<p>函数原型作用域的范围是从<strong>形参定义处到原型声明结束</strong>。这意味着，<strong>编译器在处理函数原型中的形参时只关心它的类型，而形参名（如果有的话） 通常无关紧要</strong>。而且，即使有形参名，也不必与函数定义中的形参名相匹 配。<strong>只有在变长数组(VLA)中，形参名才有用</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mighty</span><span class="params">(<span class="keyword">int</span> mouse, <span class="keyword">double</span> large)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use_a_VLA</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, ar[n][m])</span></span>;  <span class="comment">// VLA</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>文件作用域(file scope)</p>
<p>变量的定义在函数的外面，具有文件作用域（file scope），所谓的“文件”是指一个源代码(.c)文件。具有文件作用域的变量，从它的定义处到该定义所在文件的末尾均可见。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="keyword">int</span> unit = <span class="number">0</span>;   <span class="comment">// unit具有文件作用域, main和func都可以使用它</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">voud <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<blockquote>
<p><strong>翻译单元(translation unit)和文件</strong></p>
<p>多个文件在编译器中可能以一个文件出现。例如，通常在源代码（.c扩展名）中包含一个或多个头文件（.h 扩展名）。头文件会依次包含其他头文件，所以会包含多个单独的物理文件。但是，C预处理实际上是用包含的头文件内容替换#include指令。所以，编译器源代码文件和所有的头文件都看成是一个包含信息的单独文件。这个文件被称为翻译单元 （translation unit）。描述一个具有文件作用域的变量时，它的实际可见范围 是整个翻译单元。如果程序由多个源代码文件组成，那么该程序也将由多个翻译单元组成。每个翻译单元均对应一个源代码文件和它所包含的文件。</p>
</blockquote>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>C 变量有 3 种链接属性：外部链接、内部链接或无链接。</p>
<ul>
<li>外部链接：包含“外部链接”和“文件作用域”的变量可以在其他源代码文件中使用。</li>
<li>内部链接：包含“内部链接”和“文件作用域”的变量可以在当前源代码文件中使用。</li>
<li>无链接：无链接的变量只能在作用域内的局部使用的，在各种函数和块中定义的变量为无链接变量。</li>
</ul>
<h4 id="储存期"><a href="#储存期" class="headerlink" title="储存期"></a>储存期</h4><p>作用域和链接描述了标识符的可见性。存储期描述了通过这些标识符访问的对象的生存期(duration)。C对象有4种存储期：<strong>静态存储期(static)、线程存储期(thread)、自动存储期(automatic)、动态分配(allocated)存储期</strong>。</p>
<ul>
<li><p>静态存储期</p>
<p>如果对象具有静态存储期，那么它在程序的执行期间一直存在。文件作用域变量具有静态存储期。</p>
</li>
<li><p>线程存储期</p>
<p>线程存储期用于并发程序设计，程序执行可被分为多个线程。具有线程存储期的对象，从被声明时到线程结束一直存在。以关键字<code>_Thread_local</code>声明一个对象时，每个线程都获得该变量的私有备份。</p>
</li>
<li><p>自动存储期</p>
<p>在块中不带存储类别说明符或带 auto 存储类别说明符声明的变量（或作为函数头中的形参）属于自动存储类别。所有函数、块内的局部变量都是自动存储期，在函数运行时创建，函数结束后自动销毁。</p>
</li>
<li><p>动态分配存储期</p>
<p>使用malloc()或calloc()函数分配空间的对象，在创建之后，直到使用free()函数后才会被销毁。</p>
</li>
</ul>
<p>​    </p>
<h3 id="储存类别"><a href="#储存类别" class="headerlink" title="储存类别"></a>储存类别</h3><p>C语言中有5种存储列别，分别有不同的作用域、存储期、链接和声明方式。</p>
<p><img src="https://gitee.com/Carlisle345748/cloudimg/raw/master/img/5%E7%A7%8D%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB.png" alt=""></p>
<h4 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h4><p>默认情况下，声明在块或函数头中的任何变量都属于自动变量，具有自动存储期、块作用域且无链接的特征。**</p>
<ul>
<li><strong>块作用域和无链接意味着只有在变量定义所在的块中才能通过标识符访问该变量</strong>。另一个函数可以使用同名变量，但是该变量是储存在不同内存位置上的另一个变量。</li>
<li><strong>自动存储期意味着，程序在进入该变量声明所在的块时变量存在，程序在退出该块时变量消失</strong>，原来该变量占用的内存位置现在可做他用。</li>
</ul>
<p>为了更清楚地表达你的意图（例如，为了表明有意覆盖一个外部变量定义，或者强调不要把该变量改为其他存储类别），可以显式使用关键字<code>auto</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> <span class="keyword">int</span> var1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>C和C++中的auto</strong></p>
<p>关键字auto是存储类别说明符（storage-class specifier）。auto关键字在 C++中的用法完全不同，如果编写C/C++兼容的程序，最好不要使用auto作为存储类别说明符。</p>
</blockquote>
<ol>
<li>如果内层块中声明的变量与外层块中的变量同名，内层块会隐藏外层块的定义。但是离开内层块后，外层块变量的作用域又回到了原来的作用域，下面的代码演示了上述过程。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;  <span class="comment">// 第一个i在main函数内</span></span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">"i = %d address %p \n"</span>, i, &amp;i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i  = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)  <span class="comment">// 第二个i在for(....)这个块里</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i = %d  address = %p\n"</span>, i, &amp;i);  <span class="comment">// 这里还是for()里面的第二个i</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">30</span>; <span class="comment">// 第三个i在for的循环体子块内</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i = %d  address = %p\n"</span>, i, &amp;i);  <span class="comment">// 第三个i</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i = %d address %p \n"</span>, i, &amp;i);  <span class="comment">// 第一个i</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">i = 10 address 0x7ffee190c618 </span></span><br><span class="line"><span class="comment">i = 0  address = 0x7ffee1463614</span></span><br><span class="line"><span class="comment">i = 30  address = 0x7ffee1463610</span></span><br><span class="line"><span class="comment">i = 1  address = 0x7ffee1463614</span></span><br><span class="line"><span class="comment">i = 30  address = 0x7ffee1463610</span></span><br><span class="line"><span class="comment">i = 2  address = 0x7ffee1463614</span></span><br><span class="line"><span class="comment">i = 30  address = 0x7ffee1463610</span></span><br><span class="line"><span class="comment">i = 10 address 0x7ffee1463618 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>首先，在<code>main</code>函数中创建并初始化了第一个<code>i=10</code>。然后在for (int i = 0; i &lt; 3; i++)中创建了第二个<code>i=0</code>，并且在for的循环体中创建了第三个<code>i=30</code>。<strong>注意，for、while、if等语句，for、while和括号内的判断条件是一个块，而循环体是其子块。</strong>所以，第三个变量只定义在for循环体子块中，printf()中<code>i=30</code>，每轮迭代结束，新的第三个<code>i</code>变量就消失。然后循环的测试条件使用并递增第二个的<code>i</code>。所以，在循环过程中，第三个<code>i</code>被重复创建和销毁了3次。</p>
<ol start="2">
<li>自动变量的不会自动初始化，除非显式初始化它。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> repid;      <span class="comment">// 未初始化，repid是原有的垃圾值</span></span><br><span class="line"><span class="keyword">int</span> tents = <span class="number">5</span>;  <span class="comment">// 显式初始化，tents的值为5</span></span><br></pre></td></tr></table></figure>



<h4 id="寄存器变量"><a href="#寄存器变量" class="headerlink" title="寄存器变量"></a>寄存器变量</h4><p>在块中带 register 存储类别说明符声明的变量（或作为函数头中的形参）属于寄存器存储类别，具有自动存储期、块作用域、无链接， <strong>且无法获取其地址</strong>。把一个变量声明为寄存器变量即请求编译器将其储存到访问速度最快的区域。如果未初始化寄存器变量，它的值是未定义的。</p>
<p>声明寄存器变量更像一种“请求”，而不是一定成功的。编译器必须根据寄存器或最快可用内存的数量衡量你的请求，或者直接忽略你的请求，所以可能不会如你所愿。在这种情况下， 寄存器变量就变成普通的自动变量。即使是这样，仍然不能对该变量使用地址运算符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">macho</span><span class="params">(<span class="keyword">register</span> <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">register</span> <span class="keyword">int</span> quick;       <span class="comment">// 声明寄存器变量</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">macho</span><span class="params">(<span class="keyword">register</span> <span class="keyword">int</span> n)</span>  <span class="comment">// 在函数头中使用关键字register，便可请求形参是寄存器变量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="块作用域的静态变量"><a href="#块作用域的静态变量" class="headerlink" title="块作用域的静态变量"></a>块作用域的静态变量</h4><p>块作用域中定义的静态变量和自动变量一样，具有相同的作用域，但是程序离开它们所在的函数后，这些变量不会消失。也就是说，这种变量具有块作用域、无链接，但是具有静态存储期。计算机在多次函数调用之间会记录它们的值。在块中（提供块作用域和无链接）以存储类别说明符static声明这种变量。如果未显式初始化静态变量，它们会被初始化为0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_tryrstat</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Here comes interation %d: "</span>, i);</span><br><span class="line">        my_tryrstat();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_tryrstat</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fade = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> stay = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fade = %d and stay = %d\n"</span>, fade++, stay++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Here comes interation 1: fade = 1 and stay = 1</span></span><br><span class="line"><span class="comment">Here comes interation 2: fade = 1 and stay = 2</span></span><br><span class="line"><span class="comment">Here comes interation 3: fade = 1 and stay = 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>静态变量stay保存了它被递增1后的值，但是fade变量每次都是1。这表明了初始化的不同：每次调用trystat()都会初始化fade，但是stay只在编译 my_tryrstat()时被初始化一次，静态变量在程序被载入内存时已执行完毕，这条声明并未在运行时执行。</p>
<p><strong>注意: 不能在函数头的形参中使用static：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wontwork</span><span class="params">(<span class="keyword">static</span> <span class="keyword">int</span> flu)</span></span>; <span class="comment">// 不允许</span></span><br></pre></td></tr></table></figure>

<p><strong>声明具有静态变量时，必须使用常量表达式，不可使用变量</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> m = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> x = m;  <span class="comment">// 不允许，x是变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="外部链接的静态变量"><a href="#外部链接的静态变量" class="headerlink" title="外部链接的静态变量"></a>外部链接的静态变量</h4><p><strong>把变量的定义性声明（defining declaration）放在在所有函数的外面便创建了外部变量。</strong>外部链接的静态变量具有文件作用域、外部链接和静态存储期。该类别有时称为外部存储类别（external storage class），属于该类别的变量称为外部变量（external variable）。外部链接的静态变量拥有文件作用域，对所有函数都可见。</p>
<ul>
<li><p><strong>函数内引用式声明</strong>：在同一个源代码文件中定义了外部链接的静态变量，也可以在函数内使用<code>extern</code>关键字再次“声明”该变量，但是这个声明可以完全忽略。这一个做法其实更多起到说明作用，表明这个函数引用了外部变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> outer_var = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> inner = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">int</span> outer_var;  <span class="comment">// 可忽略该声明，该声明更多起到说明作用</span></span><br><span class="line">  inner += outer_var;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><strong>从其他源代码文件中引用</strong>：如果一个源代码文件使用的外部变量定义在另一个源代码文件中，则必须用extern在该文件中声明该变量。如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> outer_var;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> other_file;   <span class="comment">// other_file定义在其他源代码文文件中，使用前必须使用extern声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>初始化外部变量</strong>：外部变量和自动变量类似，也可以被显式初始化。与自动变量不同的是，如果未初始化外部变量，它们会被自动初始化为 0。这一原则也适用于外部定义的数组元素。同时，外部变量只能初始化一次，且必须在定义该变量时进行。假设有下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1 one.c</span></span><br><span class="line"><span class="keyword">char</span> permis = <span class="string">'N'</span>;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// file2 tow.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> permis = <span class="string">'Y'</span>   <span class="comment">// 错误，file1已经声明并初始化了permis</span></span><br></pre></td></tr></table></figure>

<p><strong>同时，声明静态变量时，必须使用常量表达式，不可用变量。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">2</span>;                <span class="comment">// 允许</span></span><br><span class="line"><span class="keyword">int</span> y = <span class="number">3</span> +<span class="number">20</span>;            <span class="comment">// 允许</span></span><br><span class="line"><span class="keyword">size_t</span> z = <span class="keyword">sizeof</span>(<span class="keyword">int</span>);   <span class="comment">// 允许，sizeof(int)视为常量</span></span><br><span class="line"><span class="keyword">int</span> x2 = <span class="number">2</span> * x;           <span class="comment">// 不允许，x是变量</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><strong>函数内部声明重名变量</strong>：如果在函数内声明一个与外部变量重名的变量，则外部变量会被隐藏，在函数内部使用新声明的变量。</li>
</ul>
<h4 id="内部链接的静态变量"><a href="#内部链接的静态变量" class="headerlink" title="内部链接的静态变量"></a>内部链接的静态变量</h4><p>该存储类别的变量具有静态存储期、文件作用域和内部链接。在所有函数外部，用存储类别说明符static定义的变量具有这种存储类别。与外部链接的静态变量不同，内部链接的静态变量只能在当前源代码文件(翻译单元)中使用，不能在其他源代码文件中使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>[<span class="number">6</span>] = <span class="string">"Hello"</span>;</span><br></pre></td></tr></table></figure>

<p><strong>同时，声明静态变量时，必须使用常量表达式，不可用变量。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">2</span>;                <span class="comment">// 允许</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> y = <span class="number">3</span> +<span class="number">20</span>;            <span class="comment">// 允许</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> z = <span class="keyword">sizeof</span>(<span class="keyword">int</span>);   <span class="comment">// 允许，sizeof(int)视为常量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x2 = <span class="number">2</span> * x;           <span class="comment">// 不允许，x是变量</span></span><br></pre></td></tr></table></figure>



<h4 id="储存类型与函数"><a href="#储存类型与函数" class="headerlink" title="储存类型与函数"></a>储存类型与函数</h4><p>函数也有存储类别，可以是外部函数（默认）或静态函数。外部函数可以被其他源代码文件的函数访问，但是静态函数只能用于其定义所在的源代码文件内。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">gamma</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">beta</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在同一个程序中，其他文件中的函数可以调用gamma()，但是不能调用beta()，因为以static存储类别说明符创建的函数属于特定模块私有。这样做避免了名称冲突的问题，由于beta()受限于它所在的文件，所以在其他文件中可以使用与之同名的函数。</p>
<h2 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h2><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc()"></a>malloc()</h3><p>该函数接受一个参数：所需的内存字节数。malloc()函数会找到合适的空闲内存块，这样的内存是匿名的。也就是说， malloc()分配内存，但是不会为其赋名。然而，它确实返回动态分配内存块的首字节地址。 因此，可以把该地址赋给一个指针变量，并使用指针访问这块内存。molloc()的返回值是一个void指针，这个类型相当于一个“通用指针”，通常将该函数的返回值强制转换为匹配的类型。如果malloc()分配内存失败，则返回空指针。</p>
<ul>
<li>参数：所需的内存字节数</li>
<li>返回值：指向所分配内存块的void指针，可通过强制类型转换匹配适当的数据类型。如果分配失败，则返回空指针。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 使用malloc()创建一个含有30个double类型值的数组*/</span></span><br><span class="line"><span class="keyword">double</span> * ptd;</span><br><span class="line">ptd = (<span class="keyword">double</span> *)<span class="built_in">malloc</span>(<span class="number">30</span> * <span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">ptd[<span class="number">0</span>]；</span><br><span class="line">ptd[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>



<h3 id="free"><a href="#free" class="headerlink" title="free()"></a>free()</h3><p>通常,malloc()要与free()配套使用。free()函数的参数是之前malloc()返回的地址，该函数释放之前malloc()分配的内存。因此，<strong>动态分配内存的存储期从调用malloc()分配内存到调用free()释放内存为止</strong>。设想malloc()和 free()管理着一个内存池。每次调用malloc()分配内存给程序使用，每次调用 free()把内存归还内存池中，这样便可重复使用这些内存。如果不使用free()释放内存，可能在程序结束前耗尽内存。注意：不能用 free()释放通过其他方式（如，声明一个数组）分配的内存。</p>
<ul>
<li>参数：malloc()分配的内存块地址。不能是其他方式声明的数据的地址。</li>
</ul>
<h3 id="calloc"><a href="#calloc" class="headerlink" title="calloc()"></a>calloc()</h3><p>分配内存还可以使用calloc()，calloc()函数接受两个无符号整数作为参数（ANSI规定是size_t类型）。第1个参数是所需的存储单元数量，第2个参数是存储单元的大小（以字节为单位）。<strong>calloc()函数还有一个特性：它把块中的所有位都设置为0（注意，在某些硬件系统中，不是把所有位都设置为0来表示浮点值0）。</strong></p>
<ul>
<li>参数1: 所需存储单元数量(size_t)</li>
<li>参数2: 所需存储单元的大小(size_t)，以字节为单位</li>
<li>返回值：指向所分配内存块的void指针，可通过强制类型转换匹配适当的数据类型</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*使用calloc()创建一个包含100个long类型值的数组*/</span></span><br><span class="line"><span class="keyword">long</span> * newmem;</span><br><span class="line">newmem = (<span class="keyword">long</span>*)<span class="built_in">calloc</span>(<span class="number">100</span>, <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br></pre></td></tr></table></figure>



<h3 id="变长数组-VLA-和malloc-创建数组"><a href="#变长数组-VLA-和malloc-创建数组" class="headerlink" title="变长数组(VLA)和malloc()创建数组"></a>变长数组(VLA)和malloc()创建数组</h3><h4 id="动态数组-dynamic-array"><a href="#动态数组-dynamic-array" class="headerlink" title="动态数组(dynamic array)"></a>动态数组(dynamic array)</h4><p>现在，我们有3种创建数组的方法:</p>
<ul>
<li>声明数组时，用常量表达式表示数组的维度，用数组名访问数组的元素。可以用静态内存或自动内存创建这种数组。</li>
<li>声明变长数组（C99新增的特性）时，用变量表达式表示数组的维度， 用数组名访问数组的元素。具有这种特性的数组只能在自动内存中创建。</li>
<li>声明一个指针，调用malloc()，将其返回值赋给指针，使用指针访问数组的元素。该指针可以是静态的或自动的。</li>
</ul>
<p>使用第2种和第3种方法可以创建动态数组（dynamic array）。这种数组和普通数组不同，可以在程序运行时选择数组的大小和分配内存，使用动态数组给程序带来了更多灵活性。</p>
<h4 id="异同点"><a href="#异同点" class="headerlink" title="异同点"></a>异同点</h4><ul>
<li><p>相同点</p>
<ul>
<li>都可以在程序运行中确定数组的大小</li>
</ul>
</li>
<li><p>不同点</p>
<ul>
<li>变长数组是自动存储类型，程序在离开变长数组定义所在的块时，变长数组占用的内存空间会被自动释放，不必使用 free()。</li>
<li>用malloc()创建的数组不必局限在一个函数内访问。例如，可以这样做：函数创建一个数组并返回指针，供主调函数访问，然后主调函数在末尾调用free()释放之前分配的内存。</li>
</ul>
</li>
</ul>
<p>对多维数组而言，使用变长数组更方便。当然，也可以用 malloc()创建 二维数组，但是语法比较繁琐。如果编译器不支持变长数组特性，就只能固定二维数组的维度，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> m = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> ar2[n][m];  <span class="comment">// VLA</span></span><br><span class="line"><span class="keyword">int</span> (*p2)[<span class="number">6</span>];   <span class="comment">// pre-C99</span></span><br><span class="line"><span class="keyword">int</span> (*p3)[m];   <span class="comment">// VLA support</span></span><br><span class="line">p2 = (<span class="keyword">int</span> (*)[<span class="number">6</span>])<span class="built_in">malloc</span>(n * <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">p2 = (<span class="keyword">int</span> (*)[m])<span class="built_in">malloc</span>(n * m * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));  <span class="comment">// VLA support</span></span><br></pre></td></tr></table></figure>



<h3 id="存储类别的动态内存分配"><a href="#存储类别的动态内存分配" class="headerlink" title="存储类别的动态内存分配"></a>存储类别的动态内存分配</h3><p>存储类别和动态内存分配有何联系？我们来看一个理想化模型。可以认为程序把它可用的内存分为3部分：一部分供具有外部链接、内部链接和无链接的静态变量使用；一部分供自动变量使用；一部分供动态内存分配。</p>
<ul>
<li>静态存储：静态存储类别所用的内存数量在编译时确定，只要程序还在运行，就可访问储存在该部分的数据。该类别的变量在程序开始执行时被创建，在程序 结束时被销毁。</li>
<li>自动存储：自动存储类别的变量在程序进入变量定义所在块时存在，在程序离开块时消失。因此，随着程序调用函数和函数结束，自动变量所用的内存数量也相应地增加和减少。<strong>这部分的内存通常作为栈来处理，</strong>这意味着新创建的变量按顺序加入内存，然后以相反的顺序销毁。</li>
<li>动态分配：动态分配的内存在调用 malloc()或相关函数时存在，在调用 free()后释放。这部分的内存由程序员管理。所以内存块可以在一个函数中创建，在另一个函数中销毁。正是因为这样，这部分的内存用于动态内存分配会支离破碎。也就是说，未使用的内存块分散在已使用的内存块之间。另外，使用动态内存通常比使用栈内存慢。</li>
</ul>
<h2 id="ANSI-C类型限定符-type-qualifier"><a href="#ANSI-C类型限定符-type-qualifier" class="headerlink" title="ANSI C类型限定符(type qualifier)"></a>ANSI C类型限定符(type qualifier)</h2><h3 id="const类型限定符"><a href="#const类型限定符" class="headerlink" title="const类型限定符"></a>const类型限定符</h3><p>以const关键字声明的对象，其值不能通过赋值或递增、递减来修改:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> nochange;</span><br><span class="line">nochange = <span class="number">12</span>;         <span class="comment">// 不允许</span></span><br><span class="line">nochange++;            <span class="comment">// 不允许</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>在指针和形参中使用const</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> * pf;</span><br><span class="line"><span class="keyword">float</span> <span class="keyword">const</span> * pf;  <span class="comment">// 与上式等效，const只要在 * 就可</span></span><br></pre></td></tr></table></figure>

<p>创建了 pf 指向的值不能被改变，而 pf 本身的值可以改变。例如，可以设置该指针指向其他 const值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> * <span class="keyword">const</span> pt;</span><br></pre></td></tr></table></figure>

<p>创建的指针pt本身的值不能更改。pt必须指向同一个地址，但是它所指向的值可以改变。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> * <span class="keyword">const</span> ptr;</span><br></pre></td></tr></table></figure>

<p>表明ptr既不能指向别处，它所指向的值也不能改变。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> limit)</span></span>;</span><br></pre></td></tr></table></figure>

<p>const 关键字的常见用法是声明为函数形参的指针。例如，假设有一个函数要调用 display()显示一个数组的内容。要把数组名作为实际参数传递给该函数，但是数组名是一个地址。该函数可能会更改主调函数中的数据，但是上面的函数原型保证了数据不会被更改。</p>
</li>
<li><p>对全局数据使用const</p>
<p>前面讲过，使用全局变量是一种冒险的方法，因为这样做暴露了数据， 程序的任何部分都能更改数据。如果把数据设置为 const，就可避免这样的危险，因此用 const 限定符声明全局数据很合理。</p>
<p>然而，在文件间共享const数据要小心。可以采用两个策略。</p>
<ul>
<li><p>第一，遵循外部变量的常用规则，即在一个文件中使用定义式声明，在其他文件中使用引用式声明（用extern关键字）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* file1.c */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.14159</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* file2.c */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">double</span> PI;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二，把const变量放在一个头文件中，然后在其他文件中包含该头文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* constant.h */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.14159</span>;  <span class="comment">// 必须使用static</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* file1.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"constant.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* file2.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"constant.h"</span></span></span><br></pre></td></tr></table></figure>

<p><strong>这种方案必须在头文件中用关键字static声明全局const变量</strong>。如果去掉 static，那么在file1.c和file2.c中包含constant.h将导致每个文件中都有一个相同标识符的定义式声明，C标准不允许这样做。实际上，这种方案相当于给每个文件提供了一个单独的数据副本。每个副本只对该文件可见，所以无法用这些数据和其他文件通信。不过没关系，它们都是完全相同（每个文件都包含相同的头文件）的const数据。</p>
</li>
</ul>
</li>
</ul>
<h3 id="volatile类型限定符"><a href="#volatile类型限定符" class="headerlink" title="volatile类型限定符"></a>volatile类型限定符</h3><p>volatile 限定符告知计算机，代理（而不是变量所在的程序）可以改变该变量的值。通常，它被用于硬件地址以及在其他程序或同时运行的线程中共享数据。例如，一个地址上可能储存着当前的时钟时间，无论程序做什么，地址上的值都随时间的变化而改变。或者一个地址用于接受另一台计算机传入的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> loc;</span><br><span class="line">volative <span class="keyword">int</span> * ploc;</span><br></pre></td></tr></table></figure>

<p>volatile类型限定符的作用在于编译器的优化，例如下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val1 = x;</span><br><span class="line">val2 = x;</span><br></pre></td></tr></table></figure>

<p>智能的（进行优化的）编译器会注意到以上代码使用了两次 x，但并未改变它的值。于是编译器把 x的值临时储存在寄存器中，然后在val2需要使用x时，才从寄存器中（而不是从原始内存位置上）读取x的值，以节约时间。这个过程被称为高速缓存（caching）。通常，高速缓存是个不错的优化方案，但是如果一些其他代理在以上两条语句之间改变了x的值，就不能这样优化了。如果没有volatile关键字，编译器就不知道这种事情是否会发生。因此，为安全起见，编译器不会进行高速缓存。这是在 ANSI 之前的情况。现在，如果声明中没有volatile关键字，编译器会假定变量的值在使用过程中不变，然后再尝试优化代码。</p>
<p><strong>可以同时用const和volatile限定一个值</strong>。例如，通常用const把硬件时钟设置为程序不能更改的变量，但是可以通过代理改变，这时用 volatile。只能在声明中同时使用这两个限定符，它们的顺序不重要，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">const</span> <span class="keyword">int</span> loc1;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keyword">int</span> loc2;</span><br></pre></td></tr></table></figure>



<h3 id="restirct类型限定符"><a href="#restirct类型限定符" class="headerlink" title="restirct类型限定符"></a>restirct类型限定符</h3><p>restrict 关键字允许编译器优化某部分代码以更好地支持计算。<strong>它只能用于指针，表明该指针是访问数据对象的唯一且初始的方式</strong>，以下面的代码为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ar[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">restrict</span> restar = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">int</span> *par = ar;</span><br></pre></td></tr></table></figure>

<p>这里，指针restar是访问由malloc()所分配内存的<strong>唯一且初始</strong>的方式。因此，可以用restrict关键字限定它。而指针par既不是访问ar数组中数据的初始 方式，也不是唯一方式。所以不能把它设置为restrict。</p>
<p>现在考虑下面稍复杂的例子，其中n是int类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; <span class="number">10</span>; n++)</span><br><span class="line">&#123;</span><br><span class="line">  par[n] += <span class="number">5</span>;</span><br><span class="line">  restar[n] += <span class="number">5</span>;</span><br><span class="line">  ar[n] *= <span class="number">2</span>;</span><br><span class="line">  par[n] += <span class="number">3</span>;</span><br><span class="line">  restar[n] += <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于之前声明了 restar 是访问它所指向的数据块的唯一且初始的方式， 编译器可以把涉及 restar的两条语句替换成下面这条语句，效果相同：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">restar[<span class="number">0</span>] += <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<p>但是，如果把与par相关的两条语句替换成下面的语句，将导致计算错误：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">par[<span class="number">0</span>] += <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<p>这是因为for循环在par两次访问相同的数据之间，用ar改变了该数据的值。</p>
<p>在本例中，如果未使用restrict关键字，编译器就必须假设最坏的情况 （即，在两次使用指针之间，其他的标识符可能已经改变了数据）。如果用 了restrict关键字，编译器就可以选择捷径优化计算。</p>
<p>restrict限定符还可用于函数形参中的指针。这意味着编译器可以假定在函数体内其他标识符不会修改该指针指向的数据，而且编译器可以尝试对其优化，使其不做别的用途。</p>
<p>需要关注restrict 关键字的两者。一个是编译器，该关键字告知编译器可以自由假定一些优化方案。另一个是用户，该关键字告知用户要使用满足 restrict要求的参数。总而言之，编译器不会检查用户是否遵循这一限制，但是无视它后果自负。</p>
<h3 id="Atomic类型限定符"><a href="#Atomic类型限定符" class="headerlink" title="Atomic类型限定符"></a>Atomic类型限定符</h3><p>并发程序设计把程序执行分成可以同时执行的多个线程。这给程序设计 带来了新的挑战，包括如何管理访问相同数据的不同线程。C11通过包含可选的头文件stdatomic.h和threads.h，提供了一些可选的管理方法。值得注意的是，<strong>要通过各种宏函数来访问原子类型。当一个线程对一个原子类型的对象执行原子操作时，其他线程不能访问该对象。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_Atomic <span class="keyword">int</span> hogs;           <span class="comment">// hogs是一个原子类型的变量</span></span><br><span class="line">atomic_store(&amp;hogs, <span class="number">12</span>);    <span class="comment">// stdatomic.h中的宏</span></span><br></pre></td></tr></table></figure>

<p>这里，在hogs中储存12是一个原子过程，其他线程不能访问hogs。</p>
<h3 id="旧关键字的新位置"><a href="#旧关键字的新位置" class="headerlink" title="旧关键字的新位置"></a>旧关键字的新位置</h3><p>C99允许把类型限定符和存储类别说明符static放在函数原型和函数头的形式参数的初始方括号中。对于类型限定符而言，这样做为现有功能提供了一个替代的语法。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mufunc</span><span class="params">(<span class="keyword">int</span> * <span class="keyword">const</span> a1, <span class="keyword">int</span> * <span class="keyword">restrict</span> a2, <span class="keyword">int</span> n)</span></span>;  <span class="comment">// 旧语法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">(<span class="keyword">int</span> a1[<span class="keyword">const</span>], <span class="keyword">int</span> a2[<span class="keyword">restrict</span>], <span class="keyword">int</span> n)</span></span>;    <span class="comment">// 新的等价语法，C99</span></span><br></pre></td></tr></table></figure>

<p><strong>static的情况不同，因为新标准为static引入了一种与以前用法不相关的新用法</strong>。现在，static除了表明静态存储类别变量的作用域或链接外，新的用法告知编译器如何使用形式参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">stick</span><span class="params">(<span class="keyword">double</span> ar[<span class="keyword">static</span> <span class="number">20</span>])</span></span>;</span><br></pre></td></tr></table></figure>

<p>static 的这种用法表明，函数调用中的实际参数应该是一个<strong>指向数组首元素的指针，且该数组至少有20个元素</strong></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/06/13/%E7%BB%93%E6%9E%84%E5%92%8C%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E5%BD%A2%E5%BC%8F/" rel="prev" title="结构和其他数据形式">
      <i class="fa fa-chevron-left"></i> 结构和其他数据形式
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/06/13/%E4%BD%8D%E8%BF%90%E7%AE%97/" rel="next" title="位运算">
      位运算 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#存储类型"><span class="nav-number">1.</span> <span class="nav-text">存储类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#标识符"><span class="nav-number">1.1.</span> <span class="nav-text">标识符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作用域、链接、储存期"><span class="nav-number">1.2.</span> <span class="nav-text">作用域、链接、储存期</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#作用域"><span class="nav-number">1.2.1.</span> <span class="nav-text">作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#链接"><span class="nav-number">1.2.2.</span> <span class="nav-text">链接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#储存期"><span class="nav-number">1.2.3.</span> <span class="nav-text">储存期</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#储存类别"><span class="nav-number">1.3.</span> <span class="nav-text">储存类别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#自动变量"><span class="nav-number">1.3.1.</span> <span class="nav-text">自动变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#寄存器变量"><span class="nav-number">1.3.2.</span> <span class="nav-text">寄存器变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#块作用域的静态变量"><span class="nav-number">1.3.3.</span> <span class="nav-text">块作用域的静态变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#外部链接的静态变量"><span class="nav-number">1.3.4.</span> <span class="nav-text">外部链接的静态变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部链接的静态变量"><span class="nav-number">1.3.5.</span> <span class="nav-text">内部链接的静态变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#储存类型与函数"><span class="nav-number">1.3.6.</span> <span class="nav-text">储存类型与函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分配内存"><span class="nav-number">2.</span> <span class="nav-text">分配内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc"><span class="nav-number">2.1.</span> <span class="nav-text">malloc()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#free"><span class="nav-number">2.2.</span> <span class="nav-text">free()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#calloc"><span class="nav-number">2.3.</span> <span class="nav-text">calloc()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变长数组-VLA-和malloc-创建数组"><span class="nav-number">2.4.</span> <span class="nav-text">变长数组(VLA)和malloc()创建数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#动态数组-dynamic-array"><span class="nav-number">2.4.1.</span> <span class="nav-text">动态数组(dynamic array)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#异同点"><span class="nav-number">2.4.2.</span> <span class="nav-text">异同点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#存储类别的动态内存分配"><span class="nav-number">2.5.</span> <span class="nav-text">存储类别的动态内存分配</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ANSI-C类型限定符-type-qualifier"><span class="nav-number">3.</span> <span class="nav-text">ANSI C类型限定符(type qualifier)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#const类型限定符"><span class="nav-number">3.1.</span> <span class="nav-text">const类型限定符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile类型限定符"><span class="nav-number">3.2.</span> <span class="nav-text">volatile类型限定符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#restirct类型限定符"><span class="nav-number">3.3.</span> <span class="nav-text">restirct类型限定符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Atomic类型限定符"><span class="nav-number">3.4.</span> <span class="nav-text">Atomic类型限定符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#旧关键字的新位置"><span class="nav-number">3.5.</span> <span class="nav-text">旧关键字的新位置</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">崔梓坤</p>
  <div class="site-description" itemprop="description">我的计算机学习经历和笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">崔梓坤</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
